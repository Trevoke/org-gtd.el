;;; org-gtd-archive.el --- Logic to archive tasks -*- lexical-binding: t; coding: utf-8 -*-
;;
;; Copyright Â© 2019-2023, 2025 Aldric Giacomoni

;; Author: Aldric Giacomoni <trevoke@gmail.com>
;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 3, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this file.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:
;;
;; Archiving logic for org-gtd
;;
;;; Code:

;;;; Requirements

(require 'f)
(require 'org-archive)
(require 'org-element)

(require 'org-gtd-core)
(require 'org-gtd-agenda)

;;;; Customization

(defgroup org-gtd-archive nil
  "How to archive completed / canceled items."
  :group 'org-gtd
  :package-version '(org-gtd . "3.0.0"))

(defcustom org-gtd-archive-location #'org-gtd-archive-location-func
  "Function to generate archive location for org gtd.

That is to say, when items get cleaned up from the active files, they will go
to whatever file/tree is generated by this function.  See `org-archive-location'
to learn more about the valid values generated.  Note that this will only be
the file used by the standard `org-archive' functions if you
enable command `org-gtd-mode'.  If not, this will be used only by
org-gtd's archive behavior.

This function has an arity of zero.  By default this generates a file
called gtd_archive_<currentyear> in `org-gtd-directory' and puts the entries
into a datetree."
  :group 'org-gtd-archive
  :package-version '(org-gtd . "2.0.0")
  :type 'sexp)

;;;; Constants

(defconst org-gtd-archive-file-format "gtd_archive_%s"
  "File name format for where org-gtd archives things by default.")

;;;; Commands

;;;###autoload
(defun org-gtd-archive-completed-items ()
  "Archive everything that needs to be archived in your org-gtd."
  (interactive)
  (with-org-gtd-context
      ;; Prepare all agenda buffers first
      (org-gtd-core-prepare-agenda-buffers)

      ;; Update org-id locations to ensure graph traversal can find all tasks
      ;; Filter out directories, only pass actual files
      (org-id-update-id-locations
       (seq-filter #'file-regular-p (org-gtd-core--agenda-files)))

      ;; Archive projects
      (org-gtd--archive-complete-projects)

    ;; Archive actions, calendar items, and incubated items
    ;; Exclude project tasks (those with ORG_GTD_PROJECT property)
    (org-map-entries #'org-gtd--archive-completed-actions
                     "+ORG_GTD=\"Actions\"-ORG_GTD_PROJECT={.+}"
                     'agenda)
    (org-map-entries #'org-gtd--archive-completed-actions
                     "+ORG_GTD=\"Calendar\""
                     'agenda)
    (org-map-entries #'org-gtd--archive-completed-actions
                     "+ORG_GTD=\"Incubated\""
                     'agenda)))

(defun org-gtd-archive-item-at-point ()
  "Dirty hack to force archiving where I know I can."
  (interactive)
  (with-temp-message ""
    (let* ((last-command nil)
           (temp-file (make-temp-file org-gtd-directory nil ".org"))
           (buffer (find-file-noselect temp-file)))
      (org-copy-subtree)
      (org-gtd-core-prepare-buffer buffer)
      (with-current-buffer buffer
        (org-paste-subtree)
        (goto-char (point-min))
        (with-org-gtd-context (org-archive-subtree))
        (basic-save-buffer)
        (kill-buffer))
      (delete-file temp-file))))

;;;; Functions

;;;;; Public

(defun org-gtd-archive-location-func ()
  "Default function to define where to archive items."
  (let* ((year (number-to-string (caddr (calendar-current-date))))
         (full-org-gtd-path (expand-file-name org-gtd-directory))
         (filename (format org-gtd-archive-file-format year))
         (filepath (f-join full-org-gtd-path filename)))
    (string-join `(,filepath "::" "datetree/"))))

;;;;; Private

(defun org-gtd--all-project-tasks-done-p ()
  "Return t if all tasks connected to current project are done.
Uses graph traversal to find all project tasks via BLOCKS/DEPENDS_ON relationships.
Falls back to checking immediate children if no dependency-tracked tasks exist."
  (require 'org-gtd-projects)
  (let* ((project-marker (point-marker))
         (tasks (org-gtd-projects--collect-tasks-by-graph project-marker)))
    (if tasks
        ;; Has dependency-tracked tasks - check if all done
        (seq-every-p
         (lambda (task-marker)
           (org-with-point-at task-marker
             (eq (org-element-property :todo-type (org-element-at-point)) 'done)))
         tasks)
      ;; No dependency tracking - check immediate children
      (let ((all-done t))
        (save-excursion
          (org-back-to-heading t)
          (let ((level (org-current-level)))
            (outline-next-heading)
            (while (and (not (eobp)) (> (org-current-level) level))
              (when (= (org-current-level) (1+ level))
                (unless (eq (org-element-property :todo-type (org-element-at-point)) 'done)
                  (setq all-done nil)))
              (outline-next-heading))))
        all-done))))

(defun org-gtd--archive-project-with-tasks ()
  "Archive current project heading and all its tasks in breadth-first order.

First archives the project heading, then archives all connected tasks as children
of the archived project heading, ordered breadth-first by their dependencies."
  (require 'org-gtd-projects)
  (let* ((project-marker (point-marker))
         (project-id (org-entry-get (point) "ID"))
         (tasks (org-gtd-projects--collect-tasks-by-graph project-marker)))

    ;; Step 1: Archive the project heading first
    ;; This creates the archived project that tasks will be refiled under
    (org-archive-subtree-default)

    ;; Step 2: Archive and refile each task under the archived project
    ;; Tasks are already in breadth-first order from collect-tasks-by-graph
    (when (and project-id tasks)
      ;; Find the archived project using its ID
      (let ((archived-project-marker (org-id-find project-id t)))
        (when archived-project-marker
          (dolist (task-marker tasks)
            ;; Check if task still exists (wasn't already archived as part of project subtree)
            (when (and (marker-buffer task-marker)
                       (marker-position task-marker)
                       (with-current-buffer (marker-buffer task-marker)
                         (save-excursion
                           (goto-char (marker-position task-marker))
                           ;; Verify we're at a valid heading
                           (org-at-heading-p))))
              (org-with-point-at task-marker
                ;; Archive the task to the same archive location
                (org-archive-subtree-default)

                ;; Find the archived task using its ID to refile it
                (let ((task-id (org-entry-get task-marker "ID")))
                  (when task-id
                    (let ((archived-task-marker (org-id-find task-id t)))
                      (when (and archived-task-marker
                                 (marker-buffer archived-project-marker)
                                 (buffer-live-p (marker-buffer archived-project-marker)))
                        ;; Refile the archived task under the archived project
                        (org-with-point-at archived-task-marker
                          (org-refile nil nil
                                    (list nil
                                          (marker-buffer archived-project-marker)
                                          nil
                                          (marker-position archived-project-marker))))))))))))))))

(defun org-gtd--archive-complete-projects ()
  "Archive all projects for which all actions/tasks are marked as done.

Done here is any done `org-todo-keyword'.  For org-gtd this means `org-gtd-done'
or `org-gtd-canceled'.

Archives project heading first, then tasks in breadth-first order as children
of the archived project."
  (org-map-entries
   (lambda ()
     ;; Skip category headings that contain other projects
     (let ((has-project-children nil))
       (save-excursion
         (org-back-to-heading t)
         (let ((level (org-current-level)))
           (outline-next-heading)
           (while (and (not (eobp)) (not has-project-children) (> (org-current-level) level))
             (when (string= (org-entry-get (point) "ORG_GTD") "Projects")
               (setq has-project-children t))
             (outline-next-heading))))

       (when (and (not has-project-children)
                  (org-gtd--all-project-tasks-done-p))
         (setq org-map-continue-from
               (org-element-property :begin (org-element-at-point)))
         (org-gtd--archive-project-with-tasks))))
   "+ORG_GTD=\"Projects\""
   'agenda))

(defun org-gtd--archive-completed-actions ()
  "Private function.  With point on heading, archive if entry is done."
  (if (org-entry-is-done-p)
      (progn
        (setq org-map-continue-from (org-element-property
                                     :begin
                                     (org-element-at-point)))
        (org-archive-subtree-default))))

;;;; Footer

(provide 'org-gtd-archive)

;;; org-gtd-archive.el ends here
