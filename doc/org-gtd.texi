\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename ../org-gtd.info
@settitle Org GTD User Manual
@documentencoding UTF-8
@documentlanguage en
@c %**end of header

@copying
Copyright (C) 2018-2025 Aldric Giacomoni <trevoke@@gmail.com>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE@.  See the GNU
General Public License for more details.
@end copying

@dircategory Emacs
@direntry
* Org GTD: (org-gtd).   An opinionated GTD flow implemented in org-mode.
@end direntry

@finalout
@titlepage
@title Org GTD User Manual
@subtitle for version 4.0
@author Aldric Giacomoni
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top
@top Org GTD User Manual

Org GTD is an attempt to implement the GTD flow described in the GTD
book as faithfully as possible.

@noindent
This manual is for Org GTD version 4.0
@end ifnottex

@menu
* Summary::                      quick intro to GTD
* What's new in 4.0: What's new in 40. 
* Setting up Org GTD::
* Getting Started with Org GTD:: Tutorials to get you productive quickly
* Using Org GTD::                How Org GTD maps to the GTD flow
* Reference::                    Complete reference for all org-gtd features
* Troubleshooting::

@detailmenu
--- The Detailed Node Listing ---

What's new in 4.0

* Flexible project dependencies (the big one!)::
* Simplified keyword configuration::
* Data-driven configuration::
* Declarative view language::
* Better project modification::
* Enhanced review capabilities::
* Simplified configuration::
* What you need to do::
* Previous versions::

Setting up Org GTD

* Upgrading::                    How to upgrade your local setup across major versions
* Installing::                   Get Org GTD in your emacs
* Configuring::                  Required and optional system configuration

Upgrading

* 4.0.0 <- 3.x.x: 400 <- 3xx. 


Installing

* use-package::
* Manually::


Configuring

* Basic setup::
* Complete Configuration Examples::
* Understanding Keybindings::
* Required configuration of sub-packages::
* configuration options for org-gtd::
* Recommended key bindings::
* Sample Doom Emacs Config::


Getting Started with Org GTD

* Quick Start Reference::
* Tutorial Your First Project::
* Tutorial Creating Your First Custom View::

Tutorial: Your First Project

* What You'll Learn::
* The Project::
* Step 1 Capture the Project::
* Step 2 Process the Inbox::
* Step 3 Organize as a Project::
* Step 4 View in Engage::
* Step 5 Complete the First Task::
* Step 6 Refresh and See the Change::
* What Just Happened?::
* Continue the Project::
* Key Takeaways::
* What's Next?::


Tutorial: Creating Your First Custom View

* What You'll Learn: What You'll Learn (1). 
* Why This View?::
* Understanding the View DSL::
* Creating the View Function::
* Using Your View::
* Binding to a Key::
* What You'll See::
* Experiment Modify the View::
* Available Filters::
* Key Takeaways: Key Takeaways (1). 
* What's Next?: What's Next? (1). 
* Where to Go From Here::


Using Org GTD

* Your Daily Workflow::          The GTD cycle you'll practice every day
* The GTD Flow in Depth::        Detailed explanation of each GTD step
* Understanding GTD Item Types:: When to use each type in the organize menu
* Working with Projects (Advanced)::
* Automating through emacs::

Your Daily Workflow

* Quick command reference::


The GTD Flow in Depth

* Adding things to the inbox::
* Processing the inbox::
* Clarifying each item::
* Organizing an item into the system::
* Engaging with your GTD items::


Understanding GTD Item Types

* Single Action [S]::
* Project [P]::
* Add to existing project [A]::
* Calendar [C]::
* Delegate [D]::
* Quick Action [Q]::
* Incubate [I]::
* Habit [H]::
* Knowledge [K]::
* Trash [T]::
* Working with the GTD Horizons::


Working with Projects (Advanced)

* Quick Navigation::
* First Contact Why Visual Project Management?::
* Black Triangle Your First Project Graph View::
* Understanding Project Dependencies::
* Tutorial Parallel Tasks with Graph View::
* Tutorial Complex Dependencies with Graph View::
* Common Dependency Patterns (Visual Reference)::
* Graph View Command Reference::
* Graph Rendering Modes::
* Complete Keyboard Reference::
* Auto-Refresh on File Changes::
* Technical Details::
* Practical Tips for Project Management::
* Exporting Project Graphs::
* Troubleshooting Projects with Graph View::
* See Also::
* Incubating Projects Pausing Work You're Not Ready For::
* NEXT Task 1 Research options::
* Task 1 Research options::
* Project Progress Cookies See Your Progress at a Glance::
* Cleaning up / archiving completed work::
* Commands you can call on org-agenda::
* Defining your own agenda views::
* Adding your own hooks when organizing::


Reference

* Configuration Variables Reference:: All customization variables explained
* Commands Reference::           All interactive commands explained
* Properties Reference (Internal Implementation):: All org properties used by org-gtd
* Troubleshooting Projects::     How to fix project dependency problems
* View DSL Filter Reference::    Complete reference for the View DSL
* Hooks Framework Reference::    Complete guide to customization hooks

Configuration Variables Reference

* Required Configuration::
* Directory and File Configuration::
* Capture Configuration::
* Organize and Process Configuration::
* Clarification Configuration::
* Areas of Focus Configuration::
* Engage View Configuration::
* Archive Configuration::
* Missed Engagements Review Configuration::
* ID Overlay Configuration::
* Advanced Item Configuration::
* Projects Configuration::
* Obsolete Variables (Do Not Use)::


Commands Reference

* Core GTD Workflow Commands::
* Review Commands::
* Stuck Item Review Commands::
* Review Commands (Missed Engagements)::
* Review Commands (Upcoming Delegated)::
* Custom View Commands::
* Clarification Commands::
* Archive Commands::
* Agenda-Specific Commands::
* Project Management Commands::
* Task Dependency Commands::
* Area of Focus Commands::
* Programmatic Creation Commands::
* Utility Commands::
* ID Overlay Commands::
* Migration and Upgrade Commands::
* Obsolete Commands::


Properties Reference (Internal Implementation)

* Core GTD Properties::
* Project Properties::
* Task Dependency Properties::
* Calendar and Time Properties::
* Delegation Properties::
* Habit Properties::
* Area of Focus Properties::
* Standard Org Properties Used by org-gtd::


Troubleshooting Projects

* Fixing Broken Dependencies::
* When Manual Property Editing is Needed::
* Common Problems and Solutions::


View DSL Filter Reference

* View Structure::
* Category Filters::
* Time-based Filters::
* Keyword Filters::
* Area of Focus Filters::
* Tag Filters::
* Property Filters::
* Structural Filters::
* Special Filters::
* View Configuration Options::
* Complete View Examples::
* Creating Custom Views::


Hooks Framework Reference

* What Are Organize Hooks?::
* Your First Hook in 2 Minutes::
* The org-gtd-organize-hooks Variable::
* Built-in Hooks::
* Writing Custom Hooks::
* Example Custom Hooks::
* Hook Execution Order::
* Best Practices::
* Complete Example Comprehensive Hook Setup::


Troubleshooting

* Finding lost tasks::
* Projects without a NEXT item::
* I can't create a project when clarifying an inbox item!::
* Configuration problems::
* Tasks still showing after incubating project::
* Still stuck?::

Configuration problems

* Keywords not working::
* Items not showing in engage view::


@end detailmenu
@end menu

@node Summary
@chapter Summary

This package tries to replicate as closely as possible the GTD workflow (see diagram below).

This package, and this documentation, assume familiarity with the flow of GTD as described in the book.

This package provides a system that allows you to capture incoming things into an inbox, then process the inbox and categorize each item based on the GTD categories. It leverages org-agenda to show today's items as well as the NEXT items. It provides a flexible project management system with support for both sequential and parallel task execution.

@strong{New to org-gtd?} Start with @ref{Getting Started with Org GTD} for a hands-on tutorial.

@strong{Upgrading from 3.x?} See @ref{Upgrading} for required configuration changes and migration steps.
@example
                                    +-------+
                                    |"STUFF"|
                                    +---+---+
                                        |
                                    +---v---+
                                    | INBOX |
                                    +---+---+
                                        |              Eliminate  +-----------+
                                        |            +----------->|  Trash    |
                                 +------v------+     |            +-----------+
                                 | What is it? |     |
                                 +------+------+     |            +-----------+
                                        |            | Incubate   |  Someday/ |
                                        |            +----------->|   Maybe   |
+----------+  YES (multi-step)   +------v------+  NO |            +-----------+
| Projects |<--------------------|    Is it    |-----+
+-+----^---+                     | Actionable? |     | File       +-----------+
  |    |   +----------------+    +------+------+     +----------->| Reference |
  |    |        Review for  |           |                         +-----------+
+-v----+---+     Actions    |           |
| Planning |                +---------->| YES
+----------+                            |
                                 +------v------+     Less than
                       Delegate  | What's the  |     2 minutes    +-----------+
                     +-----------+    NEXT     +----------------->|   DO IT   |
                     |           |   Action?   |                  +-----------+
                     |           +------+------+
                     |                  |
                     |                  | FOR ME:
                     |                  |         Specific Date or Time
                     |                  +-------------------------------+
                     |              ASAP|                               |
               +-----v-----+      +-----v-----+                   +-----v-----+
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               +-----------+      +-----------+                   +-----------+
                Waiting For        Next Actions                      Calendar
@end example

@node What's new in 40
@chapter What's new in 4.0

Version 4.0 is a major release that transforms how Org GTD handles projects and configuration, while maintaining compatibility with your existing GTD data.

@menu
* Flexible project dependencies (the big one!)::
* Simplified keyword configuration::
* Data-driven configuration::
* Declarative view language::
* Better project modification::
* Enhanced review capabilities::
* Simplified configuration::
* What you need to do::
* Previous versions::
@end menu

@node Flexible project dependencies (the big one!)
@section Flexible project dependencies (the big one!)

Projects are no longer limited to sequential tasks! You can now create complex project structures with parallel tasks and custom dependencies.

@itemize
@item
@strong{Define any dependency relationship} - Tasks can block other tasks, creating a directed acyclic graph (DAG) of dependencies
@item
@strong{Parallel work streams} - Multiple tasks can be NEXT at the same time if they don't depend on each other
@item
@strong{Automatic dependency detection} - Org GTD finds all tasks that are ready to work on based on the dependency graph
@item
@strong{Cycle prevention} - The system prevents circular dependencies that would create deadlocks
@item
@strong{Visual dependency helper} (optional) - See task relationships in a side window while clarifying projects
@end itemize

Tasks without explicit dependencies still work sequentially (as before), so your existing projects continue to work unchanged.

@node Simplified keyword configuration
@section Simplified keyword configuration

The new keyword configuration system is clearer and more maintainable:

@itemize
@item
@strong{One mapping instead of many variables} - Replace individual keyword variables (@code{org-gtd-next}, @code{org-gtd-todo}, etc.) with a single @code{org-gtd-keyword-mapping} structure
@item
@strong{Global TODO keywords} - No more file-level @code{#+TODO:} lines that can conflict. Use Emacs' global @code{org-todo-keywords} configuration instead
@item
@strong{Automatic validation} - Org GTD validates your keyword configuration and provides helpful error messages if something is wrong
@item
@strong{Better Emacs 29+ support} - Use @code{setopt} for automatic validation when setting variables
@end itemize

See @ref{Tell me all the levers I can pull, , Configuration options} for details.

@node Data-driven configuration
@section Data-driven configuration

New configuration system allows you to customize item properties declaratively:

@itemize
@item
@strong{Configure by item type} - Define what properties each GTD item type should have
@item
@strong{Prompt for user input} - Automatically prompt for dates, text, or custom data when organizing
@item
@strong{Extensible} - Easy to add your own custom configuration for new item types
@end itemize

@node Declarative view language
@section Declarative view language

Creating custom agenda views is now much easier with a declarative syntax:

@itemize
@item
@strong{Specify what you want, not how to get it} - Define views using simple filters instead of complex skip functions
@item
@strong{Built on org-ql} - Leverages the powerful org-ql query language for performance
@item
@strong{More maintainable} - View definitions are data structures, not code
@end itemize

@node Better project modification
@section Better project modification

@itemize
@item
@strong{Add tasks to projects anywhere} - You can now add tasks to projects even if the project file is outside @code{org-gtd-directory}
@item
@strong{Modify project structure} - Commands to create task dependencies and manage complex projects
@end itemize

@node Enhanced review capabilities
@section Enhanced review capabilities

@itemize
@item
@strong{Find missed items} - New @code{org-gtd-review-missed-items} command to catch things that slipped through
@item
@strong{Better stuck project detection} - Improved identification of projects that need attention
@end itemize

@node Simplified configuration
@section Simplified configuration

@itemize
@item
@strong{org-gtd-mode is obsolete} - No need for a special mode anymore. Just configure @code{org-agenda-files} and @code{org-edna} directly in your init file. The old mode was wrapping all agenda commands unnecessarily and had org-edna configured incorrectly.
@end itemize

@node What you need to do
@section What you need to do

If you're upgrading from 3.x, see the @ref{Upgrading, , Upgrading section} for complete step-by-step instructions. The required changes are:

@enumerate
@item
Update your keyword configuration to use @code{org-gtd-keyword-mapping}
@item
Remove any @code{#+TODO:} lines from your GTD files
@item
@strong{Run the migration: @code{M-x org-gtd-upgrade-v3-to-v4}} (required for projects to work!)
@end enumerate

For new installations, just configure @code{org-todo-keywords} and @code{org-gtd-keyword-mapping} and you're ready to go.

@node Previous versions
@section Previous versions

For changes in earlier versions, see:
@itemize
@item
@uref{whats-new-3.0.org, What's new in 3.0}
@end itemize

@node Setting up Org GTD
@chapter Setting up Org GTD

@menu
* Upgrading::                    How to upgrade your local setup across major versions
* Installing::                   Get Org GTD in your emacs
* Configuring::                  Required and optional system configuration
@end menu

@node Upgrading
@section Upgrading

If you are installing and not upgrading, you can skip this section entirely and just go to the next section, @ref{Installing}.

@menu
* 4.0.0 <- 3.x.x: 400 <- 3xx. 
@end menu

@node 400 <- 3xx
@subsection 4.0.0 <- 3.x.x

Version 4.0 introduces major improvements to keyword configuration and project management. Your existing GTD data will continue to work, but you'll need to update your configuration and optionally migrate to take full advantage of new features.

@itemize
@item
@anchor{Required Configuration changes}Required: Configuration changes


@strong{1. Update keyword configuration}

@strong{OLD way (version 3.x):}
@lisp
;; Individual keyword variables (no longer used)
(setq org-gtd-next "NEXT")
(setq org-gtd-todo "TODO")
(setq org-gtd-wait "WAIT")
(setq org-gtd-canceled "CNCL")
@end lisp

@strong{NEW way (version 4.0):}
@lisp
;; First, configure org-mode's global TODO keywords
;; All your GTD keywords must be in the same sequence
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))

;; Then map GTD semantic states to your keywords
;; Use setopt (Emacs 29+) for automatic validation, or setq for older versions
(setopt org-gtd-keyword-mapping
        '((todo . "TODO")      ;; tasks not ready to be acted upon
          (next . "NEXT")      ;; tasks ready to act on immediately
          (wait . "WAIT")      ;; tasks blocked or delegated
          (done . "DONE")      ;; tasks successfully completed
          (canceled . "CNCL"))) ;; tasks that won't be completed
@end lisp

Steps:
@enumerate
@item
Remove old keyword variables (@code{org-gtd-next}, @code{org-gtd-todo}, @code{org-gtd-wait}, @code{org-gtd-canceled} and their @code{-suffix} variants) from your configuration
@item
Remove any @code{#+TODO:} lines from your GTD org files (inbox.org, org-gtd-tasks.org, etc.)
@item
Add the global keyword configuration to your Emacs init file
@item
Ensure all GTD keywords appear in the @strong{same sequence} in @code{org-todo-keywords}
@end enumerate

@item
@anchor{Required Data migration}Required: Data migration


Version 4.0 changes how projects work internally. @strong{The old TRIGGER-based system no longer functions} - v4 uses dependency properties instead. You MUST run the migration for your existing projects to continue working.

@strong{Run the migration command:}

@lisp
M-x org-gtd-upgrade-v3-to-v4
@end lisp

@strong{Make a backup first!} The migration modifies your GTD files.

@strong{What the migration does:}

The migration performs two steps automatically:

@enumerate
@item
@strong{Adds ORG@math{_GTD} properties} to identify items:
@itemize
@item
Adds @code{ORG_GTD="Projects"} to project headings
@item
Adds @code{ORG_GTD="Actions"} to project tasks
@end itemize

@item
@strong{Converts projects to dependency-based system}:
@itemize
@item
Adds @code{ORG_GTD_DEPENDS_ON} and @code{ORG_GTD_BLOCKS} properties to create sequential task chains
@item
Adds @code{ORG_GTD_FIRST_TASKS} property to project headings
@item
Updates task states (NEXT/TODO) based on the new dependency graph
@end itemize
@end enumerate

@strong{After migration:}

@itemize
@item
Your projects continue to work sequentially (task 1 → task 2 → task 3)
@item
The sequential behavior is now implemented via dependency properties instead of TRIGGER
@item
You can now customize dependencies for individual projects if you want parallel tasks
@item
Safe to run multiple times if needed
@end itemize

@item
@anchor{Why these changes?}Why these changes?


@strong{Keyword configuration:}
@itemize
@item
Simpler: One mapping structure instead of multiple variables
@item
More reliable: Global configuration avoids file-level conflicts
@item
Better validation: Org GTD checks your configuration and provides helpful errors
@item
Future-proof: Easier to extend with new keyword types
@end itemize

@strong{Property-based system:}
@itemize
@item
More robust: Properties work reliably across different org-mode features
@item
More flexible: Enables features like multi-project tasks
@item
Better performance: Faster queries using org-ql
@end itemize

@item
@anchor{org-gtd-mode is obsolete}org-gtd-mode is obsolete


The @code{org-gtd-mode} minor mode is obsolete in version 4.0. It previously wrapped all org-agenda commands with org-gtd context, but this is no longer necessary because:

@enumerate
@item
All org-gtd commands (like @code{org-gtd-engage}) already have the right context
@item
Users should configure @code{org-agenda-files} directly
@item
Users should configure org-edna directly (the old mode had it configured incorrectly)
@end enumerate

If you were using @code{org-gtd-mode}, simply remove it and add these lines to your config:

@lisp
(setq org-agenda-files (list org-gtd-directory))
(org-edna-mode 1)
@end lisp
@end itemize

@node Installing
@section Installing

This package requires Emacs 28.1 or higher.

This package is on MELPA and MELPA stable under the name @code{org-gtd}.

@menu
* use-package::
* Manually::
@end menu

@node use-package
@subsection use-package

Just make sure this is loaded after @code{org-mode} like so.
@lisp
(use-package org-gtd :after org)
@end lisp

@node Manually
@subsection Manually

Check out the source code for dependencies and install them.
Then, clone this repo to a directory of your choice, e.g. @samp{~/.emacs.d/packages}.
Finally, add this to your config:
@lisp
(add-to-list 'load-path "~/.emacs.d/packages")
(require 'org-gtd)
@end lisp

@node Configuring
@section Configuring

@menu
* Basic setup::
* Complete Configuration Examples::
* Understanding Keybindings::
* Required configuration of sub-packages::
* configuration options for org-gtd::
* Recommended key bindings::
* Sample Doom Emacs Config::
@end menu

@node Basic setup
@subsection Basic setup

You need to configure three things for org-gtd to work:

@enumerate
@item
@strong{TODO keywords}: Configure @code{org-todo-keywords} with your GTD workflow states
@item
@strong{Keyword mapping}: Map GTD semantic states to your keywords with @code{org-gtd-keyword-mapping}
@item
@strong{org-edna}: Enable org-edna with inheritance for project dependencies to work
@end enumerate

See the configuration sections below for details.

Note: @code{org-gtd-mode} is obsolete as of version 4.0. Just configure org-agenda-files and org-edna directly.

@node Complete Configuration Examples
@subsection Complete Configuration Examples

@strong{Configuration is the most critical part of setup.} The examples below are complete, working configurations you can copy-paste into your init file.

@itemize
@item
@anchor{Example 1 Vanilla Emacs (Minimal Configuration)}Example 1: Vanilla Emacs (Minimal Configuration)


This is the simplest possible configuration for org-gtd. Copy this entire block into your init file:

@lisp
;; Configure org-mode TODO keywords
;; All GTD keywords MUST be in the same sequence
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))

;; Map GTD semantic states to your keywords
(setq org-gtd-keyword-mapping
      '((todo . "TODO")      ; tasks not ready to act on
        (next . "NEXT")      ; tasks ready to act on immediately
        (wait . "WAIT")      ; tasks blocked or delegated
        (done . "DONE")      ; tasks successfully completed
        (canceled . "CNCL"))) ; tasks that won't be completed

;; Optional: Set GTD directory (defaults to ~/gtd/)
;; (setq org-gtd-directory "~/my-gtd/")

;; Add org-gtd files to your agenda
(setq org-agenda-files (list org-gtd-directory))

;; REQUIRED: Enable org-edna for project dependencies
(org-edna-mode 1)

;; Global keybindings for GTD commands
;; These work anywhere in Emacs
(global-set-key (kbd "C-c d c") 'org-gtd-capture)
(global-set-key (kbd "C-c d e") 'org-gtd-engage)
(global-set-key (kbd "C-c d p") 'org-gtd-process-inbox)
(global-set-key (kbd "C-c d n") 'org-gtd-show-all-next)
(global-set-key (kbd "C-c d s") 'org-gtd-review-stuck-projects)

;; Keybinding for clarify map
;; This only works when you're in a clarify buffer
(with-eval-after-load 'org-gtd
  (define-key org-gtd-clarify-map (kbd "C-c c") 'org-gtd-organize))
@end lisp

@item
@anchor{Example 2 Doom Emacs Configuration}Example 2: Doom Emacs Configuration


If you use Doom Emacs, add this to your @code{packages.el}:

@lisp
(package! org-gtd)
@end lisp

Then add this to your @code{config.el}:

@lisp
(use-package! org-gtd
  :after org
  :custom
  (org-gtd-directory "~/gtd/")
  (org-todo-keywords '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
  (org-gtd-keyword-mapping '((todo . "TODO")
                             (next . "NEXT")
                             (wait . "WAIT")
                             (done . "DONE")
                             (canceled . "CNCL")))
  (org-agenda-files (list org-gtd-directory))
  :config
  (org-edna-mode)
  ;; Doom-style leader key bindings
  (map! :leader
        (:prefix ("d" . "org-gtd")
         :desc "Capture"        "c"  #'org-gtd-capture
         :desc "Engage"         "e"  #'org-gtd-engage
         :desc "Process inbox"  "p"  #'org-gtd-process-inbox
         :desc "Show all next"  "n"  #'org-gtd-show-all-next
         :desc "Stuck projects" "s"  #'org-gtd-review-stuck-projects))
  ;; Clarify map binding
  (map! :map org-gtd-clarify-map
        :desc "Organize this item" "C-c c" #'org-gtd-organize))
@end lisp

@item
@anchor{Example 3 Spacemacs Configuration}Example 3: Spacemacs Configuration


If you use Spacemacs, add this to your @code{dotspacemacs/user-config} function:

@lisp
;; Install org-gtd
(use-package org-gtd
  :ensure t
  :after org
  :init
  ;; Configure org-mode TODO keywords
  (setq org-todo-keywords
        '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
  ;; Map GTD semantic states
  (setq org-gtd-keyword-mapping
        '((todo . "TODO")
          (next . "NEXT")
          (wait . "WAIT")
          (done . "DONE")
          (canceled . "CNCL")))
  ;; Optional: Set GTD directory
  (setq org-gtd-directory "~/gtd/")
  ;; Add to agenda files
  (setq org-agenda-files (list org-gtd-directory))
  :config
  ;; REQUIRED: Enable org-edna for project dependencies
  (org-edna-mode 1)
  ;; Spacemacs leader key bindings
  (spacemacs/set-leader-keys
    "od c" 'org-gtd-capture
    "od e" 'org-gtd-engage
    "od p" 'org-gtd-process-inbox
    "od n" 'org-gtd-show-all-next
    "od s" 'org-gtd-review-stuck-projects)
  ;; Clarify map binding
  (with-eval-after-load 'org-gtd
    (define-key org-gtd-clarify-map (kbd "C-c c") 'org-gtd-organize)))
@end lisp

@item
@anchor{What These Configurations Do}What These Configurations Do


All three examples configure the same essential pieces:

@enumerate
@item
@strong{@code{org-todo-keywords}} - Defines the workflow states (TODO → NEXT → WAIT → DONE/CNCL)
@itemize
@item
The @code{|} separator marks done states (right side) vs active states (left side)
@item
All GTD keywords must be in a single sequence
@end itemize

@item
@strong{@code{org-gtd-keyword-mapping}} - Maps GTD concepts to your keyword choices
@itemize
@item
@code{todo} - Tasks not yet actionable
@item
@code{next} - Tasks ready to work on right now
@item
@code{wait} - Tasks blocked or delegated
@item
@code{done} - Tasks successfully completed
@item
@code{canceled} - Tasks that won't be done
@end itemize

@item
@strong{@code{org-gtd-directory}} - Where org-gtd keeps its files (defaults to @samp{~/gtd/})

@item
@strong{@code{org-agenda-files}} - Makes org-gtd items appear in agenda views

@item
@strong{@code{org-edna-mode}} - REQUIRED for projects to work

@item
@strong{Keybindings} - Two types:
@itemize
@item
@strong{Global bindings}: Work anywhere in Emacs (capture, engage, process, etc.)
@item
@strong{Clarify map binding}: Only works when organizing items in clarify buffers
@end itemize
@end enumerate

@item
@anchor{Testing Your Configuration}Testing Your Configuration


After adding one of the configurations above and restarting Emacs, verify everything works:

@strong{Test 1: Capture works}

@example
M-x org-gtd-capture
@end example

Expected: Opens a capture buffer for the inbox.

If it fails: Check that @code{org-gtd-directory} exists and you have write permissions.

@strong{Test 2: Engage works}

@example
M-x org-gtd-engage
@end example

Expected: Opens an agenda view (might be empty if you haven't organized anything yet).

If it fails: Check that @code{org-agenda-files} includes your GTD directory.

@strong{Test 3: Keywords are recognized}

@enumerate
@item
Open any org file: @code{M-x find-file ~/test.org}
@item
Type: @code{* Test heading}
@item
Put cursor on the heading
@item
Try cycling TODO states: @code{C-c C-t}
@end enumerate

Expected: Should cycle through TODO → NEXT → WAIT → DONE → CNCL@.

If it fails: Check that @code{org-todo-keywords} is set correctly.

@strong{Test 4: org-edna is enabled}

@example
M-x describe-variable RET org-edna-mode
@end example

Expected: Should show "t" (enabled).

If it fails: Make sure @code{(org-edna-mode 1)} is in your config and you've restarted Emacs.

@item
@anchor{Common Configuration Problems}Common Configuration Problems


Before troubleshooting, identify which configuration style you're using:
@itemize
@item
@strong{Vanilla Emacs}: See @ref{Example 1 Vanilla Emacs (Minimal Configuration), , Example 1 Vanilla Emacs}
@item
@strong{Doom Emacs}: See @ref{Example 2 Doom Emacs Configuration, , Example 2 Doom Emacs}
@item
@strong{Spacemacs}: See @ref{Example 3 Spacemacs Configuration, , Example 3 Spacemacs}
@end itemize

Each example shows the complete, correct configuration for that environment.

@strong{Problem: "org-gtd-capture" is undefined}

@strong{Cause}: org-gtd package isn't installed or loaded.

@strong{Solution}:
@itemize
@item
@strong{Vanilla Emacs}: Install from MELPA with @code{M-x package-install RET org-gtd RET}
@item
@strong{Doom Emacs}: Add @code{(package! org-gtd)} to your @code{packages.el} and run @code{doom sync}
@item
@strong{Spacemacs}: The @code{use-package} form in the @ref{Example 3 Spacemacs Configuration, , Spacemacs example} automatically installs it with @code{:ensure t}
@end itemize

@strong{Problem: Keywords don't change when I press C-c C-t}

@strong{Cause}: @code{org-todo-keywords} not configured correctly.

@strong{Solution}: Check your configuration has this setting:
@lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
@end lisp

Common mistakes:
@itemize
@item
Keywords not in quotes: Should be @code{"TODO"} not @code{TODO}
@item
Missing sequence wrapper: Need @code{'((sequence ...))} not just @code{'("TODO" ...)}
@item
No done separator: Need @code{|} before @code{"DONE"} and @code{"CNCL"}
@end itemize

See the complete configuration for your environment above.

@strong{Problem: Projects don't advance when I mark tasks DONE}

@strong{Cause}: org-edna isn't enabled.

@strong{Solution}: All three configuration examples include @code{(org-edna-mode 1)}. Make sure you have:
@itemize
@item
@strong{Vanilla/Spacemacs}: @code{(org-edna-mode 1)} in the @code{:config} section
@item
@strong{Doom}: @code{(org-edna-mode)} in the @code{:config} section (Doom handles the argument)
@end itemize

@strong{Problem: Can't see GTD items in agenda}

@strong{Cause}: GTD directory not in @code{org-agenda-files}.

@strong{Solution}: All three configuration examples include this. Check you have:
@lisp
(setq org-agenda-files (list org-gtd-directory))
@end lisp

Or if using @code{use-package} / @code{use-package!}:
@lisp
:custom
(org-agenda-files (list org-gtd-directory))
@end lisp

@strong{Problem: Keybindings don't work}

@strong{Cause}: Keybindings not defined, or defined incorrectly for your environment.

@strong{Solution}:
@itemize
@item
@strong{Vanilla Emacs}: Use @code{global-set-key} for global commands, @code{define-key org-gtd-clarify-map} for clarify buffer commands
@item
@strong{Doom Emacs}: Use @code{map!} with @code{:leader} prefix for global, @code{:map org-gtd-clarify-map} for clarify buffer
@item
@strong{Spacemacs}: Use @code{spacemacs/set-leader-keys} for global, @code{define-key} for clarify buffer
@end itemize

The clarify binding (@code{C-c c}) @strong{only works in clarify buffers} - you must run @code{M-x org-gtd-process-inbox} first.

See the complete configuration for your environment to copy the correct keybinding syntax.

@item
@anchor{Working with Your Existing Org Setup}Working with Your Existing Org Setup


Already have org-mode configured with your own refile targets and archive location? Org-gtd is designed to work @strong{alongside} your existing setup, not replace it.

@strong{Quick answers:}

@itemize
@item
@strong{Will org-gtd break my @code{org-refile-targets}?} No. Org-gtd merges its targets with yours. Your targets appear first in completion.

@item
@strong{Will org-gtd ignore my @code{org-archive-location}?} By default, yes—org-gtd uses year-based archive files. But you can make it respect yours with one line:
@lisp
(setq org-gtd-archive-location nil)  ; Use your org-archive-location
@end lisp
@end itemize

@strong{How the merge works:}

When you organize an item (say, as a Project), org-gtd builds a combined refile target list:

@enumerate
@item
Your @code{org-refile-targets} (appears first)
@item
Any heading with @code{ORG_GTD_REFILE: Projects} property (org-gtd's system)
@end enumerate

So if you have @code{org-refile-targets} pointing to @samp{~/org/projects.org}, that file's headings appear first. Org-gtd's property-marked targets appear after.

@strong{When to use which:}

@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Scenario
@tab What to do
@item New to org-mode
@tab Use org-gtd defaults. It creates targets automatically.
@item Have existing refile setup
@tab Keep it! Org-gtd adds to it, doesn't replace it.
@item Want single archive file
@tab Set @code{org-gtd-archive-location} to @code{nil}, configure @code{org-archive-location}
@item Want year-based GTD archives
@tab Use org-gtd default (nothing to configure)
@end multitable

@strong{See also:} @ref{Refiling to the appropriate area} for details on @code{ORG_GTD_REFILE} properties, @ref{Cleaning up / archiving completed work, , Cleaning up / archiving} for archive details.
@end itemize

@node Understanding Keybindings
@subsection Understanding Keybindings

org-gtd uses two types of keybindings, and understanding the difference is important:

@itemize
@item
@anchor{Global Keybindings}Global Keybindings


These work @strong{anywhere} in Emacs and let you access the main GTD commands:

@lisp
;; These commands are always available:
(global-set-key (kbd "C-c d c") 'org-gtd-capture)       ; Capture to inbox
(global-set-key (kbd "C-c d e") 'org-gtd-engage)        ; Daily view
(global-set-key (kbd "C-c d p") 'org-gtd-process-inbox) ; Process inbox
(global-set-key (kbd "C-c d n") 'org-gtd-show-all-next) ; Show NEXT actions
@end lisp

You can use any key combination you prefer. The @code{C-c d} prefix is just a convention.

@item
@anchor{Clarify Map Keybindings}Clarify Map Keybindings


These only work when you're in a @strong{clarify buffer} (during inbox processing). The most important one is:

@lisp
;; This only works in clarify buffers:
(define-key org-gtd-clarify-map (kbd "C-c c") 'org-gtd-organize)
@end lisp

@strong{When you're in a clarify buffer:}
@enumerate
@item
You've called @code{org-gtd-process-inbox} and are looking at an item
@item
You've edited the item to make it clear and actionable
@item
Now you press @code{C-c c} to organize it (choose its type: project, single action, etc.)
@end enumerate

@strong{Why the distinction?}

The clarify map is a separate keymap because:
@itemize
@item
It prevents conflicts with other org-mode bindings
@item
It only activates when you need it (during processing)
@item
You can bind different keys for organizing without affecting the rest of Emacs
@end itemize

@strong{Common patterns:}

Most users bind:
@itemize
@item
@code{C-c d *} for global commands (capture, engage, process)
@item
@code{C-c c} for organizing (only in clarify buffers)
@end itemize

But you can use whatever works for your workflow!
@end itemize

@node Required configuration of sub-packages
@subsection Required configuration of sub-packages

@itemize
@item
@anchor{Configuring org-edna}Configuring org-edna


package: @uref{https://www.nongnu.org/org-edna-el/}

This configuration is @strong{REQUIRED} for project dependencies to work correctly. It enables org-edna to automatically update task states when you complete tasks in a project.

@lisp
(org-edna-mode 1)
@end lisp

@item
@anchor{Adding org-gtd files to your agenda}Adding org-gtd files to your agenda


To see org-gtd items in your agenda views, add the org-gtd directory to your @code{org-agenda-files}:

@lisp
;; If you only want GTD files in your agenda:
(setq org-agenda-files (list org-gtd-directory))

;; Or if you have other agenda files, add GTD to the list:
(add-to-list 'org-agenda-files org-gtd-directory)
@end lisp
@end itemize

@node configuration options for org-gtd
@subsection configuration options for org-gtd

@itemize
@item
@anchor{I don't care just let me start using it}I don't care, just let me start using it


The most direct way to find out about the configuration options for org-gtd is to see the customize group: @code{M-x customize-group RET org-gtd}. They are all optional because they all come with default values.

The only one you may want to change before starting to use Org GTD is @code{org-gtd-directory}, which is the directory that Org GTD
will look to for everything it needs to do.

The configuration options will also be mentioned in the relevant subsections of @ref{Using Org GTD}.

@item
@anchor{Tell me all the levers I can pull}Tell me all the levers I can pull


Make sure you also read about sub-package configuration: @ref{Required configuration of sub-packages}.

@itemize
@item
@anchor{Required keyword configuration}Required keyword configuration


These settings are @strong{required} for Org GTD to work properly:

@table @asis
@item @code{org-todo-keywords}
(@samp{org-mode} variable) Define your TODO keyword sequences here. All GTD keywords (TODO, NEXT, WAIT, DONE, CNCL or your custom versions) @strong{must} be in the same sequence. Example.
@lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
@end lisp

@item @code{org-gtd-keyword-mapping}
Map GTD semantic states to your chosen keywords. This tells Org GTD which keyword means what. The five required mappings are.
@table @asis
@item @code{todo}
Tasks not ready to be acted upon
@item @code{next}
Tasks ready to act on immediately
@item @code{wait}
Tasks blocked or delegated to someone else
@item @code{done}
Tasks successfully completed
@item @code{canceled}
Tasks that won't be completed
@end table

Example configuration (use @code{setopt} for Emacs 29+ to get automatic validation):
@lisp
(setopt org-gtd-keyword-mapping
        '((todo . "TODO")
          (next . "NEXT")
          (wait . "WAIT")
          (done . "DONE")
          (canceled . "CNCL")))
@end lisp

Or for older Emacs versions:
@lisp
(setq org-gtd-keyword-mapping
      '((todo . "TODO")
        (next . "NEXT")
        (wait . "WAIT")
        (done . "DONE")
        (canceled . "CNCL")))
@end lisp
@end table

@item
@anchor{Optional configuration}Optional configuration


@table @asis
@item @code{org-gtd-directory}
set this to a directory. @samp{org-gtd} will look for all its files in this directory.
@item @code{org-gtd-capture-templates}
(!note: take care when changing this) This defines the pre-filled text that will show up when capturing an item to the inbox. The only requirements are that the template string must define an org-mode top-level heading, and that the entry point to the inbox.  That is to say, the first two characters must be a single asterisk followed by a space: @code{"* "}, and the entry type must be like this: @samp{entry  (file ,#'org-gtd-inbox-path)}. @ref{Adding things to the inbox}.
@item @code{org-reverse-note-order}
(@samp{org-mode} variable) set this to @code{t} to add new items to the top of project tasks and to @code{nil} to add new items to the bottom of project tasks when organizing an item as such.
@item @code{org-gtd-organize-hooks}
this is a list of functions that you can use to decorate each item when you clarify it. For instance, you could add a function to set the effort, or the priority, or some category, etc. By default it has only one function, which lets you add tags, but of course you can change this entirely. @ref{Organizing an item into the system, , Organizing an item}.
@item @code{org-gtd-archive-location}
Points to a function to generate the archive file dynamically. Default value generates a file suffixed with the current year. The function has an arity of zero and generates an org-mode file+outline path. @ref{Cleaning up / archiving completed work}.
@item @code{org-gtd-refile-to-any-target}
when @code{t}, @samp{org-gtd} will refile to the first target it finds, and create a target if it doesn't find one. When false, it will ask for confirmation before refiling. @ref{Refiling to the appropriate area}.
@item @code{org-gtd-delegate-read-func}
function that is used to prompt for a person a task is delegated to. Must return a string. By default this is set to @code{read-string}.
@item @code{org-gtd-areas-of-focus}
list of strings representing your areas of focus (horizon 2 in GTD).
@item @code{org-gtd-clarify-show-horizons}
When clarifying, do you want the horizons buffer to be shown by default, or do you prefer it hidden?
@item @code{org-gtd-clarify-project-templates}
Alist of strings: @code{project template name . project template} where there template is a series of tasks you may want to insert automatically, if you have a generic type of project that comes up a lot.
@item @code{org-gtd-horizons-file}
Name of the file, in @code{org-gtd-directory}, that will be displayed when the horizons buffer is displayed when clarifying.
@item @code{org-gtd-engage-prefix-width}
how many characters to dedicate to the prefix, on the left side of the TODO items, so the project name, if any, can show clearly.
@end table
@end itemize
@end itemize

@node Recommended key bindings
@subsection Recommended key bindings

There's an important keymap you'll want to make the flow of processing the inbox smoother. To limit impact on your emacs configuration, there is a specific keymap you can use. The function you'll want to bind is @code{org-gtd-organize}. I suggest @code{C-c c}, as in the following example.

@lisp
(define-key org-gtd-clarify-map (kbd "C-c c") #'org-gtd-organize)
@end lisp

For other keybindings, do what you need. My bindings use @code{C-c d} as a prefix, i.e.:

@table @asis
@item @code{C-c d c}
@code{org-gtd-capture}
@item @code{C-c d e}
@code{org-gtd-engage}
@end table

etc.

@node Sample Doom Emacs Config
@subsection Sample Doom Emacs Config

If you are a Doom Emacs user, then your configuration may look something like this:

@lisp
(use-package! org-gtd
  :after org
  :custom
  (org-gtd-directory "~/gtd/")
  (org-todo-keywords '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
  (org-gtd-keyword-mapping '((todo . "TODO")
                             (next . "NEXT")
                             (wait . "WAIT")
                             (done . "DONE")
                             (canceled . "CNCL")))
  (org-agenda-files (list org-gtd-directory))
  :config
  (org-edna-mode)
  (map! :leader
        (:prefix ("d" . "org-gtd")
         :desc "Capture"        "c"  #'org-gtd-capture
         :desc "Engage"         "e"  #'org-gtd-engage
         :desc "Process inbox"  "p"  #'org-gtd-process-inbox
         :desc "Show all next"  "n"  #'org-gtd-show-all-next
         :desc "Stuck projects" "s"  #'org-gtd-review-stuck-projects))
  (map! :map org-gtd-clarify-map
        :desc "Organize this item" "C-c c" #'org-gtd-organize))
@end lisp

@node Getting Started with Org GTD
@chapter Getting Started with Org GTD

You've configured org-gtd. Now let's see it in action with real examples that demonstrate why org-gtd is powerful.

@menu
* Quick Start Reference::
* Tutorial Your First Project::
* Tutorial Creating Your First Custom View::
@end menu

@node Quick Start Reference
@section Quick Start Reference

If you haven't done the 5-minute Quick Start in the README yet, do that first. It walks you through:
@enumerate
@item
Capturing a single action
@item
Processing your inbox
@item
Organizing the item
@item
Seeing it in your engage view
@end enumerate

That Quick Start proves the basic cycle works. Now let's see what makes org-gtd special: automatic project management and custom views.

@node Tutorial Your First Project
@section Tutorial: Your First Project

You've captured and organized a single action. That's great for simple tasks, but GTD's real power is managing multi-step projects. Let's create one and watch org-gtd handle the complexity automatically.

@menu
* What You'll Learn::
* The Project::
* Step 1 Capture the Project::
* Step 2 Process the Inbox::
* Step 3 Organize as a Project::
* Step 4 View in Engage::
* Step 5 Complete the First Task::
* Step 6 Refresh and See the Change::
* What Just Happened?::
* Continue the Project::
* Key Takeaways::
* What's Next?::
@end menu

@node What You'll Learn
@subsection What You'll Learn

@itemize
@item
How to capture and structure a project
@item
How org-gtd automatically manages task dependencies
@item
How tasks advance from TODO → NEXT when dependencies are satisfied
@item
How the engage view shows you what's immediately actionable
@end itemize

@node The Project
@subsection The Project

We'll plan a small house renovation with three sequential steps:
@enumerate
@item
Review blueprints
@item
Order windows
@item
Schedule carpenter
@end enumerate

This demonstrates sequential project execution - the default behavior where each task must complete before the next begins.

@node Step 1 Capture the Project
@subsection Step 1: Capture the Project

Press @code{C-c d c} (or @code{M-x org-gtd-capture}).

Type (or paste) this structure:

@example
* House Renovation
** Review blueprints
** Order windows of the right size
** Schedule carpenter
@end example

@strong{Important}: Projects in org-gtd have a specific structure:
@itemize
@item
Top-level heading (@code{*}) is the project name
@item
Second-level headings (@code{**}) are the tasks
@end itemize

Press @code{C-c C-c} to save.

@node Step 2 Process the Inbox
@subsection Step 2: Process the Inbox

Press @code{C-c d p} (or @code{M-x org-gtd-process-inbox}).

You'll see your project in a clarify buffer. This is your chance to refine it:
@itemize
@item
Add details to tasks (we already added "of the right size" to clarify what we need)
@item
Fix typos
@item
Make everything crystal clear
@end itemize

When you're satisfied, press @code{C-c c} to organize.

@node Step 3 Organize as a Project
@subsection Step 3: Organize as a Project

The transient menu appears with organization options. Press @strong{[p]} for "Project".

Watch what org-gtd does automatically:
@enumerate
@item
Marks the first task ("Review blueprints") as @strong{NEXT}
@item
Marks other tasks as @strong{TODO}
@item
Sets up dependency relationships (task 1 blocks task 2, task 2 blocks task 3)
@item
Refiles the entire project to your projects file
@end enumerate

You'll see a prompt for tags (optional). Press @code{RET} to skip or add tags if you want.

The project is now in your GTD system!

@node Step 4 View in Engage
@subsection Step 4: View in Engage

Press @code{C-c d e} (or @code{M-x org-gtd-engage}).

You'll see an agenda view showing:
@itemize
@item
@strong{NEXT: Review blueprints} - This is immediately actionable
@item
The project "House Renovation" appears in the list
@item
Other tasks ("Order windows", "Schedule carpenter") don't show as NEXT - they're waiting for the first task
@end itemize

This is your daily engagement view - it shows @strong{only} what you can act on right now, not everything in your system.

@node Step 5 Complete the First Task
@subsection Step 5: Complete the First Task

In the agenda view, move your cursor to "Review blueprints".

Press @strong{t} to cycle the TODO state.

Select @strong{DONE}.

@strong{Magic happens}: Watch "Order windows of the right size" automatically become NEXT@!

This is org-edna in action - the automatic dependency system org-gtd uses.

@node Step 6 Refresh and See the Change
@subsection Step 6: Refresh and See the Change

Press @strong{g} to refresh the agenda view.

You'll now see:
@itemize
@item
✓ "Review blueprints" is DONE (depending on your agenda settings, it may be hidden)
@item
@strong{NEXT: Order windows of the right size} - Now actionable!
@item
"Schedule carpenter" is still TODO - waiting for "Order windows" to complete
@end itemize

@node What Just Happened?
@subsection What Just Happened?

Let's understand the automatic workflow:

@enumerate
@item
@strong{When you organized as a project}, org-gtd:
@itemize
@item
Created a dependency chain: Task 1 → Task 2 → Task 3
@item
Set properties (@code{ORG_GTD_BLOCKS}, @code{ORG_GTD_DEPENDS_ON}) to track relationships
@item
Marked only the first task as NEXT
@end itemize

@item
@strong{When you marked "Review blueprints" DONE}, org-gtd:
@itemize
@item
Checked which tasks were blocked by this one
@item
Found "Order windows" had no remaining blockers
@item
Automatically changed it from TODO to NEXT
@end itemize

@item
@strong{"Schedule carpenter" stays TODO} because:
@itemize
@item
It depends on "Order windows" completing
@item
org-gtd won't mark it NEXT until its dependencies are satisfied
@end itemize
@end enumerate

You didn't manually manage any of this. You just @strong{did the work} and marked tasks complete. org-gtd handled the workflow automatically.

@node Continue the Project
@subsection Continue the Project

Complete "Order windows" the same way:
@enumerate
@item
Go to the engage view (@code{C-c d e})
@item
Find "Order windows of the right size"
@item
When done, press @strong{t} and select @strong{DONE}
@item
Watch "Schedule carpenter" automatically become NEXT
@end enumerate

When all tasks are done, the project is complete. You can archive it with @code{M-x org-gtd-archive-completed-items} during your weekly review.

@node Key Takeaways
@subsection Key Takeaways

@itemize
@item
@strong{Projects are multi-step actions} with automatic dependency management
@item
@strong{Sequential execution is the default} - tasks progress one after another
@item
@strong{The engage view shows only actionable items} - not everything in your system
@item
@strong{You focus on doing work, not managing workflows} - org-gtd handles task progression
@item
@strong{Completing tasks automatically advances projects} - no manual state management needed
@end itemize

@node What's Next?
@subsection What's Next?

This was a sequential project (A → B → C). Later, you'll learn how to:
@itemize
@item
Create @strong{parallel tasks} (A and B can both be NEXT simultaneously)
@item
Set @strong{custom dependencies} (A blocks C, B blocks C, but A and B are parallel)
@item
Manage @strong{complex project structures} with the dependency graph
@end itemize

For now, practice with a few simple sequential projects. The pattern is always:
@enumerate
@item
@strong{Capture} with project structure
@item
@strong{Clarify} to make it clear
@item
@strong{Organize} as a project
@item
@strong{Engage} to see what's actionable
@item
@strong{Complete} tasks and watch progression happen automatically
@end enumerate

@node Tutorial Creating Your First Custom View
@section Tutorial: Creating Your First Custom View

The built-in @code{org-gtd-engage} view is powerful, but you'll want custom views for different contexts. org-gtd 4.0 has a declarative View DSL that makes this easy. Let's create a view that shows all your active projects.

@menu
* What You'll Learn: What You'll Learn (1). 
* Why This View?::
* Understanding the View DSL::
* Creating the View Function::
* Using Your View::
* Binding to a Key::
* What You'll See::
* Experiment Modify the View::
* Available Filters::
* Key Takeaways: Key Takeaways (1). 
* What's Next?: What's Next? (1). 
* Where to Go From Here::
@end menu

@node What You'll Learn (1)
@subsection What You'll Learn

@itemize
@item
How the View DSL works (declarative syntax)
@item
How to create a simple custom view
@item
How to call your view and see results
@item
How to modify views for different needs
@end itemize

@node Why This View?
@subsection Why This View?

The engage view shows @strong{today's actionable items} - what you should work on right now.

But sometimes you want the @strong{big picture}:
@itemize
@item
What projects am I working on?
@item
Which ones have active tasks?
@item
What's the status of each project?
@end itemize

This view answers those questions by showing all active projects at a glance.

@node Understanding the View DSL
@subsection Understanding the View DSL

Views in org-gtd are @strong{declarative} - you describe @strong{what} you want to see, not @strong{how} to find it.

Here's the view we'll create:

@lisp
'((name . "My Active Projects")
  (filters . ((category . projects)
              (has-active-tasks . t))))
@end lisp

Let's break this down:

@table @asis
@item @code{name}
What displays in the view header
@item @code{filters}
What to include.
@table @asis
@item @code{category . projects}
Only show project headings (not single actions)
@item @code{has-active-tasks . t}
Only projects with work remaining
@end table
@end table

That's it! The View DSL translates this into an org-ql query and shows results.

@node Creating the View Function
@subsection Creating the View Function

Add this to your init file (after your org-gtd configuration):

@lisp
(with-eval-after-load 'org-gtd
  (defun my-org-gtd-active-projects ()
    "Show all active projects."
    (interactive)
    (org-gtd-view-show
     '((name . "My Active Projects")
       (filters . ((category . projects)
                   (has-active-tasks . t)))))))
@end lisp

Save your init file and reload it (@code{M-x eval-buffer} or restart Emacs).

@node Using Your View
@subsection Using Your View

Now you can call it:

@example
M-x my-org-gtd-active-projects
@end example

You'll see a list of all your active projects!

@node Binding to a Key
@subsection Binding to a Key

For quick access, bind it to a key. Add this to your configuration:

@lisp
;; If using vanilla Emacs
(global-set-key (kbd "C-c d P") 'my-org-gtd-active-projects)

;; If using Doom Emacs, add to your org-gtd config:
(map! :leader
      (:prefix "d"
       :desc "Active projects" "P" #'my-org-gtd-active-projects))

;; If using Spacemacs, add to your config:
(spacemacs/set-leader-keys "od P" 'my-org-gtd-active-projects)
@end lisp

Now press @code{C-c d P} (or your binding) to see active projects instantly!

@node What You'll See
@subsection What You'll See

The view shows:
@itemize
@item
All projects that have at least one active task
@item
Each project's current state (what tasks are NEXT, TODO, etc.)
@item
Project names and context
@end itemize

Projects that are:
@itemize
@item
Completely DONE - Won't appear (no active tasks)
@item
Canceled - Won't appear (no active tasks)
@item
Have only TODO/NEXT/WAIT tasks - Will appear
@end itemize

@node Experiment Modify the View
@subsection Experiment: Modify the View

Try these variations to see how the View DSL works:

@strong{Show ALL projects (including completed):}

@lisp
(defun my-org-gtd-all-projects ()
  "Show all projects, including completed ones."
  (interactive)
  (org-gtd-view-show
   '((name . "All Projects")
     (filters . ((category . projects))))))
     ;; Note: removed has-active-tasks filter
@end lisp

@strong{Show stuck projects:}

@lisp
(defun my-org-gtd-stuck-projects ()
  "Show projects that have work but no NEXT actions."
  (interactive)
  (org-gtd-view-show
   '((name . "Stuck Projects")
     (filters . ((category . projects)
                 (is-stuck . t))))))
@end lisp

@strong{Show projects in a specific area of focus} (if you use areas):

@lisp
(defun my-org-gtd-work-projects ()
  "Show only work projects."
  (interactive)
  (org-gtd-view-show
   '((name . "Work Projects")
     (filters . ((category . projects)
                 (has-active-tasks . t)
                 (area-of-focus . "Work"))))))
@end lisp

@node Available Filters
@subsection Available Filters

Here are common filters you can use in your views:

@table @asis
@item @code{category}
Filter by GTD category: @code{projects}, @code{actions}, @code{calendar}, @code{incubate}, @code{habits}
@item @code{todo}
Filter by keyword: @code{"NEXT"}, @code{"TODO"}, @code{"WAIT"}, @code{"DONE"}, @code{"CNCL"}
@item @code{has-active-tasks}
Only items with active (non-done) tasks
@item @code{is-stuck}
Projects that have tasks but no NEXT actions
@item @code{scheduled}
Items scheduled (you can specify ranges)
@item @code{deadline}
Items with deadlines
@item @code{area-of-focus}
Filter by area (if you use GTD horizons)
@item @code{property}
Filter by any org property
@end table

You can combine multiple filters - they all must match (AND logic).

@node Key Takeaways (1)
@subsection Key Takeaways

@itemize
@item
@strong{Views are declarative} - you describe what you want, not how to get it
@item
@strong{The View DSL is readable} - it's data, not complex code
@item
@strong{Views are easy to create and modify} - just change the filter list
@item
@strong{You can create unlimited views} - for different contexts and needs
@item
@strong{Views leverage org-ql} - fast and powerful queries
@end itemize

@node What's Next? (1)
@subsection What's Next?

Now that you understand views, you can create:
@itemize
@item
@strong{Review views} - For your weekly/monthly reviews
@item
@strong{Context views} - Show work items, home items, errands, etc.
@item
@strong{Time-based views} - Overdue items, upcoming deadlines, this week's schedule
@item
@strong{Focus views} - Deep work items, quick wins, waiting-for items
@end itemize

See @ref{View DSL Filter Reference} for the complete filter documentation with all available options and many more examples.

@node Where to Go From Here
@subsection Where to Go From Here

You now know:
@enumerate
@item
How to create and manage projects (Tutorial 1)
@item
How to create custom views (Tutorial 2)
@end enumerate

This is enough to be productive with org-gtd! The next section, "Using Org GTD", goes deep into:
@itemize
@item
All GTD item types (calendar, delegate, incubate, etc.)
@item
Advanced project features (parallel tasks, custom dependencies)
@item
Hooks and customization
@item
Integration with email and other tools
@item
Review workflows
@end itemize

Read those sections as you need them. For now, @strong{start using what you've learned}:
@itemize
@item
Capture items as they come up
@item
Process your inbox regularly (daily if possible)
@item
Use the engage view to see what's actionable
@item
Create a few simple projects
@item
Experiment with custom views
@end itemize

The best way to learn GTD is to practice the workflow. org-gtd handles the complexity - you just do the work.

@strong{Quick reference}:
@itemize
@item
@ref{Using Org GTD} - Deep dive into daily workflow and all item types
@item
@ref{Reference} - Complete documentation for configuration, commands, properties, views, and hooks
@item
@ref{Troubleshooting} - Solutions to common problems
@end itemize

@node Using Org GTD
@chapter Using Org GTD

You've completed the tutorials and understand the basics. This section covers everything else you'll need as you use org-gtd day-to-day and want to explore more advanced features.

@menu
* Your Daily Workflow::          The GTD cycle you'll practice every day
* The GTD Flow in Depth::        Detailed explanation of each GTD step
* Understanding GTD Item Types:: When to use each type in the organize menu
* Working with Projects (Advanced)::
* Automating through emacs::
@end menu

@node Your Daily Workflow
@section Your Daily Workflow

The GTD workflow has six steps. You'll do the first four frequently (even daily), and the last two periodically:

@enumerate
@item
@strong{Capture} - Get things out of your head into your inbox (@code{org-gtd-capture})
@item
@strong{Process} - Look at each inbox item one at a time (@code{org-gtd-process-inbox})
@item
@strong{Clarify} - Edit the item to make it clear and actionable
@item
@strong{Organize} - Categorize the item (@code{org-gtd-organize})
@item
@strong{Engage} - Look at what you can do right now (@code{org-gtd-engage})
@item
@strong{Review} - Periodically review your system for health
@end enumerate

You already practiced this in the @ref{Getting Started with Org GTD, , Getting Started tutorials}. The sections below go deeper into each part.

@menu
* Quick command reference::
@end menu

@node Quick command reference
@subsection Quick command reference

These are the commands you'll use most:

@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Command
@tab What it does
@tab When to use it
@item @code{org-gtd-capture}
@tab Add item to inbox
@tab Anytime something comes up
@item @code{org-gtd-process-inbox}
@tab Start processing inbox
@tab Daily (or when inbox has items)
@item @code{org-gtd-organize}
@tab Organize current item
@tab During processing (in clarify buffer)
@item @code{org-gtd-engage}
@tab See actionable items
@tab Daily (your "work from" view)
@item @code{org-gtd-show-all-next}
@tab See only NEXT actions
@tab When you want to focus on actions
@item @code{org-gtd-review-stuck-projects}
@tab Find stuck projects
@tab Weekly review
@item @code{org-gtd-projects-fix-all-todo-keywords}
@tab Fix task states after external edits
@tab After mobile/web edits
@item @code{org-gtd-archive-completed-items}
@tab Archive finished items
@tab Weekly/monthly cleanup
@end multitable

For complete command reference with detailed explanations, see @ref{Commands Reference}.

For details on each workflow step, see the subsections below.

@node The GTD Flow in Depth
@section The GTD Flow in Depth

Here are the domain elements of GTD that we handle:

@menu
* Adding things to the inbox::
* Processing the inbox::
* Clarifying each item::
* Organizing an item into the system::
* Engaging with your GTD items::
@end menu

@node Adding things to the inbox
@subsection Adding things to the inbox

The trip through GTD arguably begins by adding things to the inbox. The inbox is a file called @code{inbox.org} in the directory stored in the variable @code{org-gtd-directory}. By default this means the file will be @code{~/gtd/inbox.org}.

Org GTD provides one function to capture items: @code{M-x org-gtd-capture}. In my setup I have this bound globally as such:

@lisp
(global-set-key "C-c d c" #'org-gtd-capture)
@end lisp

This function uses the variable @code{org-gtd-capture-templates} to define org-gtd-specific capture templates. By default it comes with two templates, one to just capture a new item, and one to capture an item with a link to the file where you were when you started the capture.

You can customize these templates as you see fit. In order to maintain proper functioning of org-gtd, however, there are two constraints:

@enumerate
@item
the first two characters of the template string must be a single asterisk followed by a space: @code{"* "}
@item
the entry type must be like this: @samp{entry  (file ,#'org-gtd-inbox-path)}
@end enumerate

@strong{See also}: @ref{Configuration Variables Reference} for complete documentation of @code{org-gtd-capture-templates} and @code{org-gtd-directory}.

@node Processing the inbox
@subsection Processing the inbox

Processing the inbox means taking everything in the inbox, one at a time, and refining/categorizing them so they are instantly useful when you are looking at available next / scheduled actions.

You can start processing the inbox with @code{org-gtd-process-inbox}. This starts a looping behavior of clarifying each item in the inbox.

If you capture items from multiple sources (mobile app, email, different contexts), you can configure additional inbox files. After the main inbox is empty, processing continues through each additional file in order. See @code{org-gtd-additional-inbox-files} in @ref{Configuration Variables Reference}.

@node Clarifying each item
@subsection Clarifying each item

Clarifying an item means editing and adding the information that will be most valuable to you to the item. Note that task-specific information, such as appointment date, or name of person to whom it is delegated, or even area of focus, will be added during the Organize step, so don't worry about these yet.

@itemize
@item
@anchor{How to start clarifying}How to start clarifying


Besides ending up in here automatically while processing the inbox, there's two more ways to enter the clarifying flow:

@table @asis
@item @code{org-gtd-clarify-item}
call this from any org-mode heading to do a one-off clarification.
@item @code{org-gtd-clarify-agenda-item}
call this from the agenda view, if you have anything you want to re-clarify, or possibly clarify for the first time, from somewhere outside the inbox.
@end table

@item
@anchor{data shape requirements}data shape requirements


There's two general shapes you'll be looking for.
Almost everything will look like a simple org-mode heading.
For instance, @code{* Task desc}.


The only exception will be a project, that will look like a top-level heading for the project description with, underneath, a series of second-level headings representing each task to be executed sequentially before the project is complete.

@example
* Project heading
** First task
** Second task
** Third task
@end example

@item
@anchor{Options and commands related to clarification}Options and commands related to clarification


The clarify buffers are @code{org-mode} buffers that use the minor mode @code{org-gtd-clarify-mode}. There is a keymap, @code{org-gtd-clarify-map}, that you can use to bind useful

While clarifying, you may find it useful to see your GTD horizons. You can use:
@table @asis
@item @code{org-gtd-clarify-toggle-horizons-window}
a function that toggles the display of the horizons buffer
@item @code{org-gtd-clarify-show-horizons}
a boolean variable defining whether the horizons window should be shown (t) or hidden (nil) by default when clarifying an item. See  @ref{Working with the GTD Horizons} for more details.
@end table

If you are clarifying a project, you may be interested in project templates:
@table @asis
@item @code{org-gtd-clarify-project-insert-template}
a function that will ask you to choose a template to insert.
@item @code{org-gtd-clarify-project-templates}
an alist of the form @samp{(name . template)} where both name and template are strings. @samp{name} will be used in the interactive menu, and @samp{template} will be inserted in the buffer.
@end table

@strong{See also}: @ref{Configuration Variables Reference} for complete documentation of clarification options, and @ref{Commands Reference} for all clarification commands.
@end itemize

@node Organizing an item into the system
@subsection Organizing an item into the system

When you are done clarifying, call @code{M-x org-gtd-organize} (or hit your keybinding for it, see @ref{Recommended key bindings}). This will open a transient menu to let you choose how Org GTD should categorize this item.

Organizing is broken up into three steps:
@itemize
@item
Choosing a task type (see @ref{Understanding GTD Item Types})
@item
Applying hooks to add additional relevant information (see @ref{Hooks Framework Reference})
@item
Refiling to the appropriate area (see @ref{Refiling to the appropriate area, , Refiling} below)
@end itemize

@strong{See also}: @ref{Commands Reference} for the @code{org-gtd-organize} command and all organization-related commands.

@itemize
@item
@anchor{Refiling to the appropriate area}Refiling to the appropriate area


@itemize
@item
@anchor{Understanding Refiling in V4}Understanding Refiling in V4


In org-gtd v4, refiling is @strong{optional organizational preference}, not a structural requirement. Items can exist anywhere in your @code{org-agenda-files}.

By default, org-gtd uses @code{ORG_GTD_REFILE} properties to mark refile target headings. These can be at @strong{any level} in @strong{any file} in @code{org-agenda-files}.

@item
@anchor{Refile Target System}Refile Target System


Org-gtd @strong{merges} your @code{org-refile-targets} configuration with its own @code{ORG_GTD_REFILE} property-based targets:

@enumerate
@item
Your configured @code{org-refile-targets} appear first
@item
Org-gtd's @code{ORG_GTD_REFILE} targets appear after
@end enumerate

This means you can use both org-mode's standard refile configuration AND org-gtd's property-based system together.

Org-gtd finds refile targets by searching for @code{ORG_GTD_REFILE} property:

@example
* Projects         <-- Can be anywhere, any level
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:

** Work/
*** Development Projects   <-- Also a valid refile target!
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:
@end example

When you organize an item as a Project, org-gtd finds @strong{all} headings with @code{ORG_GTD_REFILE: Projects} (plus any targets from your @code{org-refile-targets}) and lets you choose where to refile.

@item
@anchor{Creating New Refile Targets}Creating New Refile Targets


To create a new refile target, add @code{ORG_GTD_REFILE} property to any heading:

For Projects:
@example
* My Projects
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:
@end example

For other types, use the appropriate template constant value:
@itemize
@item
Projects: @code{ORG_GTD_REFILE: Projects}
@item
Actions: @code{ORG_GTD_REFILE: Actions}
@item
Calendar: @code{ORG_GTD_REFILE: Calendar}
@item
Incubated: @code{ORG_GTD_REFILE: Incubated}
@item
Habits: @code{ORG_GTD_REFILE: Habits}
@end itemize

If no refile target exists when organizing, org-gtd automatically creates one in your default GTD file.

@item
@anchor{Using Your Own Refile Targets}Using Your Own Refile Targets


If you have existing @code{org-refile-targets} configuration, org-gtd automatically merges your targets with its own:

@lisp
;; Your refile configuration is respected and merged
(setq org-refile-targets '(("~/org/notes.org" :maxlevel . 2)
                           ("~/org/work.org" :maxlevel . 3)))
@end lisp

Your targets appear @strong{first} in the refile completion list, followed by org-gtd's @code{ORG_GTD_REFILE} targets. Files inside @code{org-gtd-directory} are filtered by the @code{ORG_GTD_REFILE} property; files outside are available as-is.

@item
@anchor{Migration from V3}Migration from V3


V3 required this structure:
@example
* Projects      <-- MUST be level 1
:PROPERTIES:
:ORG_GTD: Projects    <-- Dual-purpose property
:END:
@end example

V4 is flexible:
@example
* Projects      <-- Can be anywhere, any level
:PROPERTIES:
:ORG_GTD_REFILE: Projects    <-- Marks refile target
:END:
@end example

The upgrade script (@code{org-gtd-upgrade-v3-to-v4}) automatically renames @code{ORG_GTD} → @code{ORG_GTD_REFILE} on your old category headings.
@end itemize
@end itemize

@node Engaging with your GTD items
@subsection Engaging with your GTD items

You can see a list of all NEXT actions, and scheduled actions, with @code{M-x org-gtd-engage} .

You can call @code{org-gtd-show-all-next} to only see NEXT actions, nothing scheduled.

You can use @code{M-x org-gtd-review-missed-engagements} to find appointments you missed, delegated items needing check-ins, and late projects. This is your safety net for catching things that slipped through the cracks.

The weekly review is not yet implemented.

@node Understanding GTD Item Types
@section Understanding GTD Item Types

When you organize an item (@code{org-gtd-organize}), a transient menu appears with different item types. This section explains what each type means and when to use it.

You already saw @strong{Projects} and @strong{Single actions} in the tutorials. Here's the complete reference for all item types:

@menu
* Single Action [S]::
* Project [P]::
* Add to existing project [A]::
* Calendar [C]::
* Delegate [D]::
* Quick Action [Q]::
* Incubate [I]::
* Habit [H]::
* Knowledge [K]::
* Trash [T]::
* Working with the GTD Horizons::
@end menu

@node Single Action [S]
@subsection Single Action [S]

@strong{What it is}: A one-off task to do when you have time and energy.

@strong{When to use it}: For standalone tasks that aren't time-sensitive, don't depend on anyone else, and can be done whenever you're ready.

@strong{Examples}:
@itemize
@item
Buy birthday gift for Alex
@item
Read article about GTD methodology
@item
Update profile photo
@item
Clean garage
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Marks it as NEXT (immediately actionable)
@item
Refiles to your actions file
@item
Shows in @code{org-gtd-engage} view
@end itemize

@node Project [P]
@subsection Project [P]

@strong{What it is}: A multi-step action requiring more than one task to complete.

@strong{When to use it}: When accomplishing your goal requires multiple sequential (or parallel) steps.

@strong{Examples}:
@itemize
@item
House renovation (review blueprints → order materials → schedule work)
@item
Launch product (design → build → test → deploy → announce)
@item
Plan vacation (research destinations → book flights → arrange accommodation)
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Creates dependency relationships between tasks
@item
Marks first task(s) as NEXT, others as TODO
@item
Automatically advances tasks as you complete them
@item
Refiles entire project to your projects file
@end itemize

See @ref{Working with Projects (Advanced), , Working with Projects} for advanced features (parallel tasks, custom dependencies).

@node Add to existing project [A]
@subsection Add to existing project [A]

@strong{What it is}: Add the current task to a project that already exists.

@strong{When to use it}: When you realize a project needs an additional task, or you're breaking down a project task into sub-tasks.

@strong{Examples}:
@itemize
@item
Adding "Get permits" to your house renovation project
@item
Adding "Write announcement email" to your product launch project
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Prompts you to choose which project
@item
Inserts task into project (position depends on @code{org-reverse-note-order})
@item
Task keywords may need adjustment - use @code{org-gtd-projects-fix-todo-keywords-for-project-at-point} on the project heading if needed
@end itemize

@node Calendar [C]
@subsection Calendar [C]

@strong{What it is}: An action that must be done at a specific date or time.

@strong{When to use it}: For appointments, events, or time-sensitive tasks.

@strong{Examples}:
@itemize
@item
Doctor appointment on Tuesday at 2pm
@item
Team meeting every Monday at 9am
@item
Submit report by Friday 5pm (deadline)
@item
Call contractor on Thursday
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Prompts for date/time
@item
Adds timestamp to @code{ORG_GTD_TIMESTAMP} property
@item
Marks as NEXT
@item
Shows in agenda views at the appropriate time
@end itemize

@strong{Note}: This is for calendar items, not scheduled work blocks. In GTD, scheduling means "do this at this time," not "start working on this someday."

@node Delegate [D]
@subsection Delegate [D]

@strong{What it is}: A task someone else will do, but you need to follow up on.

@strong{When to use it}: When you're waiting for someone else to complete something and you need to check back.

@strong{Examples}:
@itemize
@item
Waiting for designer to finish mockups
@item
Asked colleague to review document
@item
IT to fix laptop issue
@item
Contractor to provide estimate
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Prompts for: person name, follow-up date
@item
Sets @code{DELEGATED_TO} property
@item
Marks as WAIT
@item
Shows in waiting-for views
@item
Appears in agenda on follow-up date
@end itemize

@strong{Customization}: Set @code{org-gtd-delegate-read-func} to use completion for names.

@node Quick Action [Q]
@subsection Quick Action [Q]

@strong{What it is}: Tasks that take less than 2 minutes.

@strong{When to use it}: For trivial tasks you can do immediately.

@strong{Examples}:
@itemize
@item
Reply to quick email
@item
File a document
@item
Add item to shopping list
@item
Send calendar invite
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Marks as DONE
@item
Archives immediately
@item
Assumes you just did it
@end itemize

@strong{GTD principle}: If it takes less than 2 minutes, do it now. Don't organize it - just do it and mark it done.

@node Incubate [I]
@subsection Incubate [I]

@strong{What it is}: Ideas or potential actions you're not ready to commit to yet (someday/maybe).

@strong{When to use it}: For things you want to think about later but don't want to act on now.

@strong{Examples}:
@itemize
@item
Learn Spanish (someday)
@item
Write a book (maybe)
@item
Remodel kitchen (not yet)
@item
Take photography class (when I have time)
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Prompts for review date
@item
Refiles to incubate file
@item
Will remind you on that date to reconsider
@end itemize

@strong{GTD principle}: Keep these out of your active system. Review periodically (weekly/monthly) to decide if they're ready to become real projects or actions.

@node Habit [H]
@subsection Habit [H]

@strong{What it is}: Recurring tasks you want to track consistently (org-mode habits).

@strong{When to use it}: For building routines and tracking streaks.

@strong{Examples}:
@itemize
@item
Exercise daily
@item
Write in journal
@item
Review finances weekly
@item
Call parents monthly
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Prompts for: repeat pattern (e.g., "daily", "+1w"), start date
@item
Creates org-mode habit with consistency tracking
@item
Shows habit graph in agenda views
@end itemize

@strong{Note}: See org-mode documentation for habit repeat patterns and tracking.

@node Knowledge [K]
@subsection Knowledge [K]

@strong{What it is}: Reference information to store for later.

@strong{When to use it}: When the item is information to keep, not an action to take.

@strong{Examples}:
@itemize
@item
Recipe you want to remember
@item
Quote from article
@item
Meeting notes for reference
@item
Product specifications
@end itemize

@strong{Important}: Choose this AFTER you've properly stored the information somewhere (your notes system, wiki, etc.). This just marks the inbox item as "filed" and archives it.

@strong{GTD principle}: Separate "stuff to do" from "stuff to know." Knowledge goes in your reference system, not your action lists.

@node Trash [T]
@subsection Trash [T]

@strong{What it is}: Not actionable, not worth keeping.

@strong{When to use it}: When you captured something that turns out to be irrelevant, already done, or not worth pursuing.

@strong{Examples}:
@itemize
@item
Event that already passed
@item
Duplicate of another item
@item
Idea that's no longer relevant
@item
Spam/noise
@end itemize

@strong{What org-gtd does}:
@itemize
@item
Deletes the item
@item
Doesn't archive, just removes it
@end itemize

@strong{GTD principle}: Be ruthless. If it's not actionable and not valuable information, delete it. Clutter in your system creates noise.

@strong{See also}: For technical details on how each item type is stored, see @ref{Properties Reference (Internal Implementation), , Properties Reference}.

@node Working with the GTD Horizons
@subsection Working with the GTD Horizons

In GTD, the horizons are defined as such:

@table @asis
@item Ground
the day-to-day
@item Horizon 1
projects
@item Horizon 2
areas of focus
@item Horizon 3
1-2 year goals
@item Horizon 4
3-5 year vision
@item Horizon 5
purpose and principles
@end table

Obviously, Ground and Horizons 1 are handled by the "capture/clarify/organize/engage" flow we've already seen.

GTD recommends that you do not start using the horizons above Horizon 1 until you have both Ground and Horizon 1 under control. So, when you are ready@dots{}

@itemize
@item
@anchor{Areas of focus}Areas of focus


Horizon 2 is now handled by a variable and a hook you can add to @code{org-gtd-organize-hooks}:
@itemize
@item
@code{org-gtd-areas-of-focus} is a list of strings, each representing one of your areas of focus.
@item
@code{org-gtd-set-area-of-focus} is the hook you would add, e.g. @code{(setq org-gtd-organize-hooks '(org-gtd-set-area-of-focus))}, it ensures each item you clarify will need to be part of a horizon.
@end itemize

You can then use the function @code{org-gtd-review-area-of-focus} to generate an agenda view to review a specific area of focus.

In order to add areas of focus to pre-existing items in your system, without going through the clarifying flow, we provide two functions:
@itemize
@item
@code{org-gtd-area-of-focus-set-on-item-at-point}, when you are on a org heading
@item
@code{org-gtd-area-of-focus-set-on-agenda-item}, when you are on an agenda item
@end itemize

Do note that calling the function on item at point will trust you blindly to do the right thing, whereas setting the area of focus through the agenda will attempt to recognize if you are on a project task and thus set the category on the project itself instead of the task.

@item
@anchor{Longer-term horizons}Longer-term horizons


The longer-term horizons can be stored in a file in the @code{org-gtd-directory}. A variable governs the name of the file, @code{org-gtd-horizons-file}, by default @samp{horizons.org}.

At the moment it does not seem particularly useful to add any automation around these, since they will change so infrequently.

They are, however, useful to display.

A variable, @code{org-gtd-clarify-show-horizons}, determines whether/where to display the side buffer while clarifying.

Regardless of the value of this variable, you can use the function @code{org-gtd-clarify-toggle-horizons-window} to display or hide the side window. If the above variable is nil, then the horizons window will be toggled on the right side of the screen.

@strong{See also}:
@itemize
@item
@ref{Configuration Variables Reference} for @code{org-gtd-areas-of-focus}, @code{org-gtd-horizons-file}, and @code{org-gtd-clarify-show-horizons}
@item
@ref{Commands Reference} for all horizon-related commands
@item
@ref{Hooks Framework Reference} for @code{org-gtd-set-area-of-focus} hook
@end itemize
@end itemize

@node Working with Projects (Advanced)
@section Working with Projects (Advanced)

You learned sequential projects in @ref{Tutorial Your First Project}. This section teaches you how to handle complex projects with parallel work streams, custom dependencies, and sophisticated project structures—all using visual project management.

@menu
* Quick Navigation::
* First Contact Why Visual Project Management?::
* Black Triangle Your First Project Graph View::
* Understanding Project Dependencies::
* Tutorial Parallel Tasks with Graph View::
* Tutorial Complex Dependencies with Graph View::
* Common Dependency Patterns (Visual Reference)::
* Graph View Command Reference::
* Graph Rendering Modes::
* Complete Keyboard Reference::
* Auto-Refresh on File Changes::
* Technical Details::
* Practical Tips for Project Management::
* Exporting Project Graphs::
* Troubleshooting Projects with Graph View::
* See Also::
* Incubating Projects Pausing Work You're Not Ready For::
* NEXT Task 1 Research options::
* Task 1 Research options::
* Project Progress Cookies See Your Progress at a Glance::
* Cleaning up / archiving completed work::
* Commands you can call on org-agenda::
* Defining your own agenda views::
* Adding your own hooks when organizing::
@end menu

@node Quick Navigation
@subsection Quick Navigation

This section covers:

@itemize
@item
@ref{First Contact Why Visual Project Management?, , Why Visual Project Management?} - Understanding the motivation
@item
@ref{Black Triangle Your First Project Graph View, , Your First Project Graph View} - Get started in 30 seconds
@item
@ref{Understanding Project Dependencies} - Learn the DAG model
@item
@ref{Tutorial Parallel Tasks with Graph View, , Tutorial Parallel Tasks} - Build your first complex project
@item
@ref{Common Dependency Patterns (Visual Reference), , Common Dependency Patterns} - Visual reference for typical structures
@item
@ref{Graph View Command Reference} - Complete command listing
@item
@ref{Graph Rendering Modes, , Rendering Modes} - SVG vs ASCII
@item
@ref{Complete Keyboard Reference} - Quick reference card
@item
@ref{Technical Details} - Implementation and properties
@item
@ref{Practical Tips for Project Management, , Practical Tips} - When and how to use graph view
@item
@ref{Troubleshooting Projects with Graph View, , Troubleshooting} - Common problems and solutions
@end itemize

@node First Contact Why Visual Project Management?
@subsection First Contact: Why Visual Project Management?

Real projects are rarely simple sequences. You might have:
@itemize
@item
Tasks that can start simultaneously (parallel research streams)
@item
Multiple tasks that must all finish before the next step (convergence points)
@item
Independent work paths that later merge (diamond patterns)
@end itemize

Managing these mentally or through text properties is error-prone. You forget dependencies, create accidental bottlenecks, or miss opportunities for parallelization.

@strong{Visual project management solves this.} You SEE your project as a dependency graph—boxes for tasks, arrows for dependencies, colors for states. Adding tasks, creating dependencies, and understanding project structure becomes intuitive and immediate.

@node Black Triangle Your First Project Graph View
@subsection Black Triangle: Your First Project Graph View

Let's see this in action right now.

@itemize
@item
@anchor{Step 1 Find a project}Step 1: Find a project


Open your engage view: @code{C-c d e}

Find any project task in your agenda (or create a quick test project if you don't have one).

@item
@anchor{Step 2 Open the graph view}Step 2: Open the graph view


Press @code{RET} on the project task to jump to the project heading.

Run: @code{M-x org-gtd-show-project-graph}

@item
@anchor{Step 3 Explore}Step 3: Explore


You're now looking at your project as a visual graph:
@itemize
@item
The project heading is at the top
@item
Tasks are arranged in layers below
@item
Arrows show which tasks block other tasks
@item
Green boxes are NEXT (ready to work on)
@item
Gray boxes are TODO (waiting for dependencies)
@end itemize

Press @code{?} to see all available commands.

@strong{Success!} You've visualized your first project. Everything from here builds on this.
@end itemize

@node Understanding Project Dependencies
@subsection Understanding Project Dependencies

Before we build complex projects, let's understand how dependencies work visually.

@itemize
@item
@anchor{The Dependency Graph (DAG)}The Dependency Graph (DAG)


Projects in org-gtd are @strong{Directed Acyclic Graphs} (DAGs):

@table @asis
@item @strong{Directed}
Dependencies have direction. If Task A blocks Task B, the arrow points from A → B@. B can't start until A finishes.

@item @strong{Acyclic}
No circular dependencies. A → B → C → A would create a deadlock. Org-gtd prevents these automatically.

@item @strong{Graph}
Tasks can have multiple dependencies. Task C might need both A AND B to finish before it can start.
@end table

@item
@anchor{What You See in Graph View}What You See in Graph View


The graph view arranges tasks in @strong{layers}:

@itemize
@item
@strong{Layer 0}: Root tasks (no dependencies, can start immediately)
@item
@strong{Layer 1}: Tasks blocked by layer 0
@item
@strong{Layer 2}: Tasks blocked by layer 1
@item
And so on@dots{}
@end itemize

@strong{Green boxes} (NEXT state) mean "ready to work on right now."
@strong{Gray boxes} (TODO state) mean "blocked by dependencies."

When you complete a NEXT task, org-gtd automatically updates the graph:
@itemize
@item
Completed task disappears (or grays out if you keep DONE tasks visible)
@item
Tasks that were waiting for it may turn green
@end itemize

@item
@anchor{Sequential vs Parallel vs Mixed}Sequential vs Parallel vs Mixed


@strong{Sequential} (default for new projects):
@itemize
@item
Tasks execute one after another: A → B → C
@item
Only one task is NEXT at a time
@item
Simple, linear workflow
@end itemize

In graph view, sequential projects look like a vertical chain of boxes with arrows flowing downward.

@strong{Parallel}:
@itemize
@item
Multiple tasks can be NEXT simultaneously
@item
Multiple tasks at layer 0 (all root tasks)
@item
Faster project completion when tasks are independent
@end itemize

In graph view, parallel projects have multiple green boxes at the same layer.

@strong{Mixed} (most real projects):
@itemize
@item
Some tasks parallel, others sequential
@item
Example: Research and Planning happen together, but both must finish before Building starts
@end itemize

In graph view, mixed projects show parallel branches that converge at join points.
@end itemize

@node Tutorial Parallel Tasks with Graph View
@subsection Tutorial: Parallel Tasks with Graph View

Let's build a project where some tasks happen simultaneously.

@itemize
@item
@anchor{The Scenario}The Scenario


You need to "Fix Shoulder Pain":
@enumerate
@item
Find MRI facility (research task)
@item
Make MRI appointment (depends on finding facility)
@item
Make orthopedist appointment (independent research - parallel with 1 & 2)
@item
Get diagnosis (depends on both appointments completing)
@end enumerate

Tasks 1 and 3 can happen in parallel—they're independent research tasks.

@item
@anchor{Step 1 Capture and Organize}Step 1: Capture and Organize


Capture the project: @code{C-c d c}

@example
* Fix Shoulder Pain
** Find place to get MRI
** Make MRI appointment
** Make orthopedist appointment
** Get diagnosis from orthopedist
@end example

Process the inbox: @code{C-c d p}

Organize as a project: @code{C-c c} → @code{[P]}

@item
@anchor{Step 2 Open Graph View}Step 2: Open Graph View


From the engage view (@code{C-c d e}), press @code{RET} on any task to jump to the project.

Run: @code{M-x org-gtd-show-project-graph}

You'll see a sequential graph (the default):
@example
[Fix Shoulder Pain]
        ↓
[NEXT: Find place to get MRI]
        ↓
[TODO: Make MRI appointment]
        ↓
[TODO: Make orthopedist appointment]
        ↓
[TODO: Get diagnosis from orthopedist]
@end example

We need to make tasks 1 and 3 parallel.

@item
@anchor{Step 3 Add Orthopedist Appointment as Root Task}Step 3: Add Orthopedist Appointment as Root Task


Click on (or navigate to) the "Find place to get MRI" task.

Press @code{a r} (add root task)

At the prompt, type: @code{Make orthopedist appointment}

@strong{Wait!} We already have that task. So instead, we'll restructure.

Actually, let's do this differently. We need to:
@enumerate
@item
Make "Make orthopedist appointment" a root task (no dependencies)
@item
Remove it from the sequential chain
@end enumerate

@strong{CURRENT LIMITATION}: The graph view can ADD tasks but can't MODIFY existing dependencies. So we'll build this from scratch using graph view commands.

@item
@anchor{Step 3 (Revised) Build with Graph View Commands}Step 3 (Revised): Build with Graph View Commands


Let me show you the INTENDED workflow (this reveals what features are still needed):

@enumerate
@item
Delete "Make orthopedist appointment" from the middle of the chain
@item
Add it as a new root task
@item
Make "Get diagnosis" depend on BOTH appointments
@end enumerate

But our graph view doesn't have delete/modify yet. Let's note this and continue with what we CAN do.

@item
@anchor{What Graph View CAN Do Right Now}What Graph View CAN Do Right Now


From the project heading in graph view:

@table @asis
@item @code{a c}
Add a child task (creates: selected task → new task)
@item @code{a r}
Add a root task (no dependencies, starts immediately)
@item @code{a b}
Add a blocker task (creates: new task → selected task)
@end table

Example: Building a parallel structure from scratch:

@enumerate
@item
Start with project heading selected
@item
@code{a r} → "Find place to get MRI"
@item
@code{a r} → "Make orthopedist appointment" (now TWO root tasks!)
@item
Select "Find place to get MRI"
@item
@code{a c} → "Make MRI appointment"
@item
Select "Make MRI appointment", @code{a c} → "Get diagnosis (MRI side)"
@item
Select "Make orthopedist appointment", @code{a c} → "Get diagnosis (ortho side)"
@end enumerate

But wait—we can't make ONE task depend on TWO tasks with current commands.

@strong{THIS REVEALS A MISSING FEATURE@.}

@item
@anchor{The Dependency Pattern (Diamond)}The Dependency Pattern (Diamond)


The pattern we want is called a "diamond":

@example
    Find MRI ─────┐
                  ├──→ Get Diagnosis
Make Ortho Appt ──┘
@end example

Two parallel paths converge at a single task.

@item
@anchor{Current Workaround}Current Workaround


For now, to create complex convergence patterns, you would:
@enumerate
@item
Use graph view to build the basic structure
@item
Press @code{r} to refresh and verify
@item
For convergence points (multiple tasks blocking one task), you need to either:
@itemize
@item
Structure the project differently
@item
Wait for "modify dependency" commands to be implemented
@end itemize
@end enumerate
@end itemize

@node Tutorial Complex Dependencies with Graph View
@subsection Tutorial: Complex Dependencies with Graph View

@itemize
@item
@anchor{The Scenario (1)}The Scenario


"Release Next Version of Software":

@enumerate
@item
List features (starting task)
@item
Implement features (depends on list)
@item
Write documentation (can start after list, parallel with implement)
@item
Get beta tester feedback (depends on both implement AND documentation)
@item
Update code based on feedback (depends on beta feedback)
@item
Update documentation based on feedback (depends on beta feedback, parallel with code updates)
@item
Release (depends on both updates completing)
@end enumerate

@item
@anchor{The Dependency Graph}The Dependency Graph


@example
List Features
    ├──→ Implement Features ───┐
    └──→ Write Documentation ───┼──→ Get Beta Feedback
                                │         ├──→ Update Code ─────┐
                                │         └──→ Update Docs ──────┼──→ Release
                                └───────────────────────────────┘
@end example

@item
@anchor{Building with Graph View}Building with Graph View


Starting from the project heading:

@enumerate
@item
@code{a r} → "List features" (root task)
@item
Select "List features"
@item
@code{a c} → "Implement features" (depends on list)
@item
Go back to "List features"
@item
@code{a c} → "Write documentation" (also depends on list - now parallel!)
@end enumerate

Now you have two parallel branches. Both are green (NEXT) because they only depend on the root task.

For the convergence at "Get Beta Feedback":
@itemize
@item
Select "Implement features"
@item
@code{a c} → "Get Beta Feedback (from implement)"
@end itemize

@strong{But we can't make it ALSO depend on "Write documentation" yet.}

@strong{THIS REVEALS THE SAME MISSING FEATURE@.}

@item
@anchor{Key Patterns This Example Shows}Key Patterns This Example Shows


@enumerate
@item
@strong{Parallel branches} after List Features (we CAN do this with @code{a c} from same parent)
@item
@strong{Converging paths} at Get Beta Feedback (we CANNOT do this yet—needs "add as blocker to existing task")
@item
@strong{Parallel updates} after feedback (we CAN do this)
@item
@strong{Final convergence} at Release (we CANNOT do this yet)
@end enumerate
@end itemize

@node Common Dependency Patterns (Visual Reference)
@subsection Common Dependency Patterns (Visual Reference)

Here's what different patterns look like in graph view:

@itemize
@item
@anchor{Sequential Chain (A → B → C)}Sequential Chain (A → B → C)


@example
[A - NEXT]
    ↓
[B - TODO]
    ↓
[C - TODO]
@end example

@strong{When to use}: Order matters, each task depends on the previous.

@strong{How to build}: Start at project, @code{a r} for first task, then @code{a c} repeatedly.

@strong{Example}: Review blueprints → Order windows → Schedule carpenter

@item
@anchor{Parallel Independent (A B C all start together)}Parallel Independent (A, B, C all start together)


@example
[A - NEXT]  [B - NEXT]  [C - NEXT]
@end example

@strong{When to use}: Tasks are completely independent, all can start immediately.

@strong{How to build}: From project heading, @code{a r} for each task.

@strong{Example}: Research destinations, Check budget, Ask for time off (vacation planning)

@item
@anchor{Fan-out (A → B A → C A → D)}Fan-out (A → B, A → C, A → D)


@example
      [A - NEXT]
     /    |    \
    ↓     ↓     ↓
[B-TODO][C-TODO][D-TODO]
@end example

@strong{When to use}: Initial work enables multiple independent paths.

@strong{How to build}: @code{a r} for A, select A, then @code{a c} for B, C, D@.

@strong{Example}: Get project approval → (Design UI, Write backend API, Setup infrastructure)

@item
@anchor{Fan-in / Convergence (A → C B → C)}Fan-in / Convergence (A → C, B → C)


@example
[A - NEXT]  [B - NEXT]
      \        /
       ↓      ↓
      [C - TODO]
@end example

@strong{When to use}: Final task needs all previous work completed.

@strong{How to build}: CANNOT BUILD YET—needs "multiple blockers" feature.

@strong{Workaround}: Make A → C → @dots{} and B → something-else for now.

@strong{Example}: (Write code, Write tests) → Merge to main

@item
@anchor{Diamond (A → B → D A → C → D)}Diamond (A → B → D, A → C → D)


@example
    [A - NEXT]
     /      \
    ↓        ↓
[B-TODO] [C-TODO]
    \      /
     ↓    ↓
   [D-TODO]
@end example

@strong{When to use}: Work splits, proceeds in parallel, then combines.

@strong{How to build}: CANNOT BUILD YET—convergence at D needs multiple blockers.

@strong{Example}: Research → (Write content, Design graphics) → Publish article
@end itemize

@node Graph View Command Reference
@subsection Graph View Command Reference

This is the complete command reference for expert users.

@strong{Most operations require the transient menu:} Press @code{?} to access all commands.

@itemize
@item
@anchor{Opening Graph View}Opening Graph View


@code{M-x org-gtd-show-project-graph}

@strong{Requires}: Point must be on a project heading (not a task), or will prompt for project selection

@strong{Creates}: Interactive SVG buffer named @code{*Org GTD Graph: <project-name>*}

@item
@anchor{Direct Keybindings (Always Available)}Direct Keybindings (Always Available)


@strong{Navigation:}

@multitable {aaaaa} {aaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item n / j
@tab Down dependency
@tab Move to a task this one blocks
@item p / k
@tab Up dependency
@tab Move to a task that blocks this one
@item TAB
@tab Next sibling
@tab Next task in same layer (same dependency depth)
@item g
@tab Goto node
@tab Jump to task by name (with completion)
@item [
@tab Back
@tab Navigate to previous node in history
@item ]
@tab Forward
@tab Navigate to next node in history
@item RET
@tab Jump to task in org file
@tab Opens the org file at the task's location
@end multitable

@strong{View:}

@multitable {aaa} {aaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item ?
@tab Show menu
@tab Display transient menu with all commands
@item r
@tab Refresh
@tab Rebuild graph (use after external changes)
@item q
@tab Quit
@tab Close graph view, keep buffer
@end multitable

@item
@anchor{Transient Menu Commands (Press @code{?} first)}Transient Menu Commands (Press @code{?} first)


@strong{Add Operations (@code{a} prefix):}

@multitable {aaa} {aaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item a c
@tab Add child
@tab Create task that depends on selected task
@item a r
@tab Add root
@tab Create task with no dependencies (starts immediately)
@item a b
@tab Add blocker
@tab Create task that blocks the selected task
@item a d
@tab Add dependency
@tab Add dependency between two tasks (supports convergence)
@end multitable

@strong{After adding}: Graph automatically refreshes to show new task.

@strong{Modify Operations:}

@multitable {aaa} {aaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item d
@tab Remove dependency
@tab Remove a dependency between two tasks
@item x
@tab Clear all relationships
@tab Clear all relationships from selected task
@end multitable

@strong{Inspect:}

@multitable {aaa} {aaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item i
@tab Show relationships
@tab Display all relationships for selected task
@end multitable

@strong{Other:}

@multitable {aaa} {aaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Description
@item Q
@tab Quit and kill
@tab Close graph view and kill buffer
@item z
@tab Zoom
@tab Zoom/filter submenu (not yet implemented)
@end multitable

@item
@anchor{Visual Indicators}Visual Indicators


@itemize
@item
@strong{Green boxes}: NEXT tasks (ready to work on)
@item
@strong{Gray boxes}: TODO tasks (blocked by dependencies)
@item
@strong{Arrows}: Dependencies (from blocker → blocked task)
@item
@strong{Layers}: Vertical positioning shows dependency depth
@end itemize

@item
@anchor{Operations Not Available in Graph View}Operations Not Available in Graph View


Some operations are standard org-mode functionality and must be done in the org file:

@strong{Changing task properties}:
@itemize
@item
TODO state: @code{C-c C-t} in org file
@item
Deadlines/schedules: @code{C-c C-d}, @code{C-c C-s} in org file
@item
Task title/description: edit in org file
@item
Tags/properties: edit in org file
@end itemize

@strong{Deleting tasks}: Mark task DONE or CNCL in the org file. Completed tasks still show in graph view (green boxes) to maintain project history.

@strong{Access org file}: Press @code{RET} on any task in graph view to jump to it in the org file.

@item
@anchor{Text-Based Alternatives}Text-Based Alternatives


Most users will find the graph view intuitive for dependency management. However, text-based task management commands are available:

@itemize
@item
@code{org-gtd-task-add-blockers} - Add blockers via text interface
@item
@code{org-gtd-task-remove-blockers} - Remove blockers via text interface
@item
@code{org-gtd-task-show-relationships} - Display relationships in minibuffer
@item
@code{org-gtd-validate-project-dependencies} - Validate project structure
@end itemize

See @ref{Task Dependency Commands} for details.
@end itemize

@node Graph Rendering Modes
@subsection Graph Rendering Modes

The graph view supports two rendering modes that you can toggle between at any time.

@itemize
@item
@anchor{SVG Mode (Default)}SVG Mode (Default)


High-quality graphical rendering with:
@itemize
@item
Smooth curves for dependency arrows
@item
Anti-aliased text
@item
Visual polish
@item
Larger display area
@item
Better for GUI Emacs
@end itemize

Set as default with:
@lisp
(setq org-gtd-graph-render-mode 'svg)
@end lisp

@item
@anchor{ASCII Mode}ASCII Mode


Text-based rendering using box-drawing characters:
@itemize
@item
Works in terminal Emacs
@item
Accessible for screen readers
@item
Compact display
@item
No external dependencies
@item
Uses Unicode box-drawing glyphs
@end itemize

Set as default with:
@lisp
(setq org-gtd-graph-render-mode 'ascii)
@end lisp

@item
@anchor{Toggling Modes}Toggling Modes


Press @code{v} while in graph view to toggle between SVG and ASCII rendering.

@item
@anchor{Troubleshooting ASCII Rendering}Troubleshooting ASCII Rendering


If ASCII rendering looks broken:
@itemize
@item
Ensure your terminal supports UTF-8 box-drawing characters
@item
Try SVG mode (@code{v} to toggle)
@item
Check that your font supports box-drawing glyphs
@item
Verify @code{(char-displayable-p ?│)} returns @code{t}
@end itemize
@end itemize

@node Complete Keyboard Reference
@subsection Complete Keyboard Reference

This is a comprehensive quick reference for all graph view keybindings.

@itemize
@item
@anchor{Navigation}Navigation


@multitable {aaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Action
@item @code{?}
@tab Show command menu (transient)
@item @code{n} / @code{j}
@tab Down dependency (to task this blocks)
@item @code{p} / @code{k}
@tab Up dependency (to task that blocks this)
@item @code{TAB}
@tab Next sibling (same layer)
@item @code{<backtab>}
@tab Previous sibling
@item @code{<}
@tab First task in layer
@item @code{>}
@tab Last task in layer
@item @code{g}
@tab Go to task by name
@item @code{[}
@tab Navigate back in history
@item @code{]}
@tab Navigate forward in history
@end multitable

@item
@anchor{Modification (via transient menu @code{?})}Modification (via transient menu @code{?})


@multitable {aaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Action
@item @code{a a}
@tab Insert task AFTER selected (child)
@item @code{a b}
@tab Insert task BEFORE selected
@item @code{a r}
@tab Add root task (no dependencies)
@item @code{m b}
@tab Modify what blocks this task
@item @code{m a}
@tab Modify what this task blocks
@item @code{r}
@tab Remove task from project
@item @code{t}
@tab Change TODO state
@end multitable

@item
@anchor{Information}Information


@multitable {aaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Action
@item @code{i}
@tab Show relationships for task
@item @code{e}
@tab Edit task in org file (jump to)
@item @code{RET}
@tab Jump to task in org file
@end multitable

@item
@anchor{View Control}View Control


@multitable {aaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Action
@item @code{v}
@tab Toggle ASCII/SVG rendering
@item @code{z}
@tab Zoom menu (filter/focus)
@item @code{R}
@tab Refresh graph (rebuild from org file)
@item @code{q}
@tab Quit graph view
@item @code{Q}
@tab Quit and kill buffer
@end multitable
@end itemize

@node Auto-Refresh on File Changes
@subsection Auto-Refresh on File Changes

Graph view automatically watches the org file and refreshes when changes are detected (with 300ms debounce). This means:

@itemize
@item
Changes in the org file appear in graph view automatically
@item
No need to manually refresh after external edits
@item
Multiple graph views of the same project stay in sync
@item
File watching is buffer-local and cleaned up on quit
@end itemize

You can still manually refresh with @code{R} if needed.

@node Technical Details
@subsection Technical Details

@itemize
@item
@anchor{Graph Data Structure}Graph Data Structure


Projects are represented as @strong{Directed Acyclic Graphs} (DAGs):

@itemize
@item
@strong{Directed}: Dependencies have direction (A blocks B, not vice versa)
@item
@strong{Acyclic}: No circular dependencies (org-gtd prevents these)
@item
@strong{Graph}: Tasks can have multiple blockers and multiple dependents
@end itemize

@item
@anchor{Layout Algorithm}Layout Algorithm


The Sugiyama layout algorithm:
@enumerate
@item
Assigns tasks to layers based on dependency depth
@item
Minimizes edge crossings between layers
@item
Centers nodes horizontally for visual balance
@item
Calculates smooth curved arrows (SVG) or line-drawing characters (ASCII)
@end enumerate

@item
@anchor{Properties Used}Properties Used


Graph view reads and writes these org properties:

@itemize
@item
@code{ORG_GTD_FIRST_TASKS} (on project heading): Space-separated list of task IDs with no dependencies
@item
@code{ORG_GTD_DEPENDS_ON} (on tasks): Space-separated list of task IDs this task depends on
@item
@code{ORG_GTD_BLOCKS} (on tasks): Space-separated list of task IDs this task blocks
@item
@code{ORG_GTD_PROJECT_IDS} (on tasks): Space-separated list of project IDs this task belongs to
@end itemize

These properties maintain bidirectional consistency. When you add dependency A→B:
@itemize
@item
A's @code{ORG_GTD_BLOCKS} includes B's ID
@item
B's @code{ORG_GTD_DEPENDS_ON} includes A's ID
@end itemize

You typically don't edit these properties directly—use graph view commands or the text-based alternatives.

@item
@anchor{Undo/Redo Support}Undo/Redo Support


Currently, undo/redo is not implemented in graph view. Graph modifications are immediately saved to the org file.

To undo changes:
@itemize
@item
Switch to the org file buffer
@item
Use @code{C-x u} (undo) as normal
@item
The graph view will auto-refresh to show the reverted state
@end itemize
@end itemize

@node Practical Tips for Project Management
@subsection Practical Tips for Project Management

@itemize
@item
@anchor{When to Use Graph View}When to Use Graph View


@itemize
@item
@strong{Planning complex projects}: Visualize before committing to structure
@item
@strong{Understanding stuck projects}: See why tasks are blocked
@item
@strong{Weekly review}: Quick visual health check of all projects
@item
@strong{Adding tasks mid-project}: Add with correct dependencies immediately
@end itemize

@item
@anchor{When to Use Sequential (Default)}When to Use Sequential (Default)


@itemize
@item
Order truly matters (can't install before purchasing)
@item
You're unsure what the next task will be until you complete current one
@item
The project is simple (3-4 tasks)
@item
You don't want to think about dependencies
@end itemize

@strong{Just organize as project} (@code{C-c c} → @code{[P]}) and you're done.

@item
@anchor{When to Create Parallel Structures}When to Create Parallel Structures


@itemize
@item
You have multiple people working on the project
@item
Tasks are independent and could be done in any order
@item
You want to optimize for speed
@item
You know all tasks upfront
@end itemize

@strong{Use @code{a r} multiple times} from graph view to create parallel roots.

@item
@anchor{Managing Complexity}Managing Complexity


@itemize
@item
@strong{Start sequential, add parallel only when needed}: Don't over-engineer.
@item
@strong{Use graph view to understand before modifying}: Visualize first.
@item
@strong{Keep task names clear and specific}: "Research venues" not "Research"
@item
@strong{Review stuck projects weekly}: @code{M-x org-gtd-review-stuck-projects}
@end itemize

@item
@anchor{Growing Projects Over Time}Growing Projects Over Time


As projects evolve, you need to add tasks:

@itemize
@item
@strong{New independent work stream}: @code{a r} (add root task)
@item
@strong{Next step in sequence}: Select current task, @code{a c} (add child)
@item
@strong{Prerequisite for existing task}: Select existing task, @code{a b} (add blocker)
@end itemize

After adding, press @code{r} to refresh the view.
@end itemize

@node Exporting Project Graphs
@subsection Exporting Project Graphs

@itemize
@item
@anchor{First Contact What is Graph Export?}First Contact: What is Graph Export?


Graph export saves your project visualization as a file. Share project plans with teammates who don't use Emacs. Include project graphs in presentations or documentation. Process graphs with external tools like Graphviz.

Three export formats:
@itemize
@item
@strong{SVG}: High-quality graphics for documents and presentations
@item
@strong{DOT}: Graphviz source for custom styling and layouts
@item
@strong{ASCII}: Text-based diagrams for terminals and plain-text documentation
@end itemize

Who needs this? Anyone collaborating outside Emacs, creating documentation, or using graph analysis tools.

@item
@anchor{Tutorial Export Your First Graph}Tutorial: Export Your First Graph


Let's export a project graph in under 30 seconds:

@enumerate
@item
Open any project in graph view: @code{M-x org-gtd-show-project-graph}
@item
Press @code{?} to open the command menu
@item
Press @code{E s} to export as SVG
@item
Choose a filename (e.g., @code{project-plan.svg})
@item
Done! Open the file in any image viewer or web browser
@end enumerate

The exported graph preserves your current view, including which task is selected (highlighted).

@item
@anchor{Progressive Learning Choosing Export Formats}Progressive Learning: Choosing Export Formats


@strong{@strong{Start with SVG}} when you first need to export. It works everywhere—documents, presentations, web pages, email attachments. Your colleague can open it in any browser.

@strong{@strong{Use DOT when you need control}}. The DOT format is Graphviz's source language. Export to DOT when you want to:
@itemize
@item
Change colors, fonts, or layout algorithms
@item
Combine multiple project graphs
@item
Generate different output formats (PNG, PDF, PostScript)
@item
Integrate with automated build systems
@end itemize

Process a DOT file with Graphviz:
@example
dot -Tpng project.dot -o project.png      # Convert to PNG
dot -Tpdf project.dot -o project.pdf      # Convert to PDF
neato -Tsvg project.dot -o custom.svg     # Different layout algorithm
@end example

@strong{@strong{Use ASCII for text contexts}}. ASCII export creates terminal-friendly diagrams. Use when:
@itemize
@item
Writing plain-text documentation (README files)
@item
Sharing in chat or email where images don't work
@item
Reviewing projects over SSH without graphics
@item
Creating quick diagrams for code comments
@end itemize

Example ASCII output:
@example
Conference Planning
├─ Research venues
├─ Create budget
│  └─ Get quotes
└─ Book venue
@end example

@strong{@strong{Handling large projects}}: All formats work with complex graphs, but consider:
@itemize
@item
SVG scales perfectly (zoom without quality loss)
@item
DOT can be processed with different layout algorithms for readability
@item
ASCII may become unwieldy with 20+ tasks (switch to SVG)
@end itemize

@item
@anchor{When Exports Differ from Display}When Exports Differ from Display


The export reflects your current graph state. If you've selected a task (navigated with @code{j~/~k} or clicked), that task appears highlighted in the export.

To export without highlighting:
@enumerate
@item
Press @code{ESC} to deselect the current task
@item
Export with @code{E s}, @code{E d}, or @code{E a}
@item
The export shows all tasks unhighlighted
@end enumerate

Changes you make in graph view are immediately saved to the org file, so exports always reflect the actual project structure.

@item
@anchor{Reference Export Commands}Reference: Export Commands


From graph view (@code{M-x org-gtd-show-project-graph}), press @code{?} to open the menu, then:

@multitable {aaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Key
@tab Command
@tab Format
@tab Best For
@item @code{E s}
@tab @code{org-gtd-graph-export-svg}
@tab SVG
@tab Documents, presentations, sharing
@item @code{E d}
@tab @code{org-gtd-graph-export-dot}
@tab DOT
@tab Graphviz processing, customization
@item @code{E a}
@tab @code{org-gtd-graph-export-ascii}
@tab ASCII
@tab Terminals, plain-text docs
@end multitable

All commands prompt for a filename. The file is created immediately.

@item
@anchor{Troubleshooting Exports}Troubleshooting Exports


@strong{@strong{"No graph to export" error}}: You must be in a graph view buffer. Open a project graph first with @code{M-x org-gtd-show-project-graph}.

@strong{@strong{Empty or corrupted file}}:
@itemize
@item
Verify the graph displays correctly before exporting
@item
Press @code{R} to refresh the graph view
@item
Try exporting to a different location with write permissions
@end itemize

@strong{@strong{SVG won't open in browser}}: Ensure the filename ends in @code{.svg}. Most programs detect format by file extension.

@strong{@strong{DOT processing fails}}: Install Graphviz (@code{dot} command) on your system. The DOT file is plain text—open it in any editor to verify its contents.
@end itemize

@node Troubleshooting Projects with Graph View
@subsection Troubleshooting Projects with Graph View

@itemize
@item
@anchor{Project is Stuck (has TODO tasks but no NEXT)}Project is Stuck (has TODO tasks but no NEXT)


Run @code{M-x org-gtd-review-stuck-projects} to find stuck projects.

Open the stuck project in graph view: @code{M-x org-gtd-show-project-graph}

@strong{What to look for}:
@itemize
@item
@strong{No green boxes?} All tasks might be waiting for dependencies that are DONE@. Press @code{r} to refresh.
@item
@strong{Gray boxes at layer 0?} These should be green (root tasks are never blocked). Something's wrong with the dependency structure.
@item
@strong{Circular dependency?} Org-gtd prevents these, but if you see arrows forming a loop, you've found a bug.
@end itemize

@strong{How to fix}:
@itemize
@item
Use graph view to understand the structure
@item
Add a new root task (@code{a r}) if nothing can start
@item
Refresh (@code{r}) after any changes
@end itemize

@item
@anchor{Task Should Be NEXT But Shows as TODO}Task Should Be NEXT But Shows as TODO


In graph view, look at the task:
@itemize
@item
Is it gray (TODO)?
@item
Trace arrows pointing TO it—these are its blockers
@item
Are all those blockers green? Then something's wrong.
@item
Are some blockers gray? Then the task is correctly blocked.
@end itemize

If blockers are actually DONE but still showing as green, press @code{r} to refresh.

@strong{How to fix}: Use @code{d} to remove incorrect dependencies, or @code{x} to clear all relationships for a task and rebuild.

@item
@anchor{Too Many Tasks Are NEXT}Too Many Tasks Are NEXT


In graph view:
@itemize
@item
Count green boxes
@item
If you have 10+ green tasks, you probably have dependency problems
@item
Some tasks should depend on others but don't
@end itemize

@strong{How to fix}:
@itemize
@item
Select a task that should be blocked
@item
Press @code{a b} to add a blocker task
@item
Or restructure: tasks later in the workflow should be children (@code{a c}) of earlier tasks
@end itemize

@item
@anchor{Graph Won't Open}Graph Won't Open


If @code{M-x org-gtd-show-project-graph} doesn't work:

@itemize
@item
Verify you're on a project heading (not a task heading)
@item
Check that the heading has @code{ORG_GTD} property set to "Projects"
@item
Try explicitly: @code{M-x org-gtd-show-project-graph}
@item
Check for errors in @code{*Messages*} buffer
@end itemize

@item
@anchor{Graph Shows No Tasks}Graph Shows No Tasks


If the graph opens but shows no tasks:

@itemize
@item
Check if the project has subtasks (tasks should be subheadings under the project)
@item
Verify tasks have @code{ORG_GTD_PROJECT_IDS} property containing the project ID
@item
Press @code{R} to force a complete refresh
@item
Check @code{*Messages*} buffer for parsing errors
@end itemize

@item
@anchor{Task Shows Wrong State (NEXT vs TODO)}Task Shows Wrong State (NEXT vs TODO)


If a task's color doesn't match its expected state:

@itemize
@item
Press @code{R} to refresh (state might be stale from external edits)
@item
Check the task's actual TODO state in the org file (press @code{e} to jump there)
@item
Verify dependencies are correct (press @code{i} to inspect relationships)
@item
Look for completed tasks that haven't been refreshed
@end itemize

@item
@anchor{Can't Modify Dependencies}Can't Modify Dependencies


If modification commands don't work:

@itemize
@item
Ensure a task is selected (should see highlighted box)
@item
Press @code{?} to verify commands are available in the transient menu
@item
Check that you're in the graph view buffer, not the org file buffer
@item
Try @code{R} to refresh if the graph is in an inconsistent state
@end itemize
@end itemize

@node See Also
@subsection See Also

@itemize
@item
@ref{Tutorial Your First Project} for sequential project basics
@item
@ref{Properties Reference (Internal Implementation), , Properties Reference} for @code{ORG_GTD_FIRST_TASKS}, @code{ORG_GTD_DEPENDS_ON}, and @code{ORG_GTD_BLOCKS} (internal implementation)
@item
@ref{Commands Reference} for all project management commands
@item
@ref{View DSL Filter Reference} for creating custom project views
@end itemize

@node Incubating Projects Pausing Work You're Not Ready For
@subsection Incubating Projects: Pausing Work You're Not Ready For

@itemize
@item
@anchor{First Contact Why Incubate Projects?}First Contact: Why Incubate Projects?


You're managing 15 active projects. Some are ready to work on NOW@. Others are good ideas, but wrong timing—maybe you're waiting for budget approval, or team availability, or just aren't ready to commit yet.

Keeping them all visible in your engage view creates noise. You scan past 10 "someday" projects to find the 5 you can actually work on today. That's cognitive load you don't need.

@strong{Incubating projects solves this.} Pause a project with a review date. It disappears from your engage view, your NEXT lists, everywhere—but preserves the complete project structure (all tasks, dependencies, planning work). When the review date arrives or you're ready, reactivate it with one command. The project springs back to life exactly as you left it.

For GTD users managing multiple projects where some need to be dormant temporarily.

@item
@anchor{Black Triangle Incubate Your First Project in 30 Seconds}Black Triangle: Incubate Your First Project in 30 Seconds


Let's incubate a project right now.

@strong{Step 1: Find a project you're not ready for}

Open graph view for any project: @code{M-x org-gtd-show-project-graph}

Or navigate to any project heading in your GTD file.

@strong{Step 2: Incubate it}

Press @code{I} in graph view, or run @code{M-x org-gtd-incubate}

Enter a review date when prompted: @code{2025-06-01}

@strong{Step 3: Verify it's gone}

Open your engage view: @code{C-c d e}

The project's tasks are GONE from your NEXT list. No clutter.

@strong{Step 4: Check your review date}

The incubated project will appear in your agenda on 2025-06-01 as a reminder to reconsider it.

@strong{Success!} You've paused a project without losing any of your planning work.

@item
@anchor{Understanding Incubation What Actually Happens}Understanding Incubation: What Actually Happens


When you incubate a project, org-gtd performs several operations to make it completely invisible while preserving state:

@strong{State Preservation}

For the project heading and every task:
@itemize
@item
Current @code{ORG_GTD} property → saved to @code{PREVIOUS_ORG_GTD} (e.g., "Projects" → "Projects")
@item
Current TODO keyword → saved to @code{PREVIOUS_TODO} property (e.g., "NEXT" → "NEXT")
@item
@code{ORG_GTD} property → set to "Incubated"
@item
TODO keyword → cleared completely (becomes nil)
@end itemize

@strong{@strong{Why clear keywords?}} This makes incubated tasks invisible to all views naturally. Your engage view shows ~(todo . "NEXT")~—tasks with no keywords don't match, so they disappear automatically.

@strong{Review Date Storage}

The review date is stored in the project heading's @code{ORG_GTD_TIMESTAMP} property as @code{<2025-06-01>}. This makes the project appear in your org-agenda on that date, just like delegated items or calendar events.

@strong{Dependency Preservation}

ALL dependency relationships (@code{ORG_GTD_DEPENDS_ON}, @code{ORG_GTD_BLOCKS}) remain intact. They're dormant—they don't affect anything while incubated—but they're there. When you reactivate, dependencies work exactly as before.

@strong{Multi-Project Tasks}

If a task belongs to MULTIPLE projects (has multiple IDs in @code{ORG_GTD_PROJECT_IDS}), it is NOT incubated. Why? Because it's still needed by other active projects.

You'll see: "Skipping multi-project task: Task Name"

The task remains active with its TODO keyword intact.

@item
@anchor{Tutorial Managing Seasonal Projects}Tutorial: Managing Seasonal Projects


Let's walk through a realistic scenario: you have annual projects that you only work on during specific seasons.

@strong{The Problem}

You're tracking these projects:
@itemize
@item
"Annual Review Process" (only relevant December-January)
@item
"Summer Conference Planning" (only relevant May-August)
@item
"Q4 Budget Proposals" (only relevant September-November)
@end itemize

It's March. None of these are relevant, but they clutter your project list and NEXT tasks keep appearing in your engage view.

@strong{The Solution: Incubate Until Needed}

In March, incubate all three:

@enumerate
@item
Navigate to "Summer Conference Planning"
@item
@code{M-x org-gtd-incubate}
@item
Review date: @code{2025-05-01}
@item
Repeat for other seasonal projects with appropriate dates
@end enumerate

Your engage view is now clean—only projects you can work on THIS MONTH@.

@strong{When Review Dates Arrive}

On May 1st, "Summer Conference Planning" appears in your agenda:

@example
Tuesday 1 May 2025
  Summer Conference Planning (review incubated project)
@end example

Options:
@itemize
@item
@strong{Ready to activate?} Press @code{RET} to jump to it, then @code{M-x org-gtd-reactivate}
@item
@strong{Still not ready?} Leave it incubated, or re-incubate with a later date
@end itemize

@strong{Reactivation Details}

When you run @code{org-gtd-reactivate}:

@enumerate
@item
State restoration happens automatically:
@itemize
@item
@code{PREVIOUS_ORG_GTD} → @code{ORG_GTD} (Incubated → Projects)
@item
@code{PREVIOUS_TODO} → TODO keywords restored
@item
@code{ORG_GTD_TIMESTAMP} removed (no longer in agenda)
@end itemize

@item
Dependency recalculation runs:
@itemize
@item
@code{org-gtd-projects-fix-todo-keywords} examines all dependencies
@item
Tasks with satisfied dependencies → marked NEXT
@item
Tasks still blocked → remain TODO
@end itemize

@item
Project graph opens automatically:
@itemize
@item
Review the project structure
@item
Verify NEXT/TODO states make sense
@item
Make any needed adjustments (@code{a}, @code{d}, @code{r} keys)
@end itemize
@end enumerate

@item
@anchor{Common Patterns and Scenarios}Common Patterns and Scenarios


@strong{Pattern: "Not Now, But Someday"}

Project ideas that might happen eventually:

@example
"Rewrite legacy authentication system"
"Migrate to new CRM platform"
"Redesign company website"
@end example

@strong{Strategy:}
@itemize
@item
Incubate with a FAR future date (2026-01-01)
@item
Or use quarterly review dates (2025-07-01, 2025-10-01, etc.)
@item
When review arrives, ask: "Is this the right time?" If no, re-incubate for next quarter
@end itemize

@strong{Pattern: "Waiting for External Factor"}

Projects blocked by external dependencies:

@example
"Launch new product" (waiting for legal approval)
"Office redesign" (waiting for budget committee meeting on May 15th)
"Implement new API" (waiting for vendor release)
@end example

@strong{Strategy:}
@itemize
@item
Incubate with review date = when you expect the blocker to clear
@item
Add note in project heading: "Incubated because: waiting for budget approval"
@item
When reactivated, first task might be "Check if budget was approved"
@end itemize

@strong{Pattern: "Quarterly Batch Projects"}

Projects you tackle in batches:

@example
"Review expenses" (quarterly)
"Update documentation" (quarterly)
"Audit security" (quarterly)
@end example

@strong{Strategy:}
@itemize
@item
After completing Q1 batch, incubate with Q2 start date
@item
Review dates: 2025-04-01, 2025-07-01, 2025-10-01, 2026-01-01
@item
Consistent rhythm without manual tracking
@end itemize

@strong{Pattern: "Collaborative Project, Waiting for Team"}

Project requires specific people who aren't available:

@example
"Marketing campaign redesign" (designer on vacation until June)
"Code refactoring sprint" (waiting for team to finish current release)
@end example

@strong{Strategy:}
@itemize
@item
Incubate with return/availability date
@item
In project heading, note: "Incubated: waiting for Sarah (back June 10th)"
@item
Reactivate when team is available, project structure intact
@end itemize

@item
@anchor{Advanced External Dependencies and Warnings}Advanced: External Dependencies and Warnings


@strong{What Are External Dependencies?}

Imagine:
@itemize
@item
Project A has "Task A1: Research vendor options"
@item
Project B (separate project) has "Task B1: Evaluate vendors" that depends on Task A1 completing
@end itemize

Task B1 has an *external dependency*—it depends on a task from a different project.

@strong{What Happens When Incubating}

If you incubate Project A, org-gtd warns you:

@example
External tasks depend on this project:
  - Task B1: Evaluate vendors (in Project B)

Continue incubating? (y/n)
@end example

@strong{@strong{Why warn?}} Incubating Project A clears Task A1's TODO keyword. Task B1 is still expecting Task A1 to be NEXT or TODO@. This creates a "dangling reference"—B1 is blocked by a task that doesn't exist in active work anymore.

@strong{@strong{Your options:}}

@enumerate
@item
@strong{Cancel incubation} (@code{n}): Don't incubate Project A yet. Maybe restructure dependencies first.

@item
@strong{Continue anyway} (@code{y}): Accept that Task B1 will stay TODO/blocked until you reactivate Project A@. Make a note in Project B about this.

@item
@strong{Remove the dependency}: Before incubating, use graph view to remove the B1 → A1 dependency link. Decide if B1 should proceed independently.
@end enumerate

@strong{Real-World Example}

You're planning a conference (Project Conference) with these tasks:
@itemize
@item
Book venue
@item
Invite speakers
@item
Set up registration
@end itemize

A separate project (Project Marketing) has:
@itemize
@item
"Design conference branding" → depends on "Book venue" (need venue details for design)
@end itemize

If you incubate Project Conference (venue not booked yet, conference might not happen), the warning shows you that Marketing's branding task will be stuck.

@strong{Decision:} You might realize the branding task should just wait in Project Marketing with a note "start when conference is confirmed", rather than having a hard dependency. Remove the link before incubating.

@item
@anchor{Technical Details How Incubation Works Under the Hood}Technical Details: How Incubation Works Under the Hood


@strong{Property-Based State Management}

Incubation uses properties, not file movement. The project and its tasks stay in the same file, same location. Only properties change:

Before incubation (Task 1 of a project):
#+begin@math{_example}
@end itemize

@node NEXT Task 1 Research options
@subsection NEXT Task 1: Research options

#+end@math{_example}

After incubation:
#+begin@math{_example}

@node Task 1 Research options
@subsection Task 1: Research options

#+end@math{_example}

Note:
@itemize
@item
TODO keyword cleared (was NEXT, now nothing)
@item
@code{ORG_GTD} changed to "Incubated"
@item
Original values saved in @code{PREVIOUS_*} properties
@item
Dependencies (@code{ORG_GTD_BLOCKS}) preserved unchanged
@end itemize

@strong{View Filtering Mechanism}

Why don't incubated tasks appear in views?

Most views filter by TODO keywords: @code{(todo . "NEXT")}, @code{(todo . "TODO|NEXT|WAIT")}, etc.

Since incubated tasks have NO TODO keyword (cleared to nil), they don't match these filters. Natural exclusion.

For area-of-focus reviews that show projects, we filter: @code{(and (property "ORG_GTD" "Projects") (property "CATEGORY" "Work"))}

Incubated projects have @code{(property "ORG_GTD" "Incubated")} instead of "Projects", so they appear in a separate "Incubated projects" section.

@strong{Reactivation Dependency Recalculation}

When you reactivate, here's the exact sequence:

@enumerate
@item
@strong{Restore properties} (for project heading + all tasks):
@itemize
@item
@code{PREVIOUS_ORG_GTD} → @code{ORG_GTD}
@item
@code{PREVIOUS_TODO} → TODO keyword
@item
Delete @code{PREVIOUS_*} properties
@item
Delete @code{ORG_GTD_TIMESTAMP}
@end itemize

@item
@strong{Recalculate NEXT/TODO states}:
@itemize
@item
Call @code{org-gtd-projects-fix-todo-keywords}
@item
This traverses the dependency graph breadth-first
@item
For each task: if ALL dependencies are DONE/CNCL → mark NEXT
@item
Otherwise → mark TODO
@end itemize

@item
@strong{Open graph view} (if interactive):
@itemize
@item
Shows the reactivated project visually
@item
User can verify states, adjust dependencies
@item
Immediate feedback on project structure
@end itemize
@end enumerate

@strong{@strong{Why recalculate?}} You might have manually edited the project while incubated—added tasks, changed dependencies, marked some DONE@. Recalculation ensures consistent state.

@strong{Multi-Project Task Detection}

The check:
@lisp
(let ((project-ids (org-entry-get-multivalued-property
                     (point) "ORG_GTD_PROJECT_IDS")))
  (if (> (length project-ids) 1)
      ;; Skip this task - belongs to multiple projects
      (message "Skipping multi-project task: %s" (org-get-heading))
    ;; Normal incubation
    ...))
@end lisp

If @code{ORG_GTD_PROJECT_IDS} contains @code{"project-a project-b"} (two IDs), the task belongs to both projects. Incubating one project shouldn't hide the task—it's still needed by the other project.

@itemize
@item
@anchor{Troubleshooting Incubation}Troubleshooting Incubation


@strong{Tasks Still Showing After Incubating Project}

@strong{Symptom:} You incubated a project, but some of its tasks still appear in your engage view.

@strong{Diagnosis:} Check if those tasks belong to multiple projects:
@enumerate
@item
Navigate to the task
@item
@code{C-c C-x p} (show properties)
@item
Look at @code{ORG_GTD_PROJECT_IDS} value
@item
If it has multiple IDs (space-separated), the task is shared
@end enumerate

@strong{Solution:} This is expected behavior. Multi-project tasks remain active because other projects need them. Options:
@itemize
@item
Incubate ALL projects the task belongs to (task will then be incubated)
@item
Remove the task from one of the projects first
@item
Accept that the task stays visible (it's genuinely active in another project)
@end itemize

@strong{Incubated Project Doesn't Appear on Review Date}

@strong{Symptom:} Review date arrived (e.g., June 1st), but the project doesn't show in your agenda.

@strong{Diagnosis:}
@enumerate
@item
Navigate to the project heading
@item
Check for @code{ORG_GTD_TIMESTAMP} property
@item
Verify format is @code{<2025-06-01>} (angle brackets, YYYY-MM-DD)
@item
Check your org-agenda-files includes the GTD file
@end enumerate

@strong{Solution:}
@itemize
@item
If property is missing: re-incubate with a date
@item
If format is wrong: manually fix to @code{<YYYY-MM-DD>}
@item
If file not in agenda: @code{M-x org-agenda-file-to-front} while in the GTD file
@end itemize

@strong{Reactivated Project Has Wrong NEXT/TODO States}

@strong{Symptom:} After reactivating, tasks that should be NEXT are showing as TODO, or vice versa.

@strong{Diagnosis:} Open graph view (@code{M-x org-gtd-show-project-graph}):
@itemize
@item
Trace arrows (dependencies)
@item
Check if dependencies are actually DONE
@item
Look for tasks with cleared keywords that should have keywords
@end itemize

@strong{Solution:}
@itemize
@item
Press @code{r} to refresh and recalculate states
@item
If recalculation doesn't fix it: dependencies might be incorrect
@item
Use @code{d} to modify dependencies, then @code{r} to recalculate
@end itemize

@strong{Can't Reactivate: "Not Incubated" Error}

@strong{Symptom:} Running @code{org-gtd-reactivate} gives error: "Item at point is not incubated"

@strong{Diagnosis:} Check the @code{ORG_GTD} property:
@enumerate
@item
@code{C-c C-x p} to show properties
@item
Look for @code{ORG_GTD} value
@item
Should be "Incubated"
@end enumerate

@strong{Solution:}
@itemize
@item
If @code{ORG_GTD} is something else (e.g., "Projects"): it's not incubated, nothing to reactivate
@item
If manually edited: set @code{ORG_GTD} back to "Incubated" or just manually restore the state
@item
If @code{PREVIOUS_*} properties are missing: you'll need to manually set states
@end itemize

@item
@anchor{See Also (1)}See Also


@itemize
@item
@ref{Commands Reference} for @code{org-gtd-incubate} and @code{org-gtd-reactivate} full command details
@item
@ref{Tutorial Your First Project} for project basics before incubating
@item
@ref{First Contact Why Visual Project Management?, , Why Visual Project Management?} for understanding project structure
@item
@ref{Properties Reference (Internal Implementation), , Properties Reference} for @code{PREVIOUS_ORG_GTD}, @code{PREVIOUS_TODO}, @code{ORG_GTD_TIMESTAMP} details
@end itemize
@end itemize

@node Project Progress Cookies See Your Progress at a Glance
@subsection Project Progress Cookies: See Your Progress at a Glance

@itemize
@item
@anchor{First Contact What Are Progress Cookies?}First Contact: What Are Progress Cookies?


Progress cookies show how far along your project is: @code{[3/7][42%]} means 3 of 7 tasks done.

They appear directly on project headings, so you can scan your project list and instantly know which projects are nearly complete, which are just starting, and which might need attention.

@strong{Who needs this?} Anyone managing multiple projects who wants quick visual feedback without opening each project to count tasks.

@item
@anchor{Black Triangle See Progress in 30 Seconds}Black Triangle: See Progress in 30 Seconds


Your projects already have progress cookies—they're enabled by default.

@enumerate
@item
Open your engage view: @code{C-c d e}
@item
Find any project task
@item
Press @code{RET} to jump to the project heading
@end enumerate

You'll see something like:

@example
* PROJ Buy a house [0/5][0%]                      :home:
@end example

That's it. The @code{[0/5][0%]} shows 0 of 5 tasks completed.

@item
@anchor{Tutorial Watch Cookies Update Automatically}Tutorial: Watch Cookies Update Automatically


Let's see progress cookies in action:

@enumerate
@item
@strong{Find a project with tasks:}
@itemize
@item
Open engage view: @code{C-c d e}
@item
Navigate to a project task, press @code{RET} to go to the project heading
@item
Note the current cookie: @code{[0/3][0%]} (or similar)
@end itemize

@item
@strong{Complete a task:}
@itemize
@item
Find a NEXT task in that project
@item
Mark it done: @code{C-c C-t DONE} (or cycle to DONE)
@end itemize

@item
@strong{Check the project heading:}
@itemize
@item
Scroll up to the project heading
@item
The cookie updated: @code{[1/3][33%]}
@end itemize
@end enumerate

No manual refresh needed. Complete tasks, cookies update automatically.

@item
@anchor{Understanding How Cookies Work}Understanding How Cookies Work


@strong{@strong{What gets counted?}}

Progress cookies count all tasks linked to the project via @code{ORG_GTD_PROJECT_IDS}. This is different from org-mode's built-in @code{[/]} cookies which only count direct children.

Why does this matter? In org-gtd v4, projects are DAGs (directed acyclic graphs)—tasks can live anywhere in your GTD files and link to projects by ID@. The cookie counts ALL linked tasks, regardless of where they're located in your files.

@strong{@strong{When do cookies update?}}

@itemize
@item
@strong{Task state changes:} Complete a task → cookie updates immediately
@item
@strong{Project creation:} New projects get cookies automatically
@item
@strong{Manual refresh:} @code{M-x org-gtd-project-update-all-cookies} refreshes everything
@item
@strong{Fix TODO keywords:} @code{M-x org-gtd-projects-fix-all-todo-keywords} also refreshes cookies
@end itemize

@item
@anchor{Configuring Cookie Position}Configuring Cookie Position


Control where cookies appear with @code{org-gtd-project-progress-cookie-position}:

@lisp
;; At end of heading, before tags (default)
(setq org-gtd-project-progress-cookie-position 'end)

;; After TODO keyword, before title
(setq org-gtd-project-progress-cookie-position 'start)

;; Disable cookies entirely
(setq org-gtd-project-progress-cookie-position nil)
@end lisp

Visual comparison:

@example
;; 'end (default):
* PROJ Buy a house [3/7][42%]                    :home:

;; 'start:
* PROJ [3/7][42%] Buy a house                    :home:

;; nil:
* PROJ Buy a house                               :home:
@end example

@item
@anchor{Common Scenarios}Common Scenarios


@strong{@strong{Cookies look wrong after external edits}}

You edited tasks outside org-gtd (mobile app, manual edit) and cookies don't match reality.

@strong{Fix:} @code{M-x org-gtd-project-update-all-cookies}

This scans all projects and recalculates from scratch.

@strong{@strong{Want to disable cookies for performance}}

If you have hundreds of projects and notice slowness:

@lisp
(setq org-gtd-project-progress-cookie-position nil)
@end lisp

Cookies won't update or display.

@strong{@strong{Cookies showing 0/0}}

This means no tasks are linked to the project. Either:
@itemize
@item
The project has no tasks yet (add some)
@item
Tasks don't have @code{ORG_GTD_PROJECT_IDS} pointing to this project (check properties)
@end itemize

@item
@anchor{Technical Reference}Technical Reference


@strong{@strong{Format:}} @code{[completed/total][percent%]}

@strong{@strong{Calculation:}} Scans all headings with @code{ORG_GTD_PROJECT_IDS} matching the project's ID@. Counts tasks with TODO keyword in @code{org-done-keywords} as completed.

@strong{@strong{Storage:}} Actual text on the heading (not computed at display time). This means cookies persist and are visible even in non-Emacs editors.

@strong{@strong{Hook:}} @code{org-after-todo-state-change-hook} triggers recalculation when task states change.

@strong{@strong{Related commands:}}
@table @asis
@item @code{org-gtd-project-update-all-cookies}
Refresh all project cookies
@item @code{org-gtd-projects-fix-all-todo-keywords}
Fixes keywords AND refreshes cookies
@end table

@strong{See also:} @ref{@code{org-gtd-project-progress-cookie-position}} in Configuration Variables Reference.
@end itemize

@node Cleaning up / archiving completed work
@subsection Cleaning up / archiving completed work

Doing this without user intervention is tricky, as it makes undoing actions more complicated. As such, Org GTD provides a function that will go through the @code{org-gtd-directory} files, find the headings that belong to Org GTD (see @ref{Refiling to the appropriate area}), and archive the finished items.

The variable @code{org-gtd-archive-location} points to a @strong{function} that returns a string matching the @code{org-archive-location} definition. It is a function in order to allow the filename to be dynamic.

The function to archive everything is @code{M-x org-gtd-archive-completed-items}.

@node Commands you can call on org-agenda
@subsection Commands you can call on org-agenda

Since Org provides the agenda, it is a convenient base of operations for interacting with things that come up through @code{org-gtd-engage}.

Here are the actions available to you:

@table @asis
@item @code{M-x org-gtd-delegate-agenda-item}
When the point is on an action, this will properly delegate the action to someone else.
@item @code{M-x org-gtd-project-cancel-from-agenda}
When the point is on a project action, this command will cancel the remaining actions in the project.
@item @code{M-x org-gtd-clarify-agenda-item}
If you would like to clarify and organize an item through the agenda view, for whatever reason, this is your entry point.
@end table

@node Defining your own agenda views
@subsection Defining your own agenda views

You can define your own agenda views by defining functions with custom agenda commands. As long as you have @code{org-gtd-directory} in your @code{org-agenda-files} (required for org-gtd to work), your views will include GTD items automatically.

@lisp
(defun my-agenda ()
  (let ((org-agenda-custom-commands '(your-definition-here)))
    (org-agenda nil "x")))
@end lisp

Where @samp{x} is whatever your defined key is.

@strong{See also}: For a much easier way to create custom views, see @ref{View DSL Filter Reference}, which provides a declarative language for defining views without writing skip functions.

@node Adding your own hooks when organizing
@subsection Adding your own hooks when organizing

Adding useful metadata to the tasks allows you to enhance the agenda view to make it more useful to you, whether it be effort, tags, priority, or any other amount of information you might like.

This being said, different types of tasks or items are not even created equal. For instance, there may be metadata you want to add to a project heading but not its tasks, or to a calendar item and not to a trash item.

Org GTD therefore provides a helper function, @code{org-gtd-organize-type-member-p}, which you can use when creating your own hooks. The function takes one argument, a list of types (provided in the function's documentation).
When called as part of a hook, this function will check a buffer-local variable called @code{org-gtd--organize-type}, managed by Org GTD, to determine truthiness.

For an example, see the source code for @code{org-gtd-areas-of-focus--set}, which will not run if the task being organized is a project task, trash, knowledge, or a quick action.

@strong{See also}: For complete documentation on the hooks framework, including many examples and best practices, see @ref{Hooks Framework Reference}.

@node Automating through emacs
@section Automating through emacs

There's now a few functions you can use when you are doing work within emacs and would like GTD to track something for you as a result:
@itemize
@item
@code{org-gtd-habit-create}
@item
@code{org-gtd-calendar-create}
@item
@code{org-gtd-delegate-create}
@item
@code{org-gtd-incubate-create}
@item
@code{org-gtd-single-action-create}
@end itemize

See the documentation for each, but suffice it to say they all take, at the very least, a string that will be used as the text part of the org heading that gets stored in org-gtd.

For instance, one way this could work:

@lisp
(defun org-gtd-email-reminder ()
  (let ((topic (message-fetch-field "subject"))
        (delegated-to (message-fetch-field "to"))
        (reminder-date (org-read-date nil nil "+3d")))
    (org-gtd-delegate-create (format "Reminder: %s" topic)
                             delegated-to
                             reminder-date)))

(add-hook 'message-send-hook 'org-gtd-email-reminder)
@end lisp

@strong{See also}: @ref{Commands Reference} for complete documentation of all programmatic creation commands.

@node Reference
@chapter Reference

This section provides complete reference documentation for all org-gtd configuration variables, commands, properties, and advanced features. Use this section when you need to look up specific details about a configuration option, command, or property.

@strong{Quick navigation}:
@itemize
@item
@ref{Configuration Variables Reference} - All customization options
@item
@ref{Commands Reference} - All interactive commands organized by workflow step
@item
@ref{Properties Reference (Internal Implementation), , Properties Reference} - All org properties used by org-gtd
@item
@ref{View DSL Filter Reference} - Complete guide to creating custom views
@item
@ref{Hooks Framework Reference} - Complete guide to customization hooks
@end itemize

For learning how to use org-gtd, start with @ref{Getting Started with Org GTD} and @ref{Using Org GTD}.

@menu
* Configuration Variables Reference:: All customization variables explained
* Commands Reference::           All interactive commands explained
* Properties Reference (Internal Implementation):: All org properties used by org-gtd
* Troubleshooting Projects::     How to fix project dependency problems
* View DSL Filter Reference::    Complete reference for the View DSL
* Hooks Framework Reference::    Complete guide to customization hooks
@end menu

@node Configuration Variables Reference
@section Configuration Variables Reference

These variables control how org-gtd behaves. All can be customized via @code{M-x customize-group RET org-gtd}.

@menu
* Required Configuration::
* Directory and File Configuration::
* Capture Configuration::
* Organize and Process Configuration::
* Clarification Configuration::
* Areas of Focus Configuration::
* Engage View Configuration::
* Archive Configuration::
* Missed Engagements Review Configuration::
* ID Overlay Configuration::
* Advanced Item Configuration::
* Projects Configuration::
* Obsolete Variables (Do Not Use)::
@end menu

@node Required Configuration
@subsection Required Configuration

@itemize
@item
@anchor{@code{org-todo-keywords} (org-mode variable)}@code{org-todo-keywords} (org-mode variable)


@strong{Type}: List of keyword sequences

@strong{Default}: Varies by org-mode installation

@strong{Description}: Defines TODO keyword sequences for org-mode. All GTD keywords must be in the @strong{same sequence}.

@strong{Required format}:
@lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
@end lisp

The @code{|} separator marks done states (right side) from active states (left side).

@item
@anchor{@code{org-gtd-keyword-mapping}}@code{org-gtd-keyword-mapping}


@strong{Type}: Alist mapping GTD states to keyword strings

@strong{Default}:
@lisp
'((todo . "TODO")
  (next . "NEXT")
  (wait . "WAIT")
  (canceled . "CNCL"))
@end lisp

@strong{Description}: Maps GTD semantic states to your chosen TODO keywords.

@strong{Required keys}:
@table @asis
@item @code{todo}
Tasks not ready to be acted upon
@item @code{next}
Tasks ready to act on immediately
@item @code{wait}
Tasks blocked or delegated to someone else
@item @code{done}
Tasks successfully completed
@item @code{canceled}
Tasks that won't be completed
@end table

@strong{Example}: Using custom keywords:
@lisp
(setq org-todo-keywords
      '((sequence "TASK" "DOING" "BLOCKED" "|" "COMPLETE" "CANCELLED")))

(setq org-gtd-keyword-mapping
      '((todo . "TASK")
        (next . "DOING")
        (wait . "BLOCKED")
        (done . "COMPLETE")
        (canceled . "CANCELLED")))
@end lisp
@end itemize

@node Directory and File Configuration
@subsection Directory and File Configuration

@itemize
@item
@anchor{@code{org-gtd-directory}}@code{org-gtd-directory}


@strong{Type}: String (directory path)

@strong{Default}: @code{"~/gtd/"}

@strong{Description}: Directory where org-gtd keeps all its files.

org-gtd will look for all its files in this directory:
@itemize
@item
@code{inbox.org} - Capture target
@item
@code{org-gtd-tasks.org} - Main GTD file
@item
@code{org-gtd-incubate.org} - Someday/maybe items
@item
@code{org-gtd-calendar.org} - Calendar items
@end itemize

@strong{Example}:
@lisp
(setq org-gtd-directory "~/my-gtd/")
@end lisp

@strong{Note}: Make sure to add this directory to @code{org-agenda-files}:
@lisp
(setq org-agenda-files (list org-gtd-directory))
@end lisp

@item
@anchor{@code{org-gtd-additional-inbox-files}}@code{org-gtd-additional-inbox-files}


@strong{Type}: List of file paths

@strong{Default}: @code{nil}

@strong{Description}: Additional inbox files to process after the main inbox.

When you call @code{org-gtd-process-inbox}, it first processes all items in the main inbox (@code{inbox.org}). After the main inbox is empty, it continues processing items from these additional files in order.

This is useful when you capture items from multiple sources:
@itemize
@item
Mobile apps that sync to a separate file
@item
Email-to-org workflows
@item
Context-specific inboxes (work, personal)
@end itemize

@strong{Example}:
@lisp
(setq org-gtd-additional-inbox-files
      '("~/gtd/mobile-inbox.org"
        "~/gtd/email-inbox.org"))
@end lisp

@strong{Note}: Each file should contain org headings at the top level, just like the main inbox.

@item
@anchor{@code{org-gtd-horizons-file}}@code{org-gtd-horizons-file}


@strong{Type}: String (filename)

@strong{Default}: @code{"horizons.org"}

@strong{Description}: Name of file (in @code{org-gtd-directory}) containing your GTD horizons (long-term goals, areas of focus, purpose).

This file can be displayed during clarification for context.

@strong{Example}:
@lisp
(setq org-gtd-horizons-file "my-horizons.org")
@end lisp
@end itemize

@node Capture Configuration
@subsection Capture Configuration

@itemize
@item
@anchor{@code{org-gtd-capture-templates}}@code{org-gtd-capture-templates}


@strong{Type}: List of org-capture template specifications

@strong{Default}:
@lisp
'(("i" "Inbox"
   entry  (file ,#'org-gtd-inbox-path)
   "* %?\n%U\n\n  %i"
   :kill-buffer t)
  ("l" "Inbox with link"
   entry  (file ,#'org-gtd-inbox-path)
   "* %?\n%U\n\n  %i\n  %a"
   :kill-buffer t))
@end lisp

@strong{Description}: Capture templates specific to org-gtd inbox.

@strong{Constraints} (must be satisfied for org-gtd to work correctly):
@enumerate
@item
Template string must start with @code{"* "} (asterisk + space for org heading)
@item
Entry type must be: @code{entry (file ,#'org-gtd-inbox-path)}
@end enumerate

@strong{Example}: Adding a custom template:
@lisp
(setq org-gtd-capture-templates
      '(("i" "Inbox"
         entry (file ,#'org-gtd-inbox-path)
         "* %?\n%U\n\n  %i"
         :kill-buffer t)
        ("m" "Meeting note"
         entry (file ,#'org-gtd-inbox-path)
         "* Meeting: %?\n%U\n\nAttendees:\n\nNotes:\n"
         :kill-buffer t)))
@end lisp
@end itemize

@node Organize and Process Configuration
@subsection Organize and Process Configuration

@itemize
@item
@anchor{@code{org-gtd-organize-hooks}}@code{org-gtd-organize-hooks}


@strong{Type}: List of functions

@strong{Default}: @code{'(org-set-tags-command)}

@strong{Description}: Functions run when organizing each item. Each function can add metadata (tags, properties, etc.) to the item being organized.

The default value prompts for tags. Built-in options:
@table @asis
@item @code{org-set-tags-command}
Prompt for tags (default)
@item @code{org-gtd-set-area-of-focus}
Prompt for area of focus
@item Custom functions
Functions you write yourself
@end table

@strong{Example}: Add effort estimation and area of focus:
@lisp
(defun my-add-effort ()
  "Prompt for effort when organizing."
  (when (org-gtd-organize-type-member-p '(action project))
    (org-set-effort)))

(setq org-gtd-organize-hooks
      '(org-set-tags-command
        org-gtd-set-area-of-focus
        my-add-effort))
@end lisp

@strong{Helper function}: @code{org-gtd-organize-type-member-p}
@itemize
@item
Takes a list of item types to check against
@item
Returns t if current item matches one of the types
@item
Available types: @code{action}, @code{project}, @code{project-task}, @code{calendar}, @code{delegate}, @code{incubate}, @code{habit}, @code{knowledge}, @code{quick}, @code{trash}
@end itemize

@item
@anchor{@code{org-gtd-save-after-organize}}@code{org-gtd-save-after-organize}


@strong{Type}: Boolean

@strong{Default}: @code{nil}

@strong{Description}: If non-nil, save all modified buffers after each organize step.

Useful if you want automatic saves during inbox processing.

@strong{Example}:
@lisp
(setq org-gtd-save-after-organize t)
@end lisp

@item
@anchor{@code{org-gtd-refile-to-any-target}}@code{org-gtd-refile-to-any-target}


@strong{Type}: Boolean

@strong{Default}: @code{t}

@strong{Description}: Control refile behavior when organizing items.

@itemize
@item
When @code{t}: org-gtd will refile to the first target it finds, or create a target if necessary, without confirmation
@item
When @code{nil}: org-gtd will ask for confirmation regardless of number of options
@end itemize

@strong{Example}: Require manual refile target selection:
@lisp
(setq org-gtd-refile-to-any-target nil)
@end lisp
@end itemize

@node Clarification Configuration
@subsection Clarification Configuration

@itemize
@item
@anchor{@code{org-gtd-clarify-show-horizons}}@code{org-gtd-clarify-show-horizons}


@strong{Type}: Symbol or nil

@strong{Default}: @code{nil}

@strong{Description}: Whether to show horizons file during clarification.

Values:
@table @asis
@item @code{nil}
Don't show horizons by default
@item @code{'top}
Show horizons window at top
@item @code{'bottom}
Show horizons window at bottom
@item @code{'left}
Show horizons window on left
@item @code{'right}
Show horizons window on right
@end table

@strong{Example}:
@lisp
(setq org-gtd-clarify-show-horizons 'right)
@end lisp

@strong{Related command}: @code{org-gtd-clarify-toggle-horizons-window} to toggle visibility during clarification.

@item
@anchor{@code{org-gtd-clarify-display-helper-buffer}}@code{org-gtd-clarify-display-helper-buffer}


@strong{Type}: Boolean

@strong{Default}: @code{nil}

@strong{Description}: If non-nil, display project dependencies helper window when clarifying projects.

When enabled, shows a live view of task relationships in a side window when there are multiple tasks in the WIP buffer.

Useful for:
@itemize
@item
Understanding complex dependency graphs
@item
Spotting cycles before they cause problems
@item
Planning parallel execution paths
@end itemize

@strong{Example}:
@lisp
(setq org-gtd-clarify-display-helper-buffer t)
@end lisp

@item
@anchor{@code{org-gtd-clarify-project-templates}}@code{org-gtd-clarify-project-templates}


@strong{Type}: Alist of (name . template) strings

@strong{Default}: @code{nil}

@strong{Description}: Pre-defined project templates for common project types.

Each entry is a pair of (template-name . template-tasks) where template-tasks is a string of org headings to insert.

@strong{Example}:
@lisp
(setq org-gtd-clarify-project-templates
      '(("Blog Post" . "** Research topic\n** Write draft\n** Edit\n** Add images\n** Publish")
        ("Code Feature" . "** Design API\n** Write tests\n** Implement feature\n** Code review\n** Merge")))
@end lisp

@strong{Entering newlines in templates}: When setting this variable in your configuration file, use @code{\n} for newlines as shown above. If entering template strings interactively (e.g., via @code{M-x customize-variable} or in the minibuffer), use @code{C-q C-j} to insert a literal newline character. This works on all platforms including Windows.

Use @code{org-gtd-clarify-project-insert-template} during clarification to insert a template.
@end itemize

@node Areas of Focus Configuration
@subsection Areas of Focus Configuration

@itemize
@item
@anchor{@code{org-gtd-areas-of-focus}}@code{org-gtd-areas-of-focus}


@strong{Type}: List of strings

@strong{Default}: @code{'("Home" "Health" "Family" "Career")}

@strong{Description}: Your areas of focus (GTD Horizon 2) - the major areas in your life where you don't want to drop balls.

Used when:
@itemize
@item
Adding area of focus to items (via @code{org-gtd-set-area-of-focus} hook)
@item
Reviewing specific areas with @code{org-gtd-review-area-of-focus}
@end itemize

@strong{Example}:
@lisp
(setq org-gtd-areas-of-focus
      '("Work" "Home" "Health" "Learning" "Relationships" "Finance"))
@end lisp
@end itemize

@node Engage View Configuration
@subsection Engage View Configuration

@itemize
@item
@anchor{@code{org-gtd-engage-prefix-width}}@code{org-gtd-engage-prefix-width}


@strong{Type}: Integer

@strong{Default}: @code{12}

@strong{Description}: How many characters to dedicate to the prefix in the engage agenda view.

The prefix shows the project name on the left side of each task.

@strong{Example}: Increase space for longer project names:
@lisp
(setq org-gtd-engage-prefix-width 20)
@end lisp
@end itemize

@node Archive Configuration
@subsection Archive Configuration

@itemize
@item
@anchor{@code{org-gtd-archive-location}}@code{org-gtd-archive-location}


@strong{Type}: Function (zero arguments, returns string) or @code{nil}

@strong{Default}: @code{#'org-gtd-archive-location-func}

@strong{Description}: Archive location for org-gtd, or @code{nil} to use @code{org-archive-location}.

When @code{nil}, org-gtd uses org-mode's standard @code{org-archive-location} variable. This allows you to use your existing org-mode archive configuration with org-gtd.

When a function, calls it to get the archive location string. The returned string must match @code{org-archive-location} format.

Default function generates: @samp{gtd_archive_YYYY.org::datetree/} (year-based archive files in @code{org-gtd-directory}).

@strong{Example}: Use org-mode's standard archive location:
@lisp
;; Respect your org-archive-location setting
(setq org-gtd-archive-location nil)
;; Configure org-mode's archive as usual
(setq org-archive-location "archive.org::* Archived")
@end lisp

@strong{Example}: Archive to a single file:
@lisp
(defun my-archive-location ()
  "Archive to a single file."
  "archive.org::")

(setq org-gtd-archive-location #'my-archive-location)
@end lisp

@strong{Example}: Archive to month-based files:
@lisp
(defun my-monthly-archive ()
  "Archive to month-based files."
  (format "archive-%s.org::datetree/"
          (format-time-string "%Y-%m")))

(setq org-gtd-archive-location #'my-monthly-archive)
@end lisp
@end itemize

@node Missed Engagements Review Configuration
@subsection Missed Engagements Review Configuration

@itemize
@item
@anchor{@code{org-gtd-review-missed-custom-views}}@code{org-gtd-review-missed-custom-views}


@strong{Type}: List of GTD view specifications

@strong{Default}: @code{nil}

@strong{Purpose}: Create custom views to find specific types of missed engagements (e.g., only work-related items, only specific areas of focus).

Think of this like creating saved searches. Instead of seeing ALL missed items, you can create views that show only the ones relevant to a specific context.

@strong{When to use}: If you have multiple areas of focus (Work, Home, Hobbies) and want to review each separately.

@strong{Example - Area-Specific Reviews}:
@lisp
(setq org-gtd-review-missed-custom-views
      '(((name . "Overdue Work Items")
         (filters . ((area-of-focus . "Work")
                     (deadline . past))))
        ((name . "Missed Home Appointments")
         (filters . ((area-of-focus . "Home")
                     (category . calendar)
                     (timestamp . past))))))
@end lisp

After configuring, run @code{M-x org-gtd-review-missed-with-custom} to see all standard views plus your custom ones.

@strong{Backward compatibility}: The old variable name @code{org-gtd-oops-custom-views} still works but will be removed in a future version.
@end itemize

@node ID Overlay Configuration
@subsection ID Overlay Configuration

@itemize
@item
@anchor{@code{org-gtd-id-overlay-truncate-length}}@code{org-gtd-id-overlay-truncate-length}


@strong{Type}: Integer

@strong{Default}: @code{20}

@strong{Description}: Maximum length for displayed heading text in ID overlays.

When @code{org-gtd-id-overlay-mode} is enabled, task IDs are replaced with truncated heading text for readability.

@strong{Example}:
@lisp
(setq org-gtd-id-overlay-truncate-length 30)
@end lisp

@item
@anchor{@code{org-gtd-id-overlay-ellipsis}}@code{org-gtd-id-overlay-ellipsis}


@strong{Type}: String

@strong{Default}: @code{"..."}

@strong{Description}: String to append to truncated heading text in ID overlays.

@strong{Example}:
@lisp
(setq org-gtd-id-overlay-ellipsis "…")
@end lisp
@end itemize

@node Advanced Item Configuration
@subsection Advanced Item Configuration

@itemize
@item
@anchor{@code{org-gtd-user-item-config}}@code{org-gtd-user-item-config}


@strong{Type}: Alist

@strong{Default}: @code{'()}

@strong{Description}: Override default behavior for GTD item types.

This is an advanced feature for customizing how org-gtd handles different item types. If org-gtd finds an item type in this alist, it uses your configuration instead of the built-in one.

@strong{Example: Integrating Contact Managers with Delegation}

BBDB (Insidious Big Brother Database) and its modern successor EBDB are Emacs contact management packages that store information about people (names, emails, addresses, phone numbers, etc.). They integrate with mail clients and other Emacs packages. If you use BBDB or EBDB to manage your contacts, you can configure org-gtd to use completion from your contacts database when delegating tasks.

For EBDB integration:
@lisp
;; Define function to fetch EBDB contacts
(defun my/ebdb-contacts ()
  "Return alist of (name . uuid) from EBDB contacts."
  (mapcar (lambda (rec)
            (let* ((name (ebdb-record-name-string rec))
                   (uuid (ebdb-record-uuid rec)))
              (cons name uuid)))
          (ebdb-records)))

;; Create custom input type for delegation that uses EBDB
(setq org-gtd-default-input-config
      (append org-gtd-default-input-config
              '(('delegate-person . (lambda (prompt)
                                     (completing-read (format "%s: " prompt)
                                                     (mapcar 'car (my/ebdb-contacts))
                                                     nil t))))))

;; Configure delegation to use the custom input type
(setq org-gtd-user-item-config
      '((:delegated
         . ((DELEGATED_TO . ((type . 'delegate-person)
                             (prompt . "Delegate to")))))))
@end lisp

For BBDB integration, adapt the function to use @code{bbdb-records} and @code{bbdb-record-name} instead:
@lisp
(defun my/bbdb-contacts ()
  "Return alist of (name . uuid) from BBDB contacts."
  (mapcar (lambda (rec)
            (cons (bbdb-record-name rec)
                  (bbdb-record-uuid rec)))
          (bbdb-records)))
@end lisp

This same pattern can be used to integrate other completion sources (org-contacts, your own custom databases, etc.) with any org-gtd input prompt that uses the @code{'text} type.
@end itemize

@node Projects Configuration
@subsection Projects Configuration

@itemize
@item
@anchor{@code{org-gtd-project-progress-cookie-position}}@code{org-gtd-project-progress-cookie-position}


@strong{Type}: Symbol or nil

@strong{Default}: @code{'end}

@strong{Description}: Controls where progress cookies are displayed on project headings.

Values:
@table @asis
@item @code{nil}
Disabled (no cookies shown)
@item @code{'start}
After TODO keyword, before title
@item @code{'end}
After heading text, before tags (default)
@end table

Progress cookies show project completion as @code{[completed/total][percent%]} format, for example @code{[3/7][42%]}.

Unlike org-mode's built-in statistics cookies (@code{[/]} or @code{[%]}) which count direct children, org-gtd's progress cookies correctly count all tasks linked to the project via @code{ORG_GTD_PROJECT_IDS}, making them accurate for the DAG-based project structure.

@strong{Example}:
@lisp
;; Show cookies at end of heading (default)
(setq org-gtd-project-progress-cookie-position 'end)

;; Show cookies at start of heading
(setq org-gtd-project-progress-cookie-position 'start)

;; Disable progress cookies
(setq org-gtd-project-progress-cookie-position nil)
@end lisp

@strong{What it looks like}:
@example
;; With 'end (default):
* PROJ Buy a house [3/7][42%]                    :home:

;; With 'start:
* PROJ [3/7][42%] Buy a house                    :home:

;; With nil:
* PROJ Buy a house                               :home:
@end example

@strong{Automatic updates}: Cookies are automatically recalculated when:
@itemize
@item
Task TODO states change (via hook)
@item
Project is created
@item
@code{org-gtd-projects-fix-all-todo-keywords} is run
@item
@code{org-gtd-project-update-all-cookies} is called manually
@end itemize

@strong{See also}: @ref{Project Progress Cookies See Your Progress at a Glance, , Project Progress Cookies} for detailed usage, @ref{@code{org-gtd-project-update-all-cookies}} for manual refresh.
@end itemize

@node Obsolete Variables (Do Not Use)
@subsection Obsolete Variables (Do Not Use)

These variables are obsolete as of version 4.0. They are listed here for reference only.

@itemize
@item
@anchor{@code{org-gtd-todo-keyword} (obsolete)}@code{org-gtd-todo-keyword} (obsolete)


@strong{Use instead}: @code{org-gtd-keyword-mapping} with key @code{'todo}

@item
@anchor{@code{org-gtd-next-keyword} (obsolete)}@code{org-gtd-next-keyword} (obsolete)


@strong{Use instead}: @code{org-gtd-keyword-mapping} with key @code{'next}

@item
@anchor{@code{org-gtd-wait-keyword} (obsolete)}@code{org-gtd-wait-keyword} (obsolete)


@strong{Use instead}: @code{org-gtd-keyword-mapping} with key @code{'wait}

@item
@anchor{@code{org-gtd-canceled-keyword} (obsolete)}@code{org-gtd-canceled-keyword} (obsolete)


@strong{Use instead}: @code{org-gtd-keyword-mapping} with key @code{'canceled}
@end itemize

@node Commands Reference
@section Commands Reference

This section lists all interactive commands available in org-gtd, organized by workflow step.

@menu
* Core GTD Workflow Commands::
* Review Commands::
* Stuck Item Review Commands::
* Review Commands (Missed Engagements)::
* Review Commands (Upcoming Delegated)::
* Custom View Commands::
* Clarification Commands::
* Archive Commands::
* Agenda-Specific Commands::
* Project Management Commands::
* Task Dependency Commands::
* Area of Focus Commands::
* Programmatic Creation Commands::
* Utility Commands::
* ID Overlay Commands::
* Migration and Upgrade Commands::
* Obsolete Commands::
@end menu

@node Core GTD Workflow Commands
@subsection Core GTD Workflow Commands

@itemize
@item
@anchor{@code{org-gtd-capture}}@code{org-gtd-capture}


@strong{Binding}: Typically @code{C-c d c} (user-configurable)

@strong{When to use}: Anytime something comes up that you need to capture

@strong{What it does}:
@itemize
@item
Opens org-capture for the inbox
@item
Uses templates from @code{org-gtd-capture-templates}
@item
Stores item in inbox.org for later processing
@end itemize

@strong{Arguments}: Optional @code{goto} and @code{keys} (same as @code{org-capture})

@strong{Example usage}:
@example
M-x org-gtd-capture
Type: "Call dentist to schedule checkup"
C-c C-c to save
@end example

@item
@anchor{@code{org-gtd-process-inbox}}@code{org-gtd-process-inbox}


@strong{Binding}: Typically @code{C-c d p}

@strong{When to use}: When your inbox has items (daily or multiple times daily)

@strong{What it does}:
@itemize
@item
Starts processing loop through inbox items
@item
Opens each item in a clarify buffer (WIP mode)
@item
Continues until inbox is empty or you quit
@item
If @code{org-gtd-additional-inbox-files} is configured, continues through those files after main inbox
@end itemize

@strong{How to use}:
@enumerate
@item
Run command
@item
Edit each item to clarify it
@item
Press your organize binding (@code{C-c c}) to organize it
@item
Repeat for next item
@end enumerate

@strong{Related}: @code{org-gtd-clarify-item} to clarify a single item without processing whole inbox

@item
@anchor{@code{org-gtd-organize}}@code{org-gtd-organize}


@strong{Binding}: Typically @code{C-c c} (only works in clarify buffers)

@strong{When to use}: After clarifying an item, to categorize it

@strong{What it does}:
@itemize
@item
Opens transient menu with organization options
@item
Prompts for item-specific information (dates, names, etc.)
@item
Runs organize hooks
@item
Refiles item to appropriate location
@end itemize

@strong{Important}: This only works in clarify buffers (org-gtd-wip-mode). It won't work in regular org files.

@strong{Item types available}:
@itemize
@item
[P] Project
@item
[A] Add to existing project
@item
[C] Calendar
@item
[D] Delegate
@item
[S] Single action
@item
[H] Habit
@item
[I] Incubate
@item
[K] Knowledge
@item
[Q] Quick action
@item
[T] Trash
@end itemize

@item
@anchor{@code{org-gtd-engage}}@code{org-gtd-engage}


@strong{Binding}: Typically @code{C-c d e}

@strong{When to use}: Daily (or multiple times daily) to see what you can work on right now

@strong{What it does}:
@itemize
@item
Shows org-agenda view customized for GTD
@item
Displays the following.
@itemize
@item
Agenda for today (appointments, deadlines, scheduled items)
@item
All NEXT actions (grouped by project)
@end itemize
@item
Uses prefix width from @code{org-gtd-engage-prefix-width}
@end itemize

@strong{Agenda commands available in this view}:
@table @asis
@item @code{t}
Change TODO state
@item @code{RET}
Visit item
@item @code{r}
Refile
@item All other org-agenda commands
Available as normal
@end table

@item
@anchor{@code{org-gtd-show-all-next}}@code{org-gtd-show-all-next}


@strong{Binding}: Typically @code{C-c d n}

@strong{When to use}: When you want to focus only on NEXT actions, without calendar/scheduled items

@strong{What it does}:
@itemize
@item
Shows all items with NEXT keyword
@item
Simpler than engage view (no agenda section)
@item
Useful for "get things done" focus mode
@end itemize
@end itemize

@node Review Commands
@subsection Review Commands

@itemize
@item
@anchor{@code{org-gtd-review-stuck-projects}}@code{org-gtd-review-stuck-projects}


@strong{Binding}: Typically @code{C-c d s}

@strong{When to use}: Weekly review, or when projects seem stalled

@strong{What it does}:
@itemize
@item
Finds projects that have active tasks but no NEXT actions
@item
Indicates dependency problems or missing FIRST@math{_TASKS}
@end itemize

@strong{How to fix stuck projects}:
@enumerate
@item
Navigate to project heading
@item
Run @code{org-gtd-projects-fix-todo-keywords-for-project-at-point}
@item
If still stuck, check dependencies
@end enumerate

@item
@anchor{@code{org-gtd-review-area-of-focus}}@code{org-gtd-review-area-of-focus}


@strong{Arguments}: Optional AREA and START-DATE

@strong{When to use}: During weekly/monthly reviews to focus on specific life area

@strong{What it does}:
@itemize
@item
Generates agenda view for items tagged with a specific area of focus
@item
Prompts for area if not provided
@item
Shows all items (projects, actions, calendar) for that area
@end itemize

@strong{Example}:
@example
M-x org-gtd-review-area-of-focus
Area: Work
Shows: All Work-related items
@end example

@item
@anchor{@code{org-gtd-review-completed-items}}@code{org-gtd-review-completed-items}


@strong{Arguments}: Optional DAYS-BACK (default 7)

@strong{When to use}: Weekly review to see what you accomplished

@strong{What it does}:
@itemize
@item
Shows items completed in the last N days
@item
Good for weekly review reflection
@end itemize

@strong{Example}:
@example
M-x org-gtd-review-completed-items
Shows: Items completed in last 7 days

C-u 30 M-x org-gtd-review-completed-items
Shows: Items completed in last 30 days
@end example

@item
@anchor{@code{org-gtd-review-completed-projects}}@code{org-gtd-review-completed-projects}


@strong{When to use}: Weekly/monthly review to see finished projects

@strong{What it does}:
@itemize
@item
Shows all projects where all tasks are DONE
@item
Ready to archive
@end itemize

@item
@anchor{@code{org-gtd-review-missed-items}}@code{org-gtd-review-missed-items}


@strong{When to use}: When you suspect items have fallen through the cracks

@strong{What it does}:
@itemize
@item
Finds items that should have been processed but weren't
@item
Looks for various data inconsistencies
@end itemize
@end itemize

@node Stuck Item Review Commands
@subsection Stuck Item Review Commands

Each of these commands finds items with problems in a specific category:

@itemize
@item
@anchor{@code{org-gtd-review-stuck-calendar-items}}@code{org-gtd-review-stuck-calendar-items}


Finds calendar items with invalid or missing timestamps.

@item
@anchor{@code{org-gtd-review-stuck-incubated-items}}@code{org-gtd-review-stuck-incubated-items}


Finds incubated items with invalid or missing review dates.

@item
@anchor{@code{org-gtd-review-stuck-habit-items}}@code{org-gtd-review-stuck-habit-items}


Finds habit items with incorrect configuration.

@item
@anchor{@code{org-gtd-review-stuck-delegated-items}}@code{org-gtd-review-stuck-delegated-items}


Finds delegated items with missing delegate or date information.

@item
@anchor{@code{org-gtd-review-stuck-single-action-items}}@code{org-gtd-review-stuck-single-action-items}


Finds single actions that aren't marked as NEXT@.
@end itemize

@node Review Commands (Missed Engagements)
@subsection Review Commands (Missed Engagements)

@itemize
@item
@anchor{What Are Missed Engagements?}What Are Missed Engagements?


Life doesn't go as planned. You miss appointments, delegated items slip through cracks, projects run late. These aren't failures—they're normal. What matters is catching them and deciding what to do next.

The missed engagements review helps you find three types of items that need attention:
@itemize
@item
@strong{Appointments you missed}: Calendar items with dates in the past
@item
@strong{Check-ins you forgot}: Delegated items where follow-up dates passed
@item
@strong{Projects running late}: Projects with overdue deadlines or start dates
@end itemize

This is your safety net. Run it daily or weekly to ensure nothing falls through the cracks.

@item
@anchor{Your First Review in 30 Seconds}Your First Review in 30 Seconds


Try this right now:

@enumerate
@item
Run @code{M-x org-gtd-review-missed-engagements}
@item
Look at what appears in the agenda view
@item
Press @code{TAB} on any item to see its details
@end enumerate

That's it. You're now reviewing missed engagements.

If you see items, ask yourself: "What should I do about this now?" Then organize accordingly (reschedule, cancel, or act).

@item
@anchor{Understanding the Review Workflow}Understanding the Review Workflow


Think of GTD like a promise system. When you:
@itemize
@item
Schedule an appointment → you promise to be there at that time
@item
Delegate a task → you promise to check in on the date you set
@item
Set a project deadline → you promise to complete by that date
@end itemize

When dates pass without action, you've broken a promise (to yourself or others).

The review workflow helps you:
@enumerate
@item
@strong{Find} broken promises (missed engagements)
@item
@strong{Decide} what to do about them
@item
@strong{Act} on your decision
@end enumerate

This isn't about guilt—it's about staying in control.

@item
@anchor{Tutorial Daily Review Workflow}Tutorial: Daily Review Workflow


Here's how to use this in your daily routine:

@strong{Morning Review} (2 minutes):
@example
M-x org-gtd-review-missed-engagements

Look at each item:
- Missed appointment? Reschedule or apologize
- Forgot to check in on delegation? Do it now
- Project running late? Decide: extend deadline or cancel
@end example

@strong{Focusing on One Type}:

If you just want to see missed appointments:
@example
M-x org-gtd-review-missed-calendar
@end example

Or just delegated items needing check-ins:
@example
M-x org-gtd-review-missed-delegated
@end example

Or just late projects:
@example
M-x org-gtd-review-missed-projects
@end example

Each command shows only that type, making it easier to focus.

@item
@anchor{Common Patterns}Common Patterns


@strong{Pattern 1: Morning Triage}
Start each day by reviewing missed engagements. Handle or reschedule everything before starting new work.

@strong{Pattern 2: Weekly Cleanup}
During weekly review, run the full missed engagements view. This catches anything that slipped through daily reviews.

@strong{Pattern 3: Context-Specific Review}
Use custom views to see missed items by area of focus (see configuration below).

@item
@anchor{Command Reference}Command Reference


@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Command
@tab Shows
@tab Use When
@item @code{org-gtd-review-missed-engagements}
@tab All missed items
@tab Daily/weekly review
@item @code{org-gtd-review-missed-calendar}
@tab Missed appointments only
@tab Checking calendar
@item @code{org-gtd-review-missed-delegated}
@tab Delegations needing check-in
@tab Following up on delegated work
@item @code{org-gtd-review-missed-projects}
@tab Late projects only
@tab Project review
@item @code{org-gtd-review-missed-with-custom}
@tab All missed + custom views
@tab Using custom filters
@end multitable

@item
@anchor{Backward Compatibility Note}Backward Compatibility Note


The old command names still work:
@itemize
@item
@code{org-gtd-oops} → @code{org-gtd-review-missed-engagements}
@item
@code{org-gtd-oops-calendar} → @code{org-gtd-review-missed-calendar}
@item
@code{org-gtd-oops-delegated} → @code{org-gtd-review-missed-delegated}
@item
@code{org-gtd-oops-projects} → @code{org-gtd-review-missed-projects}
@item
@code{org-gtd-oops-with-custom} → @code{org-gtd-review-missed-with-custom}
@end itemize

Update to the new names when convenient. The old names will be removed in a future version.
@end itemize

@node Review Commands (Upcoming Delegated)
@subsection Review Commands (Upcoming Delegated)

@itemize
@item
@anchor{What Are Upcoming Delegated Check-ins?}What Are Upcoming Delegated Check-ins?


You delegate work and set check-in dates. Some people finish early. Others appreciate regular check-ins. Waiting until check-in dates pass means lost opportunities.

The upcoming delegated review shows all active delegated items with future check-in dates. This helps you:
@itemize
@item
@strong{Catch early completions}: Someone finished early, you can adjust the plan now
@item
@strong{Plan your follow-ups}: See what check-ins are coming this week or month
@item
@strong{Proactive management}: Reach out before problems develop
@end itemize

This is your planning tool. Use it weekly to prepare your delegation check-ins, or ad-hoc when people report early progress.

@item
@anchor{Your First Review in 30 Seconds (1)}Your First Review in 30 Seconds


Try this right now:

@enumerate
@item
Run @code{M-x org-gtd-review-upcoming-delegated}
@item
Look at the delegated items with future check-in dates
@item
Press @code{TAB} on any item to see when the check-in is scheduled
@end enumerate

That's it. You're now seeing upcoming delegation check-ins.

If someone tells you they finished early, you'll find that item here and can update your plans accordingly.

@item
@anchor{Understanding Proactive Delegation Management}Understanding Proactive Delegation Management


Think about delegation timing:

@strong{Reactive management} (missed engagements):
@itemize
@item
Check-in date passes → you remember to follow up
@item
Problem discovered after it's late
@item
Always catching up
@end itemize

@strong{Proactive management} (upcoming review):
@itemize
@item
See check-ins coming this week → prepare questions
@item
Someone finishes early → immediately unblock dependent work
@item
Stay ahead of problems
@end itemize

The upcoming delegated review shifts you from reactive to proactive.

@item
@anchor{Tutorial Weekly Planning Workflow}Tutorial: Weekly Planning Workflow


Here's how to use this in your weekly planning:

@strong{Sunday Planning} (5 minutes):
@example
M-x org-gtd-review-upcoming-delegated

For each item:
- Check-in this week? Prepare questions or schedule call
- Might finish early? Be ready to adjust plans
- Blocked on something? Follow up proactively
@end example

@strong{When Someone Reports Early Completion}:
@example
M-x org-gtd-review-upcoming-delegated

Find their item in the list
Press TAB to jump to the item
Mark it DONE (it disappears from the upcoming view)
Check if this unblocks other work in the project
@end example

@strong{Combined with Missed Review}:
@example
# Morning routine
M-x org-gtd-review-missed-delegated    # Catch up on late check-ins
M-x org-gtd-review-upcoming-delegated  # Plan upcoming check-ins
@end example

The first shows what you missed. The second shows what's coming. Together they give complete delegation visibility.

@item
@anchor{Common Patterns (1)}Common Patterns


@strong{Pattern 1: Weekly Planning}
Every Sunday or Monday, review upcoming delegated items for the week. Know what check-ins are coming so you're prepared.

@strong{Pattern 2: Early Completion Response}
When someone says "I finished that task you gave me," pull up this view to find it quickly and update your plans.

@strong{Pattern 3: Project Acceleration}
Review a specific project's delegated items. If anyone finished early, immediately reassign work to take advantage of the extra time.

@strong{Pattern 4: Delegation Optimization}
Notice patterns: Who consistently finishes early? Give them more work. Who's always late? More frequent check-ins.

@item
@anchor{Understanding What You See}Understanding What You See


The view shows all active (not done) delegated items with future check-in dates:
@itemize
@item
Items with TODO, NEXT, or WAIT states
@item
Items with check-ins far in the future (months away)
@item
Items from all areas of focus
@end itemize

Once you mark an item DONE or CNCL, it disappears from this view automatically—you've already processed it and taken action.

If you see too many items and want to filter:
@itemize
@item
Focus on one project at a time (use project-specific review)
@item
Look at specific timeframes (future enhancement—not yet implemented)
@item
Use custom views with area-of-focus filters
@end itemize

@item
@anchor{Comparison Missed vs Upcoming}Comparison: Missed vs Upcoming


@multitable {aaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaa}
@headitem Review Type
@tab Shows
@tab Mindset
@tab Use When
@item Missed Delegated
@tab Past check-ins
@tab Reactive - catching up
@tab Daily triage
@item Upcoming Delegated
@tab Future check-ins
@tab Proactive - planning
@tab Weekly planning
@end multitable

Both are valuable. Missed helps you catch problems. Upcoming helps you prevent them.

@item
@anchor{Command Reference (1)}Command Reference


@multitable {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa} {aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
@headitem Command
@tab Shows
@tab Use When
@item @code{org-gtd-review-upcoming-delegated}
@tab All delegated items with future check-in dates
@tab Weekly planning, early completion responses
@end multitable
@end itemize

@node Custom View Commands
@subsection Custom View Commands

@itemize
@item
@anchor{@code{org-gtd-view-show}}@code{org-gtd-view-show}


@strong{@strong{What it is:}} Create custom GTD agenda views using a declarative language instead of learning org-ql or org-agenda internals.

@strong{@strong{Why you'd use it:}} The built-in views (engage, review-stuck-projects, etc.) cover common needs, but you have unique workflows. Maybe you only want to see work-related NEXT actions, or projects in a specific area, or items tagged "urgent". This lets you create exactly the view you need.

@strong{@strong{Who needs it:}} Users who want views tailored to their specific workflow beyond the built-in commands.

@strong{@strong{Your first custom view (5 minutes):}}

Let's create a view showing only your NEXT actions (no calendar, no agenda).

@enumerate
@item
Add this to your config file:
@lisp
(defun my-next-actions ()
  "Show all NEXT actions in a simple list."
  (interactive)
  (org-gtd-view-show
   '((name . "All NEXT Actions")
     (filters . ((todo . ("NEXT")))))))
@end lisp

@item
Save and reload your config (@code{M-x eval-buffer} or restart Emacs)

@item
Run it:
@example
M-x my-next-actions
@end example
@end enumerate

You'll see all your NEXT actions in one list. That's it—you've created a custom view!

@strong{@strong{Understanding how views work:}}

Think of views like filtered searches. You tell org-gtd what to show using @code{filters}, and it finds matching items.

The built-in @code{org-gtd-engage} command? It uses @code{org-gtd-view-show} internally. @code{org-gtd-review-stuck-projects}? Same thing. You're now using the same tool the package uses to create its own views.

Each view has two parts:
@table @asis
@item @code{name}
What to call the view (shows in agenda header)
@item @code{filters}
What to show (category, TODO state, tags, dates, etc.)
@end table

Filters are pairs like @code{(filter-type . value)}. Multiple filters combine with AND logic—all must match.

@strong{@strong{Tutorial: Common custom views}}

@strong{Show only work-related NEXT actions:}

@lisp
(defun my-work-next-actions ()
  "Show NEXT actions for work projects only."
  (interactive)
  (org-gtd-view-show
   '((name . "Work NEXT Actions")
     (filters . ((todo . ("NEXT"))
                 (area-of-focus . "Work"))))))
@end lisp

Two filters: must be NEXT AND must be in Work area.

@strong{Show projects that are stuck:}

@lisp
(defun my-stuck-projects ()
  "Show projects with no NEXT actions."
  (interactive)
  (org-gtd-view-show
   '((name . "Stuck Projects")
     (filters . ((category . stuck-projects))))))
@end lisp

One filter: category must be stuck-projects (built-in category that checks for stuck state).

@strong{Show items with past deadlines:}

@lisp
(defun my-overdue-items ()
  "Show all items with deadlines in the past."
  (interactive)
  (org-gtd-view-show
   '((name . "Overdue Items")
     (filters . ((deadline . past))))))
@end lisp

One filter: deadline must be in the past. (Automatically excludes DONE items.)

@strong{Show multiple related views together:}

@lisp
(defun my-morning-review ()
  "Show morning planning views: NEXT actions and calendar."
  (interactive)
  (org-gtd-view-show
   '(((name . "Today's NEXT Actions")
      (filters . ((todo . ("NEXT")))))
     ((name . "Upcoming Calendar Items")
      (filters . ((category . calendar)
                  (timestamp . future)))))))
@end lisp

This shows TWO views in one agenda: NEXT actions first, then upcoming calendar items.

@strong{@strong{Common patterns:}}

@strong{Filter by area of focus:}
@lisp
(filters . ((area-of-focus . "Work")))
@end lisp

@strong{Filter by category (item type):}
@lisp
(filters . ((category . projects)))      ; All projects
(filters . ((category . actions)))       ; Single actions
(filters . ((category . delegated)))     ; Delegated items
(filters . ((category . calendar)))      ; Calendar items
(filters . ((category . stuck-projects))) ; Stuck projects only
@end lisp

@strong{Filter by TODO state:}
@lisp
(filters . ((todo . ("NEXT"))))          ; Just NEXT
(filters . ((todo . ("TODO" "NEXT"))))   ; TODO or NEXT
@end lisp

@strong{Filter by time:}
@lisp
(filters . ((deadline . past)))          ; Overdue deadlines
(filters . ((timestamp . past)))         ; Past timestamps
(filters . ((timestamp . future)))       ; Future timestamps
(filters . ((scheduled . today)))        ; Scheduled for today
@end lisp

@strong{Combine multiple filters (AND logic):}
@lisp
(filters . ((category . projects)
            (area-of-focus . "Work")
            (deadline . past)))
; Shows: Projects AND Work area AND overdue
@end lisp

@strong{@strong{When to create custom views:}}

Create a custom view when you find yourself:
@itemize
@item
Repeatedly filtering the engage view manually
@item
Wanting to see specific combinations org-gtd doesn't provide
@item
Needing views for specific contexts (home office, traveling, morning routine)
@item
Organizing weekly reviews around specific categories
@end itemize

Don't create views for one-time queries—just use the built-in views and navigate. Create views for repeated patterns in your workflow.

@strong{@strong{Binding to keys:}}

Once you've created a view you use often, bind it to a key:

@lisp
;; Vanilla Emacs
(global-set-key (kbd "C-c d w") 'my-work-next-actions)

;; Doom Emacs (in config.el)
(map! :leader
      (:prefix "d"
       :desc "Work NEXT actions" "w" #'my-work-next-actions))

;; Spacemacs (in user-config)
(spacemacs/set-leader-keys "od w" 'my-work-next-actions)
@end lisp

@strong{@strong{Complete filter reference:}}

For the full list of available filters and their syntax, see @ref{View DSL Filter Reference, , View DSL Reference}.

Common filters include:
@table @asis
@item @code{category}
projects, actions, delegated, calendar, stuck-projects, etc.
@item @code{todo}
List of TODO keywords to match
@item @code{area-of-focus}
Specific area/category
@item @code{deadline}, @code{scheduled}, @code{timestamp}
Time-based filters (past, future, today)
@item @code{tags}
Match specific tags
@item @code{level}
Heading level (2 for projects, 3+ for tasks)
@end table

@strong{@strong{Command reference:}}

@strong{Function signature:}
@lisp
(org-gtd-view-show VIEW-SPEC-OR-SPECS)
@end lisp

@strong{Arguments:}
@table @asis
@item @code{VIEW-SPEC-OR-SPECS}
Either a single view specification (alist) or list of view specifications
@end table

@strong{View specification structure:}
@lisp
'((name . "View Name")
  (filters . ((filter-type . value)
              (filter-type . value)
              ...)))
@end lisp

@strong{Multiple views:}
@lisp
'(((name . "View 1")
   (filters . (...)))
  ((name . "View 2")
   (filters . (...))))
@end lisp

@strong{Returns:} Opens org-agenda buffer with the specified view

@strong{Example:}
@lisp
;; Single view
(org-gtd-view-show
 '((name . "Active Projects")
   (filters . ((category . projects)))))

;; Multiple views
(org-gtd-view-show
 '(((name . "NEXT Actions")
    (filters . ((todo . ("NEXT")))))
   ((name . "Stuck Projects")
    (filters . ((category . stuck-projects))))))
@end lisp
@end itemize

@node Clarification Commands
@subsection Clarification Commands

@itemize
@item
@anchor{@code{org-gtd-clarify-item}}@code{org-gtd-clarify-item}


@strong{Arguments}: Optional MARKER and WINDOW-CONFIG

@strong{When to use}: To clarify a single org heading without processing the entire inbox

@strong{What it does}:
@itemize
@item
Opens item in clarify buffer (WIP mode)
@item
You can edit and organize it
@item
Returns to previous location when done
@end itemize

@strong{Example}: Clarifying an item in your tasks file that needs re-organization.

@item
@anchor{@code{org-gtd-clarify-agenda-item}}@code{org-gtd-clarify-agenda-item}


@strong{When to use}: When viewing agenda and want to re-clarify an item

@strong{What it does}:
@itemize
@item
Opens agenda item in clarify buffer
@item
Same as @code{org-gtd-clarify-item} but works from agenda view
@end itemize

@item
@anchor{@code{org-gtd-clarify-toggle-horizons-window}}@code{org-gtd-clarify-toggle-horizons-window}


@strong{When to use}: During clarification, to show/hide your horizons file

@strong{What it does}:
@itemize
@item
Toggles display of horizons file in side window
@item
Position determined by @code{org-gtd-clarify-show-horizons} (or right side if variable is nil)
@end itemize

@item
@anchor{@code{org-gtd-clarify-project-insert-template}}@code{org-gtd-clarify-project-insert-template}


@strong{When to use}: During project clarification, to insert a predefined template

@strong{What it does}:
@itemize
@item
Prompts for template from @code{org-gtd-clarify-project-templates}
@item
Inserts template tasks into current project
@end itemize

@item
@anchor{Updating Items Without Refiling}Updating Items Without Refiling


@strong{@strong{What this is:}} A way to reconfigure existing GTD items (change their category, properties, or details) without moving them to a different location in your files.

@strong{@strong{Who needs it:}} Anyone who wants to change how an item is organized while keeping it where it is - perfect for items already in projects, or when you like your current file organization.

@strong{@strong{Your first use (30 seconds):}}

You're looking at your agenda and see a single action that should actually be delegated. But it's already in a specific project file and you want it to stay there:

@enumerate
@item
In agenda view, put point on the item
@item
Type: @code{C-u M-x org-gtd-clarify-agenda-item}
@item
Make your changes in the clarify buffer
@item
Type: @code{M-x org-gtd-organize}
@item
Type: @code{-n} to toggle "Update in place (no refile)"
@item
Choose: @code{d} for Delegate
@item
Fill in delegation details
@item
Done - item is updated but stays in its current location
@end enumerate

@strong{@strong{How it works:}}

Normally when you organize an item, org-gtd moves (refiles) it to the appropriate GTD category location. But sometimes you want to change the configuration without moving the item.

There are two ways to trigger this:

@strong{Via prefix argument:}
@itemize
@item
@code{C-u M-x org-gtd-clarify-item} - Clarify item at point without refiling
@item
@code{C-u M-x org-gtd-clarify-agenda-item} - Clarify agenda item without refiling
@end itemize

@strong{Via transient toggle:}
@itemize
@item
During organization, press @code{-n} in the @code{org-gtd-organize} menu to toggle "Update in place (no refile)"
@item
The toggle is only available when NOT processing the inbox (inbox items must be refiled)
@end itemize

When the skip-refile flag is set, organizing the item will:
@itemize
@item
Apply all the same configuration (properties, tags, hooks)
@item
Update the item in its current location
@item
NOT move it to a different file or heading
@end itemize

@strong{@strong{Common scenarios:}}

@strong{Reconfiguring project tasks:}
@itemize
@item
Task is already in the right project file
@item
You want to change it from single action to delegated
@item
Use skip-refile to update without moving
@end itemize

@strong{Adjusting agenda items:}
@itemize
@item
Item appears in your daily agenda
@item
You realize it needs different properties (change deadline, add delegation, etc.)
@item
Use skip-refile to update configuration in place
@end itemize

@strong{Organizing items in custom locations:}
@itemize
@item
You've organized items in a specific way outside @code{org-gtd-directory}
@item
You want to apply GTD categories but preserve your file structure
@item
Use skip-refile to maintain your organization
@end itemize

@strong{@strong{What stays the same vs what changes:}}

@strong{Changes applied:}
@itemize
@item
GTD category (ORG@math{_GTD} property)
@item
TODO keyword state
@item
Properties (delegation info, dates, etc.)
@item
Tags
@item
All organize hooks
@end itemize

@strong{Preserved:}
@itemize
@item
File location
@item
Position within file
@item
Parent heading (for tasks in projects)
@item
Sibling relationships
@end itemize

@strong{@strong{Technical details:}}

When you set the skip-refile flag (via @code{C-u} prefix or @code{-n} toggle):
@itemize
@item
The flag is stored in the clarify buffer as @code{org-gtd-clarify--skip-refile}
@item
Category finalize functions check this flag
@item
If set, they call @code{org-gtd-organize--update-in-place} instead of refiling
@item
The original heading is replaced with the configured content from the WIP buffer
@item
Archive categories (quick-action, knowledge, trash) always archive regardless of this flag
@end itemize

@strong{@strong{Migration note:}}

In previous versions, there was a special command @code{org-gtd-delegate-item-at-point} for delegating items without moving them. This command has been removed in favor of the more general skip-refile mechanism:

@strong{OLD way (no longer available):}
@lisp
M-x org-gtd-delegate-item-at-point
@end lisp

@strong{NEW way (version 4.0+):}
@lisp
;; From agenda or file:
C-u M-x org-gtd-clarify-item
;; or
C-u M-x org-gtd-clarify-agenda-item
;; Then organize and press -n toggle
M-x org-gtd-organize
;; Press -n to enable skip-refile
;; Choose delegation
@end lisp

The new approach is more flexible - it works for ANY GTD category, not just delegation.
@end itemize

@node Archive Commands
@subsection Archive Commands

@itemize
@item
@anchor{@code{org-gtd-archive-completed-items}}@code{org-gtd-archive-completed-items}


@strong{When to use}: Weekly or monthly cleanup

@strong{What it does}:
@itemize
@item
Finds all DONE/CNCL items in GTD files
@item
Archives them to location specified by @code{org-gtd-archive-location}
@item
Keeps your active files clean
@end itemize

@strong{Example}:
@example
M-x org-gtd-archive-completed-items
Archives: All completed items
Result: Clean active files, archived items in archive file(s)
@end example
@end itemize

@node Agenda-Specific Commands
@subsection Agenda-Specific Commands

These commands only work when point is on an agenda item:

@itemize
@item
@anchor{@code{org-gtd-delegate-agenda-item}}@code{org-gtd-delegate-agenda-item}


@strong{When to use}: In agenda view, to delegate an existing action to someone else

@strong{What it does}:
@itemize
@item
Prompts for person to delegate to
@item
Prompts for follow-up date
@item
Updates item properties
@item
Refiles to delegated items location
@end itemize

@item
@anchor{@code{org-gtd-project-cancel-from-agenda}}@code{org-gtd-project-cancel-from-agenda}


@strong{When to use}: In agenda view, when you want to cancel an entire project

@strong{What it does}:
@itemize
@item
Finds the project containing the agenda item
@item
Marks all remaining tasks as CNCL
@item
Updates project status
@end itemize
@end itemize

@node Project Management Commands
@subsection Project Management Commands

@itemize
@item
@anchor{@code{org-gtd-projects-fix-todo-keywords-for-project-at-point}}@code{org-gtd-projects-fix-todo-keywords-for-project-at-point}


@strong{When to use}: When project TODO states seem incorrect after dependency changes

@strong{What it does}:
@itemize
@item
Recalculates which tasks should be NEXT based on dependency graph
@item
Updates all task keywords in the project
@item
Fixes stuck projects
@end itemize

@strong{Required}: Point must be on project heading

@strong{Note}: This is automatically called after graph UI operations and text-based task management commands. You typically only need this for troubleshooting edge cases.

@item
@anchor{@code{org-gtd-projects-fix-all-todo-keywords}}@code{org-gtd-projects-fix-all-todo-keywords}


@strong{@strong{What it is:}} Recalculates and fixes TODO/NEXT states for ALL projects in your GTD system at once.

@strong{@strong{Why you'd use it:}} After making changes in external tools (mobile apps, web interfaces, other editors) that don't know about org-gtd's dependency logic, your task states might be inconsistent. This command makes everything sane again.

@strong{@strong{Who needs it:}} Anyone who edits their GTD files outside of org-gtd (mobile apps, sync conflicts, manual edits).

@strong{@strong{Your first use (30 seconds):}}

@enumerate
@item
Edit tasks on your phone/tablet/other tool
@item
Sync back to Emacs
@item
Run: @code{M-x org-gtd-projects-fix-all-todo-keywords}
@item
Done - all task states are now correct
@end enumerate

That's it. No need to manually check each project.

@strong{@strong{Common scenarios:}}

@itemize
@item
Completed tasks on mobile → states might be wrong → run this
@item
Changed task descriptions/notes externally → run this to be safe
@item
Sync conflict resolution → run this after fixing conflicts
@item
Bulk manual edits outside org-gtd → run this
@item
After migration or data import → run this
@end itemize

@strong{@strong{When to use this vs the single-project version:}}

Use @code{org-gtd-projects-fix-all-todo-keywords} when:
@itemize
@item
You've worked in external tools (mobile, web, other editors)
@item
You've edited multiple projects
@item
You don't know which projects are affected
@item
You want to fix everything at once (safest option)
@end itemize

Use @code{org-gtd-projects-fix-todo-keywords-for-project-at-point} when:
@itemize
@item
You know which specific project has issues
@item
You've just edited one project in Emacs
@item
You want to fix just one project quickly
@end itemize

@strong{@strong{What it does (technical):}}

@enumerate
@item
Scans all projects in agenda files
@item
Resets active task states (TODO/NEXT → TODO)
@item
Calculates which tasks are ready based on dependencies
@item
Marks ready tasks as NEXT
@item
Preserves user-set states (WAIT, DONE, CNCL)
@item
Handles multi-project tasks correctly (AND semantics)
@end enumerate

@strong{@strong{Multi-project tasks:}}

Some tasks can belong to multiple projects. This command handles them safely:
@itemize
@item
Shared task becomes NEXT only if ready in ALL its projects
@item
If ready in just some projects, stays TODO
@item
WAIT states are never auto-changed
@end itemize

@strong{@strong{When NOT to use:}}

@itemize
@item
If you only work in Emacs with org-gtd commands (automatic state management works)
@item
If your projects look correct already
@item
Before making external changes (use after, not before)
@end itemize

@item
@anchor{@code{org-gtd-project-update-all-cookies}}@code{org-gtd-project-update-all-cookies}


@strong{@strong{What it is:}} Refreshes progress cookies on ALL project headings at once.

@strong{@strong{Why you'd use it:}} Progress cookies show @code{[3/7][42%]} on project headings. While these update automatically when you change task states, sometimes you want to refresh everything—for example, after bulk changes or data migration.

@strong{@strong{Your first use (30 seconds):}}

@enumerate
@item
Run: @code{M-x org-gtd-project-update-all-cookies}
@item
Done - all project headings now show accurate progress
@end enumerate

@strong{@strong{What it does:}}

@itemize
@item
Scans all projects in agenda files
@item
Counts completed vs total tasks for each project
@item
Updates the @code{[completed/total][percent%]} display on each project heading
@end itemize

@strong{@strong{When to use:}}

@itemize
@item
After bulk task changes outside of org-gtd
@item
After data migration or import
@item
During weekly review for visual refresh
@item
If progress cookies look outdated
@end itemize

@strong{@strong{Configuration:}}

Progress cookies are controlled by @code{org-gtd-project-progress-cookie-position}:
@itemize
@item
@code{'end} (default) - cookies appear at end of heading before tags
@item
@code{'start} - cookies appear after TODO keyword
@item
@code{nil} - cookies disabled entirely
@end itemize

@strong{See also}: @ref{Project Progress Cookies See Your Progress at a Glance, , Project Progress Cookies} for detailed usage guide.

@item
@anchor{@code{org-gtd-incubate}}@code{org-gtd-incubate}


@strong{@strong{What it is:}} Smart command to pause items you're not ready to work on yet.

@strong{@strong{Why you'd use it:}} You have a project or action that's a good idea, but not right now. You want to set it aside with a reminder to review it later, without losing your planning work.

@strong{@strong{Who needs it:}} Anyone managing "someday/maybe" items or projects they want to defer.

@strong{@strong{Your first use (30 seconds):}}

@enumerate
@item
Navigate to a project or action
@item
Run: @code{M-x org-gtd-incubate}
@item
Enter review date: @code{2025-12-01}
@item
Done - it disappears from your engage view until that date
@end enumerate

@strong{@strong{What it does:}}

Detects what you're on:
@itemize
@item
Project heading → incubates entire project with all tasks
@item
Project task → incubates the project it belongs to
@item
Single action → incubates just that action
@end itemize

For projects:
@itemize
@item
Preserves all task states and dependencies
@item
Hides everything from engage/NEXT views
@item
Adds review date to your agenda
@item
Skips multi-project tasks (tasks shared between projects)
@end itemize

@strong{@strong{When to use:}}

@itemize
@item
Projects you want to pursue "someday" but not now
@item
Ideas that need to marinate before you're ready
@item
Seasonal projects (start each year)
@item
Projects blocked by external factors beyond your control
@end itemize

@item
@anchor{@code{org-gtd-reactivate}}@code{org-gtd-reactivate}


@strong{@strong{What it is:}} Bring back incubated projects and actions.

@strong{@strong{Why you'd use it:}} The review date arrived, you're ready to work on it again.

@strong{@strong{Your first use (30 seconds):}}

@enumerate
@item
When you see an incubated item in agenda (on its review date)
@item
Run: @code{M-x org-gtd-reactivate}
@item
Graph view opens - review the project structure
@item
Adjust if needed and close
@end enumerate

@strong{@strong{What it does:}}

@itemize
@item
Restores original item states (project → Projects, actions → Actions, etc.)
@item
Restores task TODO keywords
@item
Recalculates NEXT tasks based on current dependencies
@item
Opens project graph view (for projects) so you can review and adjust
@item
Removes the review date
@end itemize

@strong{@strong{When to use:}}

@itemize
@item
When an incubated item appears in your agenda on its review date
@item
When you're ready to reactivate something earlier than scheduled
@item
During weekly review when scanning incubated items
@end itemize
@end itemize

@node Task Dependency Commands
@subsection Task Dependency Commands

These text-based commands manage task relationships without using the graph view. Most users will find the graph view more intuitive (press @code{M-x org-gtd-show-project-graph}), but these commands are useful for:

@itemize
@item
Working in the org file directly
@item
Scripting/automation
@item
Preference for text-based workflows
@end itemize

@strong{Graph UI equivalents}:
@itemize
@item
Adding dependencies: @code{a} (add dependency), @code{a b} (add blocker), @code{a c} (add child)
@item
Removing dependencies: @code{d} (remove dependency), @code{x} (clear all)
@item
Viewing relationships: @code{i} (show relationships)
@end itemize

See @ref{Graph View Command Reference} for the visual approach.

@itemize
@item
@anchor{@code{org-gtd-task-add-blockers}}@code{org-gtd-task-add-blockers}


@strong{When to use}: To specify that the current task depends on other task(s) completing first

@strong{What it does}:
@itemize
@item
Prompts to select tasks that block the current task
@item
Creates bidirectional relationships.
@itemize
@item
Adds selected task IDs to current task's ORG@math{_GTD}@math{_DEPENDS}@math{_ON}
@item
Adds current task ID to selected tasks' ORG@math{_GTD}@math{_BLOCKS}
@end itemize
@item
Can select multiple blockers
@end itemize

@strong{Example}:
@example
On task: "Get diagnosis"
M-x org-gtd-task-add-blockers
Select: "Make MRI appointment" and "Make orthopedist appointment"
Result: Both appointments must complete before diagnosis can start
@end example

@item
@anchor{@code{org-gtd-task-remove-blockers}}@code{org-gtd-task-remove-blockers}


@strong{When to use}: To remove blocking relationships from current task

@strong{What it does}:
@itemize
@item
Shows current blockers
@item
Prompts to select which to remove
@item
Removes bidirectional relationships
@end itemize

@item
@anchor{@code{org-gtd-task-add-dependent}}@code{org-gtd-task-add-dependent}


@strong{When to use}: To specify that another task depends on the current task completing

@strong{What it does}:
@itemize
@item
Prompts to select a task that depends on current task
@item
Creates bidirectional relationship.
@itemize
@item
Adds selected task ID to current task's ORG@math{_GTD}@math{_BLOCKS}
@item
Adds current task ID to selected task's ORG@math{_GTD}@math{_DEPENDS}@math{_ON}
@end itemize
@end itemize

@strong{Example}:
@example
On task: "Get project approval"
M-x org-gtd-task-add-dependent
Select: "Start implementation"
Result: Implementation can't start until approval is done
@end example

@item
@anchor{@code{org-gtd-task-add-dependents}}@code{org-gtd-task-add-dependents}


@strong{When to use}: To specify multiple tasks that depend on the current task

@strong{What it does}:
@itemize
@item
Same as @code{org-gtd-task-add-dependent} but allows multiple selections
@end itemize

@item
@anchor{@code{org-gtd-task-clear-relationships}}@code{org-gtd-task-clear-relationships}


@strong{When to use}: To remove ALL dependency relationships from current task

@strong{What it does}:
@itemize
@item
Removes all ORG@math{_GTD}@math{_BLOCKS} and ORG@math{_GTD}@math{_DEPENDS}@math{_ON} properties
@item
Updates related tasks to remove references to this task
@item
Use with caution!
@end itemize

@item
@anchor{@code{org-gtd-task-show-relationships}}@code{org-gtd-task-show-relationships}


@strong{When to use}: To see what tasks are related to the current task

@strong{What it does}:
@itemize
@item
Displays in minibuffer.
@itemize
@item
Tasks this task depends on (blockers)
@item
Tasks that depend on this task (dependents)
@end itemize
@item
Useful for understanding dependency graph
@end itemize

@item
@anchor{@code{org-gtd-validate-project-dependencies}}@code{org-gtd-validate-project-dependencies}


@strong{When to use}: To check for dependency problems in a project

@strong{What it does}:
@itemize
@item
Detects broken dependency references (task IDs that don't exist)
@item
Finds orphaned tasks (not reachable from FIRST@math{_TASKS})
@item
Identifies circular dependencies
@item
Provides guidance on fixes
@end itemize

@strong{Required}: Point must be on project heading

@item
@anchor{@code{org-gtd-remove-task-from-project}}@code{org-gtd-remove-task-from-project}


@strong{When to use}: To remove a task from a project structure

@strong{What it does}:
@itemize
@item
Removes the project ID from task's ORG@math{_GTD}@math{_PROJECT}@math{_IDS} property
@item
Doesn't delete the task, just removes project association
@item
Useful when reorganizing project structures
@end itemize
@end itemize

@node Area of Focus Commands
@subsection Area of Focus Commands

@itemize
@item
@anchor{@code{org-gtd-area-of-focus-set-on-item-at-point}}@code{org-gtd-area-of-focus-set-on-item-at-point}


@strong{When to use}: To add area of focus to an existing item (not during organize)

@strong{What it does}:
@itemize
@item
Prompts for area from @code{org-gtd-areas-of-focus}
@item
Sets CATEGORY property
@item
Use this on any org heading
@end itemize

@strong{Note}: Trusts you to use it correctly (no validation)

@item
@anchor{@code{org-gtd-area-of-focus-set-on-agenda-item}}@code{org-gtd-area-of-focus-set-on-agenda-item}


@strong{When to use}: In agenda view, to set area of focus on an item

@strong{What it does}:
@itemize
@item
Same as @code{org-gtd-area-of-focus-set-on-item-at-point} but from agenda
@item
Smarter: detects if you're on a project task and sets area on the project instead
@end itemize
@end itemize

@node Programmatic Creation Commands
@subsection Programmatic Creation Commands

These commands create GTD items programmatically (useful for automation and Emacs Lisp code):

@itemize
@item
@anchor{@code{org-gtd-habit-create}}@code{org-gtd-habit-create}


@strong{Arguments}: STRING and additional parameters

@strong{Use case}: Creating habits from Emacs Lisp

@strong{Example}:
@lisp
(org-gtd-habit-create "Exercise" "daily" (org-read-date nil nil "+0d"))
@end lisp

@item
@anchor{@code{org-gtd-calendar-create}}@code{org-gtd-calendar-create}


@strong{Arguments}: STRING and DATE-TIME

@strong{Use case}: Creating calendar items from Emacs Lisp

@strong{Example}:
@lisp
(org-gtd-calendar-create "Team meeting" (org-read-date nil nil "+7d 9:00"))
@end lisp

@item
@anchor{@code{org-gtd-delegate-create}}@code{org-gtd-delegate-create}


@strong{Arguments}: STRING, DELEGATED-TO, and REMINDER-DATE

@strong{Use case}: Auto-delegating from email, code review systems, etc.

@strong{Example}:
@lisp
(defun org-gtd-email-reminder ()
  (let ((topic (message-fetch-field "subject"))
        (delegated-to (message-fetch-field "to"))
        (reminder-date (org-read-date nil nil "+3d")))
    (org-gtd-delegate-create (format "Reminder: %s" topic)
                             delegated-to
                             reminder-date)))

(add-hook 'message-send-hook 'org-gtd-email-reminder)
@end lisp

@item
@anchor{@code{org-gtd-incubate-create}}@code{org-gtd-incubate-create}


@strong{Arguments}: STRING and REVIEW-DATE

@strong{Use case}: Programmatically adding someday/maybe items

@strong{Example}:
@lisp
(org-gtd-incubate-create "Learn Rust" (org-read-date nil nil "+6m"))
@end lisp

@item
@anchor{@code{org-gtd-single-action-create}}@code{org-gtd-single-action-create}


@strong{Arguments}: STRING

@strong{Use case}: Programmatically adding actions

@strong{Example}:
@lisp
(org-gtd-single-action-create "Follow up on proposal")
@end lisp
@end itemize

@node Utility Commands
@subsection Utility Commands

@itemize
@item
@anchor{@code{org-gtd-setup-keywords-wizard}}@code{org-gtd-setup-keywords-wizard}


@strong{When to use}: Initial setup or when changing keyword configuration

@strong{What it does}:
@itemize
@item
Interactive wizard to configure GTD keyword mapping
@item
Guides you through setting up @code{org-gtd-keyword-mapping}
@item
Validates configuration
@end itemize

@item
@anchor{@code{org-gtd-inbox-path}}@code{org-gtd-inbox-path}


@strong{Not interactive, but useful in Emacs Lisp}

@strong{Returns}: Full path to inbox.org file

@strong{Use case}: When writing custom capture templates or automation

@strong{Example}:
@lisp
(defun my-custom-capture ()
  (let ((inbox (org-gtd-inbox-path)))
    ;; do something with inbox file
    ))
@end lisp
@end itemize

@node ID Overlay Commands
@subsection ID Overlay Commands

@itemize
@item
@anchor{@code{org-gtd-id-overlay-mode}}@code{org-gtd-id-overlay-mode}


@strong{Type}: Minor mode

@strong{When to use}: When working with project dependencies and wanting readable task references

@strong{What it does}:
@itemize
@item
Replaces task IDs with truncated heading text
@item
Makes dependency properties more readable
@item
Automatically enabled in WIP buffers
@end itemize

@item
@anchor{@code{org-gtd-id-overlay-refresh-buffer}}@code{org-gtd-id-overlay-refresh-buffer}


@strong{When to use}: After modifying headings, to update overlays

@strong{What it does}:
@itemize
@item
Refreshes all ID overlays in current buffer
@item
Usually automatic, but available for manual refresh
@end itemize

@item
@anchor{@code{org-gtd-id-overlay-clear-buffer}}@code{org-gtd-id-overlay-clear-buffer}


@strong{When to use}: To remove all overlays (see raw IDs)

@strong{What it does}:
@itemize
@item
Removes all ID overlays from buffer
@item
Shows actual ID values
@end itemize
@end itemize

@node Migration and Upgrade Commands
@subsection Migration and Upgrade Commands

@itemize
@item
@anchor{@code{org-gtd-upgrade-v3-to-v4}}@code{org-gtd-upgrade-v3-to-v4}


@strong{When to use}: REQUIRED when upgrading from version 3.x to 4.0

@strong{What it does}:
@enumerate
@item
Adds ORG@math{_GTD} properties to identify items
@item
Converts TRIGGER-based projects to dependency-based system
@item
Updates task states based on new dependency graph
@end enumerate

@strong{Important}:
@itemize
@item
Make a backup first!
@item
Required for existing projects to work in v4
@item
Safe to run multiple times
@item
See @ref{Upgrading, , Upgrading section} for complete details
@end itemize
@end itemize

@node Obsolete Commands
@subsection Obsolete Commands

@itemize
@item
@anchor{@code{org-gtd-mode} (obsolete since 40)}@code{org-gtd-mode} (obsolete since 4.0)


@strong{Use instead}:
@lisp
(setq org-agenda-files (list org-gtd-directory))
(org-edna-mode 1)
@end lisp

This minor mode is no longer needed and will be removed in a future version.

@item
@anchor{@code{org-gtd-delegate-item-at-point} (removed in 40)}@code{org-gtd-delegate-item-at-point} (removed in 4.0)


@strong{Use instead}: Skip-refile feature with clarify commands

This command was removed because it only solved one specific case (delegating without moving). The new skip-refile feature is more general and works for any GTD category.

@strong{Migration}:
@lisp
;; OLD (no longer available):
M-x org-gtd-delegate-item-at-point

;; NEW (works from agenda or file):
C-u M-x org-gtd-clarify-agenda-item
;; or
C-u M-x org-gtd-clarify-item
;; Then in organize menu: press -n to toggle skip-refile, choose delegation
@end lisp

See @ref{Options and commands related to clarification, , Clarification Options} for full documentation on the skip-refile feature.
@end itemize

@node Properties Reference (Internal Implementation)
@section Properties Reference (Internal Implementation)

@strong{For most users}: You don't need to read this section! Use the graph view or text-based task management commands instead.

@strong{This section is for}:
@itemize
@item
Understanding org-gtd's internal data model
@item
Writing elisp automation/integration code
@item
Debugging edge cases
@item
Migrating data from other systems
@end itemize

org-gtd uses org-mode properties to track state and relationships. These properties are managed automatically by org-gtd commands - @strong{you should not edit them manually during normal use.}

If you find yourself manually editing properties, that indicates a missing feature - please file an issue!

@menu
* Core GTD Properties::
* Project Properties::
* Task Dependency Properties::
* Calendar and Time Properties::
* Delegation Properties::
* Habit Properties::
* Area of Focus Properties::
* Standard Org Properties Used by org-gtd::
@end menu

@node Core GTD Properties
@subsection Core GTD Properties

@itemize
@item
@anchor{ORG@math{_GTD}}ORG@math{_GTD}


@strong{Used on}: All GTD items (projects, actions, calendar items, incubated items, etc.)

@strong{Purpose}: Identifies the type of GTD item

@strong{Values}:
@table @asis
@item @code{"Projects"}
Project heading
@item @code{"Actions"}
Project tasks and single actions
@item @code{"Calendar"}
Calendar items (appointments, deadlines)
@item @code{"Incubated"}
Someday/maybe items
@item @code{"Delegated"}
Delegated tasks (set in combination with DELEGATED@math{_TO})
@end table

@strong{Example}:
@example
* My Project
:PROPERTIES:
:ORG_GTD: Projects
:END:
** NEXT Task 1
:PROPERTIES:
:ORG_GTD: Actions
:END:
@end example

@strong{Note}: This property is how org-gtd identifies items. Don't modify manually unless you understand the implications.

@item
@anchor{ORG@math{_GTD}@math{_REFILE}}ORG@math{_GTD}@math{_REFILE}


@strong{Used on}: Category headings that serve as refile targets

@strong{Purpose}: Marks a heading as a refile target for org-gtd's optional refile system (see @ref{Refiling to the appropriate area, , Refiling section})

@strong{Values}:
@table @asis
@item @code{"Projects"}
Target for refiling projects
@item @code{"Actions"}
Target for refiling single actions
@item @code{"Calendar"}
Target for refiling calendar items
@item @code{"Incubated"}
Target for refiling incubated items
@item @code{"Habits"}
Target for refiling habits
@end table

@strong{Example}:
@example
* Projects         <-- Can be at any level in any file
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:

* Work/Development Projects   <-- Can have multiple targets per type
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:
@end example

@strong{How it's set}:
@itemize
@item
Automatically created by @code{org-gtd-upgrade-v3-to-v4} (renames ORG@math{_GTD} on level 1 headings)
@item
Manually when creating custom refile targets
@item
Via @code{org-entry-put} in elisp: @code{(org-entry-put nil "ORG_GTD_REFILE" "Projects")}
@end itemize

@strong{Important notes}:
@itemize
@item
Org-gtd merges these targets with your @code{org-refile-targets} configuration
@item
Can exist at ANY level in ANY file in @code{org-agenda-files}
@item
You can have multiple refile targets for the same category type
@item
Your @code{org-refile-targets} appear first, then @code{ORG_GTD_REFILE} targets
@end itemize
@end itemize

@node Project Properties
@subsection Project Properties

@itemize
@item
@anchor{ORG@math{_GTD}@math{_FIRST}@math{_TASKS}}ORG@math{_GTD}@math{_FIRST}@math{_TASKS}


@strong{Used on}: Project headings

@strong{Purpose}: Identifies which tasks can start immediately (have no dependencies)

@strong{Format}: Space-separated list of task IDs

@strong{Example}:
@example
* Software Release
:PROPERTIES:
:ORG_GTD: Projects
:ORG_GTD_FIRST_TASKS: abc123 def456
:END:
@end example

This means tasks with IDs "abc123" and "def456" can both start immediately (parallel execution).

@strong{How it's set}:
@itemize
@item
Automatically when organizing a project
@item
Automatically by graph view @code{a r} (add root task) and @code{a b} (add blocker as root)
@item
Programmatically via @code{org-entry-add-to-multivalued-property}
@end itemize

@strong{For interactive use}: Use graph view commands instead of editing this property directly.
@end itemize

@node Task Dependency Properties
@subsection Task Dependency Properties

@itemize
@item
@anchor{ORG@math{_GTD}@math{_DEPENDS}@math{_ON}}ORG@math{_GTD}@math{_DEPENDS}@math{_ON}


@strong{Used on}: Project tasks

@strong{Purpose}: Lists task IDs that must complete before this task can start

@strong{Format}: Space-separated list of task IDs

@strong{Example}:
@example
** NEXT Get project approval
:PROPERTIES:
:ID: task-001
:ORG_GTD: Actions
:ORG_GTD_BLOCKS: task-002 task-003
:END:
** TODO Design solution
:PROPERTIES:
:ID: task-002
:ORG_GTD: Actions
:ORG_GTD_DEPENDS_ON: task-001
:ORG_GTD_BLOCKS: task-004
:END:
** TODO Setup infrastructure
:PROPERTIES:
:ID: task-003
:ORG_GTD: Actions
:ORG_GTD_DEPENDS_ON: task-001
:ORG_GTD_BLOCKS: task-004
:END:
** TODO Implement feature
:PROPERTIES:
:ID: task-004
:ORG_GTD: Actions
:ORG_GTD_DEPENDS_ON: task-002 task-003
:END:
@end example

In this example:
@itemize
@item
Task 001 (approval) starts first
@item
Tasks 002 (design) and 003 (infrastructure) can run in parallel after approval
@item
Task 004 (implement) waits for both 002 and 003 to complete
@end itemize

@strong{How it's set}:
@itemize
@item
Automatically by graph view @code{a} (add dependency), @code{a c} (add child), @code{a b} (add blocker)
@item
Automatically by text commands @code{org-gtd-task-add-blockers}, @code{org-gtd-task-add-dependent}
@item
Programmatically via @code{org-gtd-dependencies-create} (maintains bidirectional relationships)
@end itemize

@strong{For interactive use}: Use graph view or text-based task commands instead of editing this property directly.

@item
@anchor{ORG@math{_GTD}@math{_BLOCKS}}ORG@math{_GTD}@math{_BLOCKS}


@strong{Used on}: Project tasks

@strong{Purpose}: Lists task IDs that depend on this task completing (inverse of DEPENDS@math{_ON})

@strong{Format}: Space-separated list of task IDs

@strong{Relationship}: If task A has @code{ORG_GTD_BLOCKS: B C}, then:
@itemize
@item
Task B should have @code{ORG_GTD_DEPENDS_ON: A}
@item
Task C should have @code{ORG_GTD_DEPENDS_ON: A}
@end itemize

@strong{How it's set}:
@itemize
@item
Automatically maintained when setting ORG@math{_GTD}@math{_DEPENDS}@math{_ON} (bidirectional)
@item
Programmatically via @code{org-gtd-dependencies-create} (handles bidirectional updates)
@end itemize

@strong{For interactive use}: Use graph view or text-based task commands - they maintain the bidirectional relationship automatically.

@item
@anchor{ORG@math{_GTD}@math{_PROJECT}@math{_IDS}}ORG@math{_GTD}@math{_PROJECT}@math{_IDS}


@strong{Used on}: Tasks

@strong{Purpose}: Lists project IDs this task belongs to (supports multi-project tasks)

@strong{Format}: Space-separated list of project IDs

@strong{Note}: Currently org-gtd creates one project per task, but this property supports future multi-project features.
@end itemize

@node Calendar and Time Properties
@subsection Calendar and Time Properties

@itemize
@item
@anchor{ORG@math{_GTD}@math{_TIMESTAMP}}ORG@math{_GTD}@math{_TIMESTAMP}


@strong{Used on}: Calendar items, delegated items

@strong{Purpose}: Stores the appointment time or follow-up date

@strong{Format}: Org timestamp (inactive timestamp)

@strong{Example}:
@example
* Doctor appointment
:PROPERTIES:
:ORG_GTD: Calendar
:ORG_GTD_TIMESTAMP: [2025-10-15 Wed 14:00]
:END:
@end example

@strong{Why not use SCHEDULED}: org-gtd uses a custom property to distinguish between "do this at this time" (GTD calendar items) and "start working on this sometime after this date" (org-mode scheduling).

@strong{How it's set}:
@itemize
@item
Automatically by @code{org-gtd-organize} when organizing items as calendar items
@item
Programmatically when creating calendar items
@end itemize

@strong{For interactive use}: Use @code{org-gtd-organize} to change calendar items.
@end itemize

@node Delegation Properties
@subsection Delegation Properties

@itemize
@item
@anchor{DELEGATED@math{_TO}}DELEGATED@math{_TO}


@strong{Used on}: Delegated items

@strong{Purpose}: Stores the name of person/team the task is delegated to

@strong{Format}: String (person's name)

@strong{Example}:
@example
* Review document
:PROPERTIES:
:ORG_GTD: Delegated
:DELEGATED_TO: Alice Smith
:ORG_GTD_TIMESTAMP: [2025-10-18 Fri]
:END:
@end example

@strong{How it's set}:
@itemize
@item
Automatically by @code{org-gtd-organize} when organizing as delegated item
@item
Automatically by @code{org-gtd-delegate-agenda-item} from agenda
@item
Programmatically when creating delegated items
@end itemize

@strong{For interactive use}: Use @code{org-gtd-delegate-agenda-item} or organize flow.

@strong{Customization}: Set @code{org-gtd-delegate-read-func} to customize how names are entered (e.g., for completion).
@end itemize

@node Habit Properties
@subsection Habit Properties

@itemize
@item
@anchor{STYLE}STYLE


@strong{Used on}: Habits

@strong{Purpose}: Identifies item as an org-mode habit

@strong{Value}: @code{"habit"}

@strong{Example}:
@example
* TODO Exercise
SCHEDULED: <2025-10-11 Fri .+1d>
:PROPERTIES:
:STYLE: habit
:END:
@end example

@strong{Note}: This is a standard org-mode habit property. See org-mode documentation for habit repeat patterns and configuration.
@end itemize

@node Area of Focus Properties
@subsection Area of Focus Properties

@itemize
@item
@anchor{CATEGORY}CATEGORY


@strong{Used on}: All items (when using areas of focus)

@strong{Purpose}: Identifies which area of focus (GTD Horizon 2) an item belongs to

@strong{Format}: String matching value from @code{org-gtd-areas-of-focus}

@strong{Example}:
@example
* Finish quarterly report
:PROPERTIES:
:ORG_GTD: Actions
:CATEGORY: Work
:END:
@end example

@strong{When to set}:
@itemize
@item
During organize, if @code{org-gtd-set-area-of-focus} is in @code{org-gtd-organize-hooks}
@item
Manually with @code{org-gtd-area-of-focus-set-on-item-at-point}
@item
From agenda with @code{org-gtd-area-of-focus-set-on-agenda-item}
@end itemize

@strong{Use}: Filter views by area with @code{org-gtd-review-area-of-focus} or custom views.
@end itemize

@node Standard Org Properties Used by org-gtd
@subsection Standard Org Properties Used by org-gtd

@itemize
@item
@anchor{ID}ID


@strong{Used on}: All GTD items

@strong{Purpose}: Unique identifier for the item (org-mode standard)

@strong{Format}: Auto-generated UUID

@strong{Note}: org-gtd relies heavily on IDs for task relationships. Don't delete ID properties.

@item
@anchor{keyword}@strong{TODO} keyword


@strong{Not a property, but a heading keyword}

@strong{Values used by org-gtd}:
@itemize
@item
Value from @code{org-gtd-keyword-mapping}'s @code{todo} key (default "TODO")
@item
Value from @code{org-gtd-keyword-mapping}'s @code{next} key (default "NEXT")
@item
Value from @code{org-gtd-keyword-mapping}'s @code{wait} key (default "WAIT")
@item
Value from @code{org-gtd-keyword-mapping}'s @code{done} key (default "DONE")
@item
Value from @code{org-gtd-keyword-mapping}'s @code{canceled} key (default "CNCL")
@end itemize

@item
@anchor{SCHEDULED (org-mode standard)}SCHEDULED (org-mode standard)


@strong{Used on}: Habits primarily

@strong{Purpose}: For org-mode habits, defines repeat pattern

@strong{Note}: org-gtd uses ORG@math{_GTD}@math{_TIMESTAMP} for calendar items instead of SCHEDULED to maintain GTD semantics.

@item
@anchor{DEADLINE (org-mode standard)}DEADLINE (org-mode standard)


@strong{Used on}: Items with hard deadlines

@strong{Purpose}: Mark items that must be done by a specific date

@strong{Note}: org-gtd respects org-mode deadlines in all views and oops checks.
@end itemize

@node Troubleshooting Projects
@section Troubleshooting Projects

This section covers how to fix problems with project dependencies. @strong{You should rarely need this} - the graph view and task management commands handle dependencies correctly. If you find yourself needing these troubleshooting steps frequently, that indicates a bug - please file an issue!

@menu
* Fixing Broken Dependencies::
* When Manual Property Editing is Needed::
* Common Problems and Solutions::
@end menu

@node Fixing Broken Dependencies
@subsection Fixing Broken Dependencies

If you encounter dependency problems (circular dependencies, broken references, orphaned tasks):

@enumerate
@item
@strong{Validate project structure}:
@itemize
@item
Put point on project heading
@item
Run @code{M-x org-gtd-validate-project-dependencies}
@item
This detects broken references, orphaned tasks, and circular dependencies
@item
Follow the guidance provided
@end itemize

@item
@strong{Visual inspection with graph view}:
@itemize
@item
Run @code{M-x org-gtd-show-project-graph}
@item
Visual inspection often makes problems obvious
@item
Missing arrows? Use @code{a} to add missing dependencies
@item
Wrong arrows? Use @code{d} to remove incorrect dependencies
@item
Task with too many relationships? Use @code{i} to inspect, @code{x} to clear all
@end itemize

@item
@strong{Clear and rebuild}:
If task relationships are completely corrupted:
@itemize
@item
In graph view: Select the problematic task, press @code{x} to clear all relationships
@item
Or in text: Put point on task, run @code{M-x org-gtd-task-clear-relationships}
@item
Rebuild dependencies using graph view add commands (@code{a}, @code{a c}, @code{a b})
@end itemize
@end enumerate

@node When Manual Property Editing is Needed
@subsection When Manual Property Editing is Needed

@strong{You should never need to manually edit properties during normal use.}

The ONLY cases where manual property editing might be necessary:

@enumerate
@item
@strong{Writing elisp automation/integration code}
@itemize
@item
See @ref{Properties Reference (Internal Implementation), , Properties Reference} for property documentation
@item
Use programmatic functions: @code{org-gtd-dependencies-create}, @code{org-entry-add-to-multivalued-property}, etc.
@item
Never manipulate properties directly from interactive commands
@end itemize

@item
@strong{Debugging org-gtd internals}
@itemize
@item
If you suspect a bug in org-gtd's property management
@item
Compare properties with graph view to identify discrepancies
@item
File an issue with details!
@end itemize

@item
@strong{Migrating data from another system}
@itemize
@item
If importing projects from external tools
@item
Batch property updates may be more efficient
@item
Validate with @code{org-gtd-validate-project-dependencies} afterward
@end itemize

@item
@strong{Emergency recovery from data corruption}
@itemize
@item
Only as last resort if graph view and commands fail
@item
After manual edits, run @code{org-gtd-projects-fix-todo-keywords-for-project-at-point} (one project)
@item
Or run @code{org-gtd-projects-fix-all-todo-keywords} to fix all projects at once
@item
Consider this a bug and file an issue
@end itemize
@end enumerate

@strong{If you find yourself manually editing properties regularly}, that indicates missing features. Please file an issue describing your workflow - we'll add the missing commands!

@node Common Problems and Solutions
@subsection Common Problems and Solutions

@itemize
@item
@anchor{Project Shows No NEXT Tasks (Stuck Project)}Project Shows No NEXT Tasks (Stuck Project)


@strong{Symptom}: Project has incomplete tasks but none are NEXT@.

@strong{Diagnosis}:
@itemize
@item
Run @code{M-x org-gtd-show-project-graph}
@item
Look for green boxes (NEXT tasks)
@item
If no green boxes, check for:
@itemize
@item
Circular dependencies (arrows forming a loop)
@item
All tasks waiting on incomplete tasks
@item
Missing ORG@math{_GTD}@math{_FIRST}@math{_TASKS} property
@end itemize
@end itemize

@strong{Solution}:
@itemize
@item
Fix circular dependencies: Use @code{d} to remove incorrect dependencies
@item
Add root tasks: Use @code{a r} or @code{a b} to create tasks that can start immediately
@item
Run @code{org-gtd-validate-project-dependencies} for detailed diagnosis
@end itemize

@item
@anchor{Too Many NEXT Tasks}Too Many NEXT Tasks


@strong{Symptom}: Project shows 10+ green boxes in graph view.

@strong{Diagnosis}: Tasks that should be dependent are independent.

@strong{Solution}:
@itemize
@item
In graph view, identify tasks that should depend on others
@item
Use @code{a} to add dependencies between tasks
@item
Or restructure: tasks later in workflow should be children (@code{a c}) of earlier tasks
@end itemize

@item
@anchor{Task Won't Advance to NEXT}Task Won't Advance to NEXT


@strong{Symptom}: Completed a task, but dependent task still shows TODO (gray).

@strong{Diagnosis}:
@itemize
@item
In graph view, select the gray task
@item
Press @code{i} to show relationships
@item
Check if all blockers are actually DONE
@end itemize

@strong{Solution}:
@itemize
@item
If blockers are DONE but showing as blocking: Press @code{r} to refresh graph
@item
If blocker shouldn't block this task: Use @code{d} to remove the dependency
@item
If multiple wrong dependencies: Use @code{x} to clear all, rebuild with @code{a}
@end itemize

@item
@anchor{Task States Inconsistent After External Edits}Task States Inconsistent After External Edits


@strong{Symptom}: After editing on mobile app or resolving sync conflicts, task states don't match dependencies.

@strong{Examples}:
@itemize
@item
Tasks marked NEXT but blocked by incomplete dependencies
@item
Tasks stuck in TODO when they should be NEXT
@item
Multiple projects showing inconsistent states
@end itemize

@strong{Diagnosis}:
@itemize
@item
External tools (mobile apps, web interfaces) don't understand org-gtd dependency logic
@item
Manual edits or sync conflicts disrupted task states
@item
Affects all projects if you edited multiple files
@end itemize

@strong{Solution}:
@itemize
@item
For one project: Put point on project heading, run @code{M-x org-gtd-projects-fix-todo-keywords-for-project-at-point}
@item
For all projects: Run @code{M-x org-gtd-projects-fix-all-todo-keywords}
@end itemize

@strong{Recommended workflow after mobile edits}:
@enumerate
@item
Sync files to Emacs
@item
Run @code{M-x org-gtd-projects-fix-all-todo-keywords}
@item
Verify with @code{M-x org-gtd-engage} - should show correct NEXT tasks
@end enumerate
@end itemize

@node View DSL Filter Reference
@section View DSL Filter Reference

The View DSL (Domain-Specific Language) lets you create custom agenda views using simple, declarative syntax. This section documents all available filters.

@menu
* View Structure::
* Category Filters::
* Time-based Filters::
* Keyword Filters::
* Area of Focus Filters::
* Tag Filters::
* Property Filters::
* Structural Filters::
* Special Filters::
* View Configuration Options::
* Complete View Examples::
* Creating Custom Views::
@end menu

@node View Structure
@subsection View Structure

A GTD view is defined as an alist:

@lisp
'((name . "View Name")
  (filters . ((filter-type . filter-value) ...)))
@end lisp

Multiple filters create AND logic (all must match).

@node Category Filters
@subsection Category Filters

Filter by GTD item category:

@itemize
@item
@anchor{@code{(category delegated)}}@code{(category . delegated)}


@strong{Matches}: Items with DELEGATED@math{_TO} property

@strong{Use case}: See all delegated tasks

@strong{Example}:
@lisp
'((name . "All Delegations")
  (filters . ((category . delegated))))
@end lisp

@item
@anchor{@code{(category calendar)}}@code{(category . calendar)}


@strong{Matches}: Items with @code{ORG_GTD="Calendar"}

@strong{Use case}: See all calendar items/appointments

@strong{Example}:
@lisp
'((name . "Calendar Items")
  (filters . ((category . calendar))))
@end lisp

@item
@anchor{@code{(category projects)}}@code{(category . projects)}


@strong{Matches}: Project headings (@code{ORG_GTD="Projects"})

@strong{Use case}: List all projects

@strong{Example}:
@lisp
'((name . "All Projects")
  (filters . ((category . projects))))
@end lisp

@item
@anchor{@code{(category active-projects)}}@code{(category . active-projects)}


@strong{Matches}: Projects with at least one active (non-done) task

@strong{Use case}: See projects with work remaining

@strong{Example}:
@lisp
'((name . "Active Projects")
  (filters . ((category . active-projects))))
@end lisp

@item
@anchor{@code{(category completed-projects)}}@code{(category . completed-projects)}


@strong{Matches}: Projects where all tasks are DONE

@strong{Use case}: Weekly review to see completed projects ready to archive

@strong{Example}:
@lisp
'((name . "Completed Projects")
  (filters . ((category . completed-projects))))
@end lisp

@item
@anchor{@code{(category stuck-projects)}}@code{(category . stuck-projects)}


@strong{Matches}: Projects with active tasks but no NEXT or WAIT tasks

@strong{Use case}: Find projects needing attention (dependency problems)

@strong{Example}:
@lisp
'((name . "Stuck Projects")
  (filters . ((category . stuck-projects))))
@end lisp

@item
@anchor{@code{(category incubate)}}@code{(category . incubate)}


@strong{Matches}: Items with @code{ORG_GTD="Incubated"} (someday/maybe)

@strong{Use case}: Review someday/maybe list

@strong{Example}:
@lisp
'((name . "Someday/Maybe")
  (filters . ((category . incubate))))
@end lisp

@item
@anchor{@code{(category habit)}}@code{(category . habit)}


@strong{Matches}: Items with @code{STYLE="habit"}

@strong{Use case}: See all habits

@strong{Example}:
@lisp
'((name . "All Habits")
  (filters . ((category . habit))))
@end lisp
@end itemize

@node Time-based Filters
@subsection Time-based Filters

Filter by timestamps, deadlines, and scheduled dates:

@itemize
@item
@anchor{@code{(timestamp past)}}@code{(timestamp . past)}


@strong{Matches}: Items with @code{ORG_GTD_TIMESTAMP} in the past that aren't done

@strong{Use case}: Missed appointments and follow-ups

@strong{Example}:
@lisp
'((name . "Missed Appointments")
  (filters . ((category . calendar)
              (timestamp . past))))
@end lisp

@item
@anchor{@code{(timestamp future)}}@code{(timestamp . future)}


@strong{Matches}: Items with @code{ORG_GTD_TIMESTAMP} in the future

@strong{Use case}: Upcoming appointments

@strong{Example}:
@lisp
'((name . "Upcoming Appointments")
  (filters . ((category . calendar)
              (timestamp . future))))
@end lisp

@item
@anchor{@code{(deadline past)}}@code{(deadline . past)}


@strong{Matches}: Items with deadline in the past that aren't done

@strong{Use case}: Overdue items

@strong{Example}:
@lisp
'((name . "Overdue Items")
  (filters . ((deadline . past))))
@end lisp

@item
@anchor{@code{(scheduled past)}}@code{(scheduled . past)}


@strong{Matches}: Items scheduled in the past that aren't done

@strong{Use case}: Find items that should have started

@strong{Example}:
@lisp
'((name . "Overdue Start Dates")
  (filters . ((scheduled . past))))
@end lisp

@item
@anchor{@code{(scheduled future)}}@code{(scheduled . future)}


@strong{Matches}: Items scheduled in the future

@strong{Use case}: See what's coming up

@strong{Example}:
@lisp
'((name . "Future Scheduled")
  (filters . ((scheduled . future))))
@end lisp

@item
@anchor{@code{(scheduled today)}}@code{(scheduled . today)}


@strong{Matches}: Items scheduled for today

@strong{Use case}: Today's habits and scheduled actions

@strong{Example}:
@lisp
'((name . "Today's Scheduled Items")
  (filters . ((scheduled . today))))
@end lisp

@item
@anchor{@code{(closed recent)}}@code{(closed . recent)}


@strong{Matches}: Items closed in last 7 days

@strong{Use case}: Weekly review accomplishments

@strong{Example}:
@lisp
'((name . "Recent Completions")
  (filters . ((closed . recent))))
@end lisp

@item
@anchor{@code{(closed past-day)}}@code{(closed . past-day)}


@strong{Matches}: Items closed in last day

@item
@anchor{@code{(closed past-week)}}@code{(closed . past-week)}


@strong{Matches}: Items closed in last week

@item
@anchor{@code{(closed past-month)}}@code{(closed . past-month)}


@strong{Matches}: Items closed in last month

@item
@anchor{@code{(closed past-year)}}@code{(closed . past-year)}


@strong{Matches}: Items closed in last year

@item
@anchor{@code{(closed today)}}@code{(closed . today)}


@strong{Matches}: Items closed today

@strong{Use case}: End-of-day review

@strong{Example}:
@lisp
'((name . "Completed Today")
  (filters . ((closed . today))))
@end lisp
@end itemize

@node Keyword Filters
@subsection @strong{TODO} Keyword Filters

Filter by TODO state:

@itemize
@item
@anchor{@code{(todo ("KEYWORD1" "KEYWORD2"))}}@code{(todo . ("KEYWORD1" "KEYWORD2"))}


@strong{Matches}: Items with any of the specified TODO keywords

@strong{Use case}: Show specific states

@strong{Example}: Show only NEXT actions:
@lisp
'((name . "NEXT Actions Only")
  (filters . ((todo . ("NEXT")))))
@end lisp

@strong{Example}: Show NEXT and WAIT:
@lisp
'((name . "Active and Waiting")
  (filters . ((todo . ("NEXT" "WAIT")))))
@end lisp

@item
@anchor{@code{(done t)}}@code{(done . t)}


@strong{Matches}: Items with done TODO states (right side of @code{|} in keyword sequence)

@strong{Use case}: Show completed items

@strong{Example}:
@lisp
'((name . "Completed Items")
  (filters . ((done . t))))
@end lisp
@end itemize

@node Area of Focus Filters
@subsection Area of Focus Filters

Filter by life area:

@itemize
@item
@anchor{@code{(area-of-focus "AREA")}}@code{(area-of-focus . "AREA")}


@strong{Matches}: Items with @code{CATEGORY="AREA"}

@strong{Use case}: Focus on specific life area

@strong{Example}:
@lisp
'((name . "Work Items")
  (filters . ((area-of-focus . "Work"))))
@end lisp

@strong{Example}: Work projects only:
@lisp
'((name . "Work Projects")
  (filters . ((category . active-projects)
              (area-of-focus . "Work"))))
@end lisp
@end itemize

@node Tag Filters
@subsection Tag Filters

Filter by org tags:

@itemize
@item
@anchor{@code{(tags ("TAG1" "TAG2"))}}@code{(tags . ("TAG1" "TAG2"))}


@strong{Matches}: Items with any of the specified tags

@strong{Use case}: Filter by context, priority, or custom tags

@strong{Example}:
@lisp
'((name . "Home and Errands")
  (filters . ((todo . ("NEXT"))
              (tags . ("@@home" "@@errands")))))
@end lisp

@item
@anchor{@code{(tags-match "PATTERN")}}@code{(tags-match . "PATTERN")}


@strong{Matches}: Items matching org-mode tag expression pattern

@strong{Use case}: Complex tag queries

@strong{Example}: All items with context tags (tags starting with @@):
@lisp
'((name . "Context-Tagged Items")
  (filters . ((tags-match . "@{^@@@}"))))
@end lisp

@strong{Org tag expressions}:
@table @asis
@item @code{"tag1|tag2"}
Has tag1 OR tag2
@item @code{"tag1&tag2"}
Has tag1 AND tag2
@item @code{"@{^@@@}"}
Has any tag starting with @@
@end table
@end itemize

@node Property Filters
@subsection Property Filters

Filter by arbitrary org properties:

@itemize
@item
@anchor{@code{(property (("PROP" "VALUE")))}}@code{(property . (("PROP" . "VALUE")))}


@strong{Matches}: Items with specified property value

@strong{Use case}: Filter by custom properties

@strong{Example}:
@lisp
'((name . "High Priority Actions")
  (filters . ((property . (("PRIORITY" . "A")))
              (todo . ("NEXT")))))
@end lisp

@strong{Example}: Multiple property filters:
@lisp
'((name . "Project Tasks")
  (filters . ((property . (("ORG_GTD" . "Actions"))))))
@end lisp
@end itemize

@node Structural Filters
@subsection Structural Filters

Filter by org heading structure:

@itemize
@item
@anchor{@code{(level N)}}@code{(level . N)}


@strong{Matches}: Headings at level N

@strong{Use case}: Show only top-level items

@strong{Example}: Top-level projects only:
@lisp
'((name . "Top-Level Projects")
  (filters . ((category . projects)
              (level . 2))))
@end lisp

@strong{Note}: org-gtd projects are typically at level 2 in their files (under a category heading at level 1).
@end itemize

@node Special Filters
@subsection Special Filters

@itemize
@item
@anchor{@code{(not-habit t)}}@code{(not-habit . t)}


@strong{Matches}: Items that are NOT habits

@strong{Use case}: Exclude habits from views

@strong{Example}:
@lisp
'((name . "NEXT Actions (No Habits)")
  (filters . ((todo . ("NEXT"))
              (not-habit . t))))
@end lisp

@item
@anchor{@code{(invalid-timestamp t)}}@code{(invalid-timestamp . t)}


@strong{Matches}: Items with missing or malformed @code{ORG_GTD_TIMESTAMP} property

@strong{Use case}: Data validation, finding broken calendar/delegate items

@strong{Example}:
@lisp
'((name . "Items with Invalid Timestamps")
  (filters . ((invalid-timestamp . t))))
@end lisp
@end itemize

@node View Configuration Options
@subsection View Configuration Options

These options control how the view is displayed:

@itemize
@item
@anchor{@code{(view-type agenda)}}@code{(view-type . agenda)}


@strong{Purpose}: Create a native org-agenda view instead of org-ql block

@strong{Use case}: When you want a day/week agenda view

@strong{Example}:
@lisp
'((name . "Weekly Agenda")
  (view-type . agenda)
  (agenda-span . 7)
  (filters . ()))
@end lisp

@item
@anchor{@code{(agenda-span N)}}@code{(agenda-span . N)}


@strong{Purpose}: Number of days to show in agenda view

@strong{Default}: 1

@strong{Requires}: @code{(view-type . agenda)}

@strong{Example}: Week view:
@lisp
'((name . "Week Ahead")
  (view-type . agenda)
  (agenda-span . 7))
@end lisp

@item
@anchor{@code{(show-habits t)} or @code{(show-habits nil)}}@code{(show-habits . t)} or @code{(show-habits . nil)}


@strong{Purpose}: Control habit visibility in agenda views

@strong{Default}: Habits shown

@strong{Requires}: @code{(view-type . agenda)}

@strong{Example}: Agenda without habits:
@lisp
'((name . "Today (No Habits)")
  (view-type . agenda)
  (show-habits . nil))
@end lisp

@item
@anchor{@code{(additional-blocks BLOCK-SPECS)}}@code{(additional-blocks . BLOCK-SPECS)}


@strong{Purpose}: Add additional agenda blocks to the view

@strong{Format}: List of block specifications

@strong{Example}: Agenda + NEXT actions:
@lisp
'((name . "Today + Actions")
  (view-type . agenda)
  (additional-blocks . ((todo . "NEXT"))))
@end lisp

@item
@anchor{@code{(prefix-format FORMAT-STRING)}}@code{(prefix-format . FORMAT-STRING)}


@strong{Purpose}: Custom agenda prefix format

@strong{Use case}: Customize how items appear in agenda

@strong{Example}:
@lisp
'((name . "Custom Format View")
  (view-type . agenda)
  (prefix-format . "  %-12:c %?-12t% s"))
@end lisp
@end itemize

@node Complete View Examples
@subsection Complete View Examples

@itemize
@item
@anchor{Weekly Review View}Weekly Review View


@lisp
(defun my-weekly-review ()
  "Weekly review showing completed items, active projects, and stuck projects."
  (interactive)
  (org-agenda nil "w")
  (let ((org-agenda-custom-commands
         '(("w" "Weekly Review"
            ((org-ql-block '(and (property "ORG_GTD" "Projects")
                                 (project-has-active-tasks))
                           ((org-ql-block-header "Active Projects")))
             (org-ql-block '(and (property "ORG_GTD" "Projects")
                                 (project-is-stuck))
                           ((org-ql-block-header "Stuck Projects")))
             (org-ql-block '(closed :from "-7d")
                           ((org-ql-block-header "Completed This Week"))))))))
    (org-agenda nil "w")))
@end lisp

@item
@anchor{Context-Based View}Context-Based View


@lisp
(defun my-contexts-view ()
  "Show NEXT actions grouped by context."
  (interactive)
  (org-gtd-engage-grouped-by-context))
@end lisp

@item
@anchor{Morning Planning View}Morning Planning View


@lisp
(defun my-morning-view ()
  "Morning planning: today's agenda, NEXT actions, and delegations to follow up."
  (interactive)
  (org-gtd-view-show
   '((name . "Morning Planning")
     (view-type . agenda)
     (agenda-span . 1)
     (additional-blocks . ((todo . "NEXT"))))))
@end lisp
@end itemize

@node Creating Custom Views
@subsection Creating Custom Views

To create a custom view:

@enumerate
@item
@strong{Define the view specification}:
@lisp
(defun my-custom-view ()
  "Description of what this view shows."
  (interactive)
  (org-gtd-view-show
   '((name . "View Name")
     (filters . ((filter1 . value1)
                 (filter2 . value2))))))
@end lisp

@item
@strong{Bind to a key} (optional):
@lisp
(global-set-key (kbd "C-c d v") 'my-custom-view)
@end lisp

@item
@strong{Test and refine} - Run the view and adjust filters as needed
@end enumerate

@node Hooks Framework Reference
@section Hooks Framework Reference

@menu
* What Are Organize Hooks?::
* Your First Hook in 2 Minutes::
* The org-gtd-organize-hooks Variable::
* Built-in Hooks::
* Writing Custom Hooks::
* Example Custom Hooks::
* Hook Execution Order::
* Best Practices::
* Complete Example Comprehensive Hook Setup::
@end menu

@node What Are Organize Hooks?
@subsection What Are Organize Hooks?

Hooks let you automatically capture information about tasks as you organize them—like tracking when tasks were created, auto-tagging items with "urgent" in the title, or estimating effort based on keywords.

Without hooks, you'd manually add the same metadata to every task. With hooks, you define the pattern once and org-gtd applies it automatically during organization.

For anyone who wants consistent metadata on their GTD items without repetitive manual work.

@node Your First Hook in 2 Minutes
@subsection Your First Hook in 2 Minutes

Let's add automatic creation timestamps to all tasks except trash and quick actions.

@enumerate
@item
Add this to your config:
@lisp
(defun my-track-creation-date ()
  "Add CREATED property with current timestamp."
  (unless (org-gtd-organize-type-member-p '(trash quick))
    (org-set-property "CREATED"
                      (format-time-string "[%Y-%m-%d %a %H:%M]"))))

(add-to-list 'org-gtd-organize-hooks 'my-track-creation-date)
@end lisp

@item
Restart Emacs (or eval the code with @code{C-x C-e})

@item
Capture something: @code{M-x org-gtd-capture}, type "Test task", finish capture

@item
Process it: @code{M-x org-gtd-process-inbox}, organize as "Single action"

@item
Look at the task: you'll see a CREATED property with today's timestamp
@end enumerate

You just automated metadata capture. Every item you organize now gets timestamped automatically.

@node The org-gtd-organize-hooks Variable
@subsection The org-gtd-organize-hooks Variable

@strong{Type}: List of functions

@strong{When run}: During @code{org-gtd-organize}, after you choose item type but before refiling

@strong{Purpose}: Add metadata (tags, properties, etc.) to items as they're organized

@strong{Default value}: @code{'(org-set-tags-command)}

@node Built-in Hooks
@subsection Built-in Hooks

@itemize
@item
@anchor{@code{org-set-tags-command}}@code{org-set-tags-command}


@strong{What it does}: Prompts for tags to add to the item

@strong{Use when}: You want to tag items during organization (default)

@strong{To use}:
@lisp
(setq org-gtd-organize-hooks '(org-set-tags-command))
@end lisp

@item
@anchor{@code{org-gtd-set-area-of-focus}}@code{org-gtd-set-area-of-focus}


@strong{What it does}: Prompts for area of focus (from @code{org-gtd-areas-of-focus}) and sets CATEGORY property

@strong{Use when}: You use GTD Horizon 2 (areas of focus)

@strong{To use}:
@lisp
(setq org-gtd-organize-hooks '(org-set-tags-command
                               org-gtd-set-area-of-focus))
@end lisp

@strong{Behavior}: Skips prompt for:
@itemize
@item
Project tasks (sets on project instead)
@item
Trash items
@item
Knowledge items
@item
Quick actions
@end itemize
@end itemize

@node Writing Custom Hooks
@subsection Writing Custom Hooks

Custom hooks are functions that run during organization. They can:
@itemize
@item
Add properties
@item
Set tags
@item
Modify heading text
@item
Prompt for information
@item
Skip certain item types
@end itemize

@itemize
@item
@anchor{Basic Hook Structure}Basic Hook Structure


@lisp
(defun my-organize-hook ()
  "Description of what this hook does."
  (interactive)  ;; hooks can be interactive or not
  ;; Your code here
  ;; Point will be on the heading being organized
  ;; Use org-mode functions to modify it
  )
@end lisp

@item
@anchor{Using org-gtd-organize-type-member-p}Using org-gtd-organize-type-member-p


This helper function lets you run code only for specific item types.

@strong{Function signature}:
@lisp
(org-gtd-organize-type-member-p TYPE-LIST)
@end lisp

@strong{Arguments}:
@table @asis
@item @code{TYPE-LIST}
List of item type symbols to check against
@end table

@strong{Returns}: @code{t} if current item matches one of the types, @code{nil} otherwise

@strong{Available types}:
@table @asis
@item @code{'action}
Single actions
@item @code{'project}
Project headings
@item @code{'project-task}
Tasks within projects
@item @code{'calendar}
Calendar items
@item @code{'delegate}
Delegated items
@item @code{'incubate}
Someday/maybe items
@item @code{'habit}
Habits
@item @code{'knowledge}
Reference items
@item @code{'quick}
Quick actions (<2 min)
@item @code{'trash}
Trashed items
@end table

@strong{Example}: Only run for actions and projects:
@lisp
(defun my-hook ()
  (when (org-gtd-organize-type-member-p '(action project))
    ;; do something
    ))
@end lisp
@end itemize

@node Example Custom Hooks
@subsection Example Custom Hooks

@itemize
@item
@anchor{Selective Tagging with Unless}Selective Tagging with Unless


The most common pattern is "run this hook for everything EXCEPT certain types". This example prompts for tags on all items except trash and knowledge (reference):

@lisp
(defun my-tag-tasks ()
  "Prompt for tags on all items except trash and knowledge."
  (unless (org-gtd-organize-type-member-p '(trash knowledge))
    (org-set-tags-command)))

(setq org-gtd-organize-hooks '(my-tag-tasks))
@end lisp

This replaces the default @code{org-set-tags-command} with selective tagging. The @code{unless} pattern is cleaner than listing all the types you DO want: it says "skip these few, run for everything else."

@item
@anchor{Add Effort Estimation}Add Effort Estimation


@lisp
(defun my-add-effort ()
  "Prompt for effort estimation when organizing actions and projects."
  (when (org-gtd-organize-type-member-p '(action project))
    (call-interactively #'org-set-effort)))

(add-to-list 'org-gtd-organize-hooks 'my-add-effort)
@end lisp

@item
@anchor{Add Priority}Add Priority


@lisp
(defun my-add-priority ()
  "Prompt for priority when organizing actions."
  (when (org-gtd-organize-type-member-p '(action))
    (call-interactively #'org-priority)))

(add-to-list 'org-gtd-organize-hooks 'my-add-priority)
@end lisp

@item
@anchor{Auto-Set Property Based on Keywords}Auto-Set Property Based on Keywords


@lisp
(defun my-auto-tag-urgent ()
  "Automatically tag items with 'urgent' in their heading."
  (when (org-gtd-organize-type-member-p '(action project))
    (let ((heading (org-get-heading t t t t)))
      (when (string-match-p (regexp-quote "URGENT") heading)
        (org-set-tags ":urgent:")))))

(add-to-list 'org-gtd-organize-hooks 'my-auto-tag-urgent)
@end lisp

@item
@anchor{Add Custom Property}Add Custom Property


@lisp
(defun my-add-client ()
  "Prompt for client name on work-related items."
  (when (org-gtd-organize-type-member-p '(action project))
    (when (y-or-n-p "Is this for a client? ")
      (let ((client (read-string "Client name: ")))
        (org-set-property "CLIENT" client)))))

(add-to-list 'org-gtd-organize-hooks 'my-add-client)
@end lisp

@item
@anchor{Integration with Org-Roam}Integration with Org-Roam


@lisp
(defun my-link-to-roam-project ()
  "Link GTD project to Org-Roam note."
  (when (org-gtd-organize-type-member-p '(project))
    (when (y-or-n-p "Link to Org-Roam note? ")
      (org-roam-node-insert))))

(add-to-list 'org-gtd-organize-hooks 'my-link-to-roam-project)
@end lisp

@item
@anchor{Set Effort from Keywords}Set Effort from Keywords


@lisp
(defun my-auto-set-effort ()
  "Automatically set effort based on keywords in heading."
  (when (org-gtd-organize-type-member-p '(action))
    (let ((heading (downcase (org-get-heading t t t t))))
      (cond
       ((string-match-p "quick\\|call\\|email" heading)
        (org-set-property "Effort" "0:15"))
       ((string-match-p "meeting\\|review" heading)
        (org-set-property "Effort" "1:00"))
       ((string-match-p "research\\|write\\|design" heading)
        (org-set-property "Effort" "2:00"))))))

(add-to-list 'org-gtd-organize-hooks 'my-auto-set-effort)
@end lisp
@end itemize

@node Hook Execution Order
@subsection Hook Execution Order

Hooks run in the order they appear in @code{org-gtd-organize-hooks}.

@strong{Example}: Set area first, then tags:
@lisp
(setq org-gtd-organize-hooks
      '(org-gtd-set-area-of-focus  ;; runs first
        org-set-tags-command))      ;; runs second
@end lisp

This order matters if one hook depends on another's results.

@node Best Practices
@subsection Best Practices

@enumerate
@item
@strong{Use type checking}: Always use @code{org-gtd-organize-type-member-p} to run hooks only for relevant item types

@item
@strong{Keep hooks focused}: Each hook should do one thing well

@item
@strong{Make hooks optional}: Use @code{y-or-n-p} for optional metadata:
@lisp
(when (y-or-n-p "Add custom property? ")
  (org-set-property "PROP" value))
@end lisp

@item
@strong{Test interactively}: Make hooks interactive for testing:
@lisp
(defun my-hook ()
  (interactive)  ;; can test with M-x my-hook
  ...)
@end lisp

@item
@strong{Handle errors gracefully}: Wrap risky code in condition-case:
@lisp
(condition-case err
    (my-risky-operation)
  (error (message "Hook failed: %s" err)))
@end lisp

@item
@strong{Document your hooks}: Add docstrings explaining what each hook does
@end enumerate

@node Complete Example Comprehensive Hook Setup
@subsection Complete Example: Comprehensive Hook Setup

@lisp
;; Custom hooks for org-gtd
(defun my-add-effort ()
  "Prompt for effort on actions and projects."
  (when (org-gtd-organize-type-member-p '(action project))
    (call-interactively #'org-set-effort)))

(defun my-add-priority ()
  "Prompt for priority on actions."
  (when (org-gtd-organize-type-member-p '(action))
    (call-interactively #'org-priority)))

(defun my-auto-tag-contexts ()
  "Automatically suggest context tags based on heading keywords."
  (when (org-gtd-organize-type-member-p '(action))
    (let* ((heading (downcase (org-get-heading t t t t)))
           (suggested-tags '()))
      (when (string-match-p "\\(phone\\|call\\)" heading)
        (push "@@phone" suggested-tags))
      (when (string-match-p "\\(computer\\|code\\|write\\)" heading)
        (push "@@computer" suggested-tags))
      (when (string-match-p "\\(store\\|buy\\|shop\\)" heading)
        (push "@@errands" suggested-tags))
      (when suggested-tags
        (message "Suggested contexts: %s" (string-join suggested-tags ", "))))))

(defun my-track-creation-date ()
  "Add CREATED property with current timestamp."
  (unless (org-gtd-organize-type-member-p '(trash quick))
    (org-set-property "CREATED"
                      (format-time-string "[%Y-%m-%d %a %H:%M]"))))

;; Install hooks
(setq org-gtd-organize-hooks
      '(org-gtd-set-area-of-focus  ;; set area first
        org-set-tags-command        ;; then tags
        my-auto-tag-contexts        ;; suggest context tags
        my-add-effort               ;; estimate effort
        my-add-priority             ;; set priority if needed
        my-track-creation-date))    ;; track when created
@end lisp

This creates a comprehensive metadata capture workflow during organization.

@node Troubleshooting
@chapter Troubleshooting

This section covers common problems and their solutions. For complete command documentation, see @ref{Commands Reference}.

@menu
* Finding lost tasks::
* Projects without a NEXT item::
* I can't create a project when clarifying an inbox item!::
* Configuration problems::
* Tasks still showing after incubating project::
* Still stuck?::
@end menu

@node Finding lost tasks
@section Finding lost tasks

Sometimes items get stuck or fall through the cracks. org-gtd provides several commands to find problematic items:

@table @asis
@item @code{org-gtd-review-stuck-calendar-items}
Calendar items with invalid or missing timestamps
@item @code{org-gtd-review-stuck-incubated-items}
Incubated items with invalid or missing review dates
@item @code{org-gtd-review-stuck-habit-items}
Habits with incorrect configuration
@item @code{org-gtd-review-stuck-delegated-items}
Delegated items missing delegate or date information
@item @code{org-gtd-review-stuck-single-action-items}
Single actions that aren't marked as NEXT
@item @code{org-gtd-review-stuck-projects}
Projects that have tasks but no NEXT actions
@item @code{org-gtd-review-missed-items}
Items that should have been processed but weren't
@end table

See @ref{Commands Reference} for detailed documentation of these commands.

@node Projects without a NEXT item
@section Projects without a NEXT item

If a project has active tasks but none are marked NEXT, this usually indicates:
@enumerate
@item
Missing dependency configuration (no @code{ORG_GTD_FIRST_TASKS} property)
@item
org-edna is not enabled
@item
Dependency properties need recalculation
@item
Task states are inconsistent after external edits (mobile apps, sync conflicts)
@end enumerate

@strong{Solution for one project}: Put the point on the project heading and run @code{M-x org-gtd-projects-fix-todo-keywords-for-project-at-point}.

@strong{Solution for all projects}: Run @code{M-x org-gtd-projects-fix-all-todo-keywords} to fix all projects at once. This is especially useful after:
@itemize
@item
Editing tasks on mobile apps or web interfaces
@item
Resolving sync conflicts
@item
Bulk manual edits outside org-gtd
@item
Migrating or importing data
@end itemize

@strong{Note}: Make sure org-edna is enabled: @code{(org-edna-mode 1)} in your init file. See @ref{Configuring} for setup instructions.

See also: @ref{Working with Projects (Advanced)} for complete project troubleshooting guide.

@node I can't create a project when clarifying an inbox item!
@section I can't create a project when clarifying an inbox item!

When organizing an item as a project, org-gtd expects a specific structure:

@example
* Project heading
** First task
** Second task
** Third task
@end example

@strong{Common issues}:
@itemize
@item
Top-level heading must be a single asterisk @code{*}
@item
Tasks must be second-level headings @code{**}
@item
Must have at least one task under the project heading
@end itemize

See @ref{data shape requirements} for complete details.

If this doesn't solve your problem, please open an issue at @uref{https://github.com/Trevoke/org-gtd.el/issues} with:
@enumerate
@item
The exact structure of your item in the clarify buffer
@item
What happens when you try to organize it
@item
Any error messages
@end enumerate

@node Configuration problems
@section Configuration problems

@menu
* Keywords not working::
* Items not showing in engage view::
@end menu

@node Keywords not working
@subsection Keywords not working

If TODO keywords aren't changing correctly:

@enumerate
@item
@strong{Check @code{org-todo-keywords} includes all GTD keywords in one sequence}:
@lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
@end lisp

@item
@strong{Check @code{org-gtd-keyword-mapping} maps to those keywords}:
@lisp
(setq org-gtd-keyword-mapping
      '((todo . "TODO")
        (next . "NEXT")
        (wait . "WAIT")
        (done . "DONE")
        (canceled . "CNCL")))
@end lisp

@item
@strong{Remove any @code{#+TODO:} lines from GTD org files}
@end enumerate

See @ref{Configuring} for complete setup instructions.

@node Items not showing in engage view
@subsection Items not showing in engage view

If items aren't appearing in @code{org-gtd-engage}:

@enumerate
@item
@strong{Check org-agenda-files includes org-gtd-directory}:
@lisp
(setq org-agenda-files (list org-gtd-directory))
@end lisp

@item
@strong{Check item has correct properties}:
@itemize
@item
Single actions should have @code{ORG_GTD: Actions} and TODO keyword NEXT
@item
Project tasks should have @code{ORG_GTD: Actions} and be part of a project
@end itemize

@item
@strong{Verify org-edna is enabled}:
@lisp
(org-edna-mode 1)
@end lisp
@end enumerate

See @ref{Configuration Variables Reference} for all configuration options.

@node Tasks still showing after incubating project
@section Tasks still showing after incubating project

@strong{Symptom}: Incubated a project but some tasks still appear in engage view.

@strong{Diagnosis}:
@itemize
@item
Multi-project tasks (tasks shared between projects) are not incubated
@item
If task belongs to Project A and Project B, and you only incubate Project A, the task stays visible
@end itemize

@strong{Solution}:
@itemize
@item
Check task's ORG@math{_GTD}@math{_PROJECT}@math{_IDS} property to see which projects it belongs to
@item
Either incubate all projects the task belongs to, or remove it from one project first
@item
During incubation, watch for "Skipping multi-project task" messages
@end itemize

@strong{Recommended workflow}:
@enumerate
@item
Before incubating: review the project for multi-project tasks
@item
Decide: should this task stay active (part of other project) or be incubated too?
@item
If incubating: incubate all projects it belongs to
@item
If staying active: accept that it will remain visible
@end enumerate

@node Still stuck?
@section Still stuck?

If you're still having problems:

@enumerate
@item
Check @ref{Reference} for complete documentation
@item
Search existing issues: @uref{https://github.com/Trevoke/org-gtd.el/issues}
@item
Ask on Discord: @uref{https://discord.gg/2kAK6TfqJq}
@item
Open a new issue with:
@itemize
@item
Your org-gtd configuration
@item
Steps to reproduce the problem
@item
Expected vs actual behavior
@item
Any error messages
@end itemize
@end enumerate

@bye
