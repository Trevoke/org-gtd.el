#+TITLE: Org GTD User Manual
:PREAMBLE:
#+AUTHOR: Aldric Giacomoni
#+EMAIL: trevoke@gmail.com
#+DATE: 2015-{{{year}}}
#+LANGUAGE: en

#+TEXINFO_DIR_CATEGORY: Emacs
#+TEXINFO_DIR_TITLE: Org GTD: (org-gtd)
#+TEXINFO_DIR_DESC: An opinionated GTD flow implemented in org-mode
#+TEXINFO_FILENAME: ../org-gtd.info
#+SUBTITLE: for version 4.0
#+TEXINFO_DEFFN: t
#+OPTIONS: H:3 num:3 toc:2
#+PROPERTY: header-args :eval never
#+MACRO: year (eval (format-time-string "%Y"))

Org GTD is an attempt to implement the GTD flow described in the GTD
book as faithfully as possible.

#+TEXINFO: @noindent
This manual is for Org GTD version 4.0

:END:
* Copying
:PROPERTIES:
:copying:  t
:END:
Copyright (C) 2018-{{{year}}} Aldric Giacomoni <trevoke@gmail.com>

You can redistribute this document and/or modify it under the terms
of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any
later version.

This document is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

* Summary
:PROPERTIES:
:DESCRIPTION: quick intro to GTD
:END:
This package tries to replicate as closely as possible the GTD workflow (see diagram below).

This package, and this documentation, assume familiarity with the flow of GTD as described in the book.

This package provides a system that allows you to capture incoming things into an inbox, then process the inbox and categorize each item based on the GTD categories. It leverages org-agenda to show today's items as well as the NEXT items. It provides a flexible project management system with support for both sequential and parallel task execution.

*New to org-gtd?* Start with [[#getting-started][Getting Started with Org GTD]] for a hands-on tutorial.

*Upgrading from 3.x?* See [[#upgrading][Upgrading]] for required configuration changes and migration steps.
#+begin_example
                                    +-------+
                                    |"STUFF"|
                                    +---+---+
                                        |
                                    +---v---+
                                    | INBOX |
                                    +---+---+
                                        |              Eliminate  +-----------+
                                        |            +----------->|  Trash    |
                                 +------v------+     |            +-----------+
                                 | What is it? |     |
                                 +------+------+     |            +-----------+
                                        |            | Incubate   |  Someday/ |
                                        |            +----------->|   Maybe   |
+----------+  YES (multi-step)   +------v------+  NO |            +-----------+
| Projects |<--------------------|    Is it    |-----+
+-+----^---+                     | Actionable? |     | File       +-----------+
  |    |   +----------------+    +------+------+     +----------->| Reference |
  |    |        Review for  |           |                         +-----------+
+-v----+---+     Actions    |           |
| Planning |                +---------->| YES
+----------+                            |
                                 +------v------+     Less than
                       Delegate  | What's the  |     2 minutes    +-----------+
                     +-----------+    NEXT     +----------------->|   DO IT   |
                     |           |   Action?   |                  +-----------+
                     |           +------+------+
                     |                  |
                     |                  | FOR ME:
                     |                  |         Specific Date or Time
                     |                  +-------------------------------+
                     |              ASAP|                               |
               +-----v-----+      +-----v-----+                   +-----v-----+
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               |           |      |           |                   |           |
               +-----------+      +-----------+                   +-----------+
                Waiting For        Next Actions                      Calendar
#+end_example
* What's new in 4.0
:PROPERTIES:
:CUSTOM_ID: new-in-4.0
:END:

Version 4.0 is a major release that transforms how Org GTD handles projects and configuration, while maintaining compatibility with your existing GTD data.

** Flexible project dependencies (the big one!)
Projects are no longer limited to sequential tasks! You can now create complex project structures with parallel tasks and custom dependencies.

- *Define any dependency relationship* - Tasks can block other tasks, creating a directed acyclic graph (DAG) of dependencies
- *Parallel work streams* - Multiple tasks can be NEXT at the same time if they don't depend on each other
- *Automatic dependency detection* - Org GTD finds all tasks that are ready to work on based on the dependency graph
- *Cycle prevention* - The system prevents circular dependencies that would create deadlocks
- *Visual dependency helper* (optional) - See task relationships in a side window while clarifying projects

Tasks without explicit dependencies still work sequentially (as before), so your existing projects continue to work unchanged.

** Simplified keyword configuration
The new keyword configuration system is clearer and more maintainable:

- *One mapping instead of many variables* - Replace individual keyword variables (~org-gtd-next~, ~org-gtd-todo~, etc.) with a single ~org-gtd-keyword-mapping~ structure
- *Global TODO keywords* - No more file-level ~#+TODO:~ lines that can conflict. Use Emacs' global ~org-todo-keywords~ configuration instead
- *Automatic validation* - Org GTD validates your keyword configuration and provides helpful error messages if something is wrong
- *Better Emacs 29+ support* - Use ~setopt~ for automatic validation when setting variables

See [[#all-the-levers][Configuration options]] for details.

** Data-driven configuration
New configuration system allows you to customize item properties declaratively:

- *Configure by item type* - Define what properties each GTD item type should have
- *Prompt for user input* - Automatically prompt for dates, text, or custom data when organizing
- *Extensible* - Easy to add your own custom configuration for new item types

** Declarative view language
Creating custom agenda views is now much easier with a declarative syntax:

- *Specify what you want, not how to get it* - Define views using simple filters instead of complex skip functions
- *Built on org-ql* - Leverages the powerful org-ql query language for performance
- *More maintainable* - View definitions are data structures, not code

** Better project modification
- *Add tasks to projects anywhere* - You can now add tasks to projects even if the project file is outside ~org-gtd-directory~
- *Modify project structure* - Commands to create task dependencies and manage complex projects

** Enhanced review capabilities
- *Find missed items* - New ~org-gtd-review-missed-items~ command to catch things that slipped through
- *Better stuck project detection* - Improved identification of projects that need attention

** Simplified configuration
- *org-gtd-mode is obsolete* - No need for a special mode anymore. Just configure ~org-agenda-files~ and ~org-edna~ directly in your init file. The old mode was wrapping all agenda commands unnecessarily and had org-edna configured incorrectly.

** What you need to do
If you're upgrading from 3.x, see the [[#upgrading][Upgrading section]] for complete step-by-step instructions. The required changes are:

1. Update your keyword configuration to use ~org-gtd-keyword-mapping~
2. Remove any ~#+TODO:~ lines from your GTD files
3. *Run the migration: ~M-x org-gtd-upgrade-v3-to-v4~* (required for projects to work!)

For new installations, just configure ~org-todo-keywords~ and ~org-gtd-keyword-mapping~ and you're ready to go.

** Previous versions
For changes in earlier versions, see:
- [[file:whats-new-3.0.org][What's new in 3.0]]

* Setting up Org GTD
** Upgrading
:PROPERTIES:
:DESCRIPTION: How to upgrade your local setup across major versions
:CUSTOM_ID: upgrading
:END:
If you are installing and not upgrading, you can skip this section entirely and just go to the next section, [[#Installing][Installing]].
*** 4.0.0 <- 3.x.x
Version 4.0 introduces major improvements to keyword configuration and project management. Your existing GTD data will continue to work, but you'll need to update your configuration and optionally migrate to take full advantage of new features.

**** Required: Configuration changes

*1. Update keyword configuration*

*OLD way (version 3.x):*
#+begin_src emacs-lisp
;; Individual keyword variables (no longer used)
(setq org-gtd-next "NEXT")
(setq org-gtd-todo "TODO")
(setq org-gtd-wait "WAIT")
(setq org-gtd-canceled "CNCL")
#+end_src

*NEW way (version 4.0):*
#+begin_src emacs-lisp
;; First, configure org-mode's global TODO keywords
;; All your GTD keywords must be in the same sequence
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))

;; Then map GTD semantic states to your keywords
;; Use setopt (Emacs 29+) for automatic validation, or setq for older versions
(setopt org-gtd-keyword-mapping
        '((todo . "TODO")      ;; tasks not ready to be acted upon
          (next . "NEXT")      ;; tasks ready to act on immediately
          (wait . "WAIT")      ;; tasks blocked or delegated
          (done . "DONE")      ;; tasks successfully completed
          (canceled . "CNCL"))) ;; tasks that won't be completed
#+end_src

Steps:
1. Remove old keyword variables (~org-gtd-next~, ~org-gtd-todo~, ~org-gtd-wait~, ~org-gtd-canceled~ and their ~-suffix~ variants) from your configuration
2. Remove any ~#+TODO:~ lines from your GTD org files (inbox.org, org-gtd-tasks.org, etc.)
3. Add the global keyword configuration to your Emacs init file
4. Ensure all GTD keywords appear in the *same sequence* in ~org-todo-keywords~

**** Required: Data migration

Version 4.0 changes how projects work internally. *The old TRIGGER-based system no longer functions* - v4 uses dependency properties instead. You MUST run the migration for your existing projects to continue working.

*Run the migration command:*

#+begin_src emacs-lisp
M-x org-gtd-upgrade-v3-to-v4
#+end_src

*Make a backup first!* The migration modifies your GTD files.

*What the migration does:*

The migration performs two steps automatically:

1. *Adds ORG_GTD properties* to identify items:
   - Adds ~ORG_GTD="Projects"~ to project headings
   - Adds ~ORG_GTD="Actions"~ to project tasks

2. *Converts projects to dependency-based system*:
   - Adds ~ORG_GTD_DEPENDS_ON~ and ~ORG_GTD_BLOCKS~ properties to create sequential task chains
   - Adds ~ORG_GTD_FIRST_TASKS~ property to project headings
   - Updates task states (NEXT/TODO) based on the new dependency graph

*After migration:*

- Your projects continue to work sequentially (task 1 → task 2 → task 3)
- The sequential behavior is now implemented via dependency properties instead of TRIGGER
- You can now customize dependencies for individual projects if you want parallel tasks
- Safe to run multiple times if needed

**** Why these changes?

*Keyword configuration:*
- Simpler: One mapping structure instead of multiple variables
- More reliable: Global configuration avoids file-level conflicts
- Better validation: Org GTD checks your configuration and provides helpful errors
- Future-proof: Easier to extend with new keyword types

*Property-based system:*
- More robust: Properties work reliably across different org-mode features
- More flexible: Enables features like multi-project tasks
- Better performance: Faster queries using org-ql

**** org-gtd-mode is obsolete

The ~org-gtd-mode~ minor mode is obsolete in version 4.0. It previously wrapped all org-agenda commands with org-gtd context, but this is no longer necessary because:

1. All org-gtd commands (like ~org-gtd-engage~) already have the right context
2. Users should configure ~org-agenda-files~ directly
3. Users should configure org-edna directly (the old mode had it configured incorrectly)

If you were using ~org-gtd-mode~, simply remove it and add these lines to your config:

#+begin_src emacs-lisp
(setq org-agenda-files (list org-gtd-directory))
(org-edna-mode 1)
#+end_src

** Installing
:PROPERTIES:
:DESCRIPTION: Get Org GTD in your emacs
:CUSTOM_ID: Installing
:END:
This package requires Emacs 28.1 or higher.

This package is on MELPA and MELPA stable under the name ~org-gtd~.
*** use-package
Just make sure this is loaded after ~org-mode~ like so.
#+begin_src emacs-lisp
  (use-package org-gtd :after org)
#+end_src
*** Manually
Check out the source code for dependencies and install them.
Then, clone this repo to a directory of your choice, e.g. =~/.emacs.d/packages=.
Finally, add this to your config:
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.emacs.d/packages")
(require 'org-gtd)
#+end_src
** Configuring
:PROPERTIES:
:DESCRIPTION: Required and optional system configuration
:CUSTOM_ID: configuring
:END:
*** Basic setup
You need to configure three things for org-gtd to work:

1. *TODO keywords*: Configure ~org-todo-keywords~ with your GTD workflow states
2. *Keyword mapping*: Map GTD semantic states to your keywords with ~org-gtd-keyword-mapping~
3. *org-edna*: Enable org-edna with inheritance for project dependencies to work

See the configuration sections below for details.

Note: ~org-gtd-mode~ is obsolete as of version 4.0. Just configure org-agenda-files and org-edna directly.

*** Complete Configuration Examples

*Configuration is the most critical part of setup.* The examples below are complete, working configurations you can copy-paste into your init file.

**** Example 1: Vanilla Emacs (Minimal Configuration)
:PROPERTIES:
:CUSTOM_ID: example-1-vanilla-emacs-minimal-configuration
:END:

This is the simplest possible configuration for org-gtd. Copy this entire block into your init file:

#+begin_src emacs-lisp
;; Configure org-mode TODO keywords
;; All GTD keywords MUST be in the same sequence
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))

;; Map GTD semantic states to your keywords
(setq org-gtd-keyword-mapping
      '((todo . "TODO")      ; tasks not ready to act on
        (next . "NEXT")      ; tasks ready to act on immediately
        (wait . "WAIT")      ; tasks blocked or delegated
        (done . "DONE")      ; tasks successfully completed
        (canceled . "CNCL"))) ; tasks that won't be completed

;; Optional: Set GTD directory (defaults to ~/gtd/)
;; (setq org-gtd-directory "~/my-gtd/")

;; Add org-gtd files to your agenda
(setq org-agenda-files (list org-gtd-directory))

;; REQUIRED: Enable org-edna for project dependencies
(org-edna-mode 1)

;; Global keybindings for GTD commands
;; These work anywhere in Emacs
(global-set-key (kbd "C-c d c") 'org-gtd-capture)
(global-set-key (kbd "C-c d e") 'org-gtd-engage)
(global-set-key (kbd "C-c d p") 'org-gtd-process-inbox)
(global-set-key (kbd "C-c d n") 'org-gtd-show-all-next)
(global-set-key (kbd "C-c d s") 'org-gtd-review-stuck-projects)

;; Keybinding for clarify map
;; This only works when you're in a clarify buffer
(with-eval-after-load 'org-gtd
  (define-key org-gtd-clarify-map (kbd "C-c c") 'org-gtd-organize))
#+end_src

**** Example 2: Doom Emacs Configuration
:PROPERTIES:
:CUSTOM_ID: example-2-doom-emacs-configuration
:END:

If you use Doom Emacs, add this to your ~packages.el~:

#+begin_src emacs-lisp
(package! org-gtd)
#+end_src

Then add this to your ~config.el~:

#+begin_src emacs-lisp
(use-package! org-gtd
  :after org
  :custom
  (org-gtd-directory "~/gtd/")
  (org-todo-keywords '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
  (org-gtd-keyword-mapping '((todo . "TODO")
                             (next . "NEXT")
                             (wait . "WAIT")
                             (done . "DONE")
                             (canceled . "CNCL")))
  (org-agenda-files (list org-gtd-directory))
  :config
  (org-edna-mode)
  ;; Doom-style leader key bindings
  (map! :leader
        (:prefix ("d" . "org-gtd")
         :desc "Capture"        "c"  #'org-gtd-capture
         :desc "Engage"         "e"  #'org-gtd-engage
         :desc "Process inbox"  "p"  #'org-gtd-process-inbox
         :desc "Show all next"  "n"  #'org-gtd-show-all-next
         :desc "Stuck projects" "s"  #'org-gtd-review-stuck-projects))
  ;; Clarify map binding
  (map! :map org-gtd-clarify-map
        :desc "Organize this item" "C-c c" #'org-gtd-organize))
#+end_src

**** Example 3: Spacemacs Configuration
:PROPERTIES:
:CUSTOM_ID: example-3-spacemacs-configuration
:END:

If you use Spacemacs, add this to your ~dotspacemacs/user-config~ function:

#+begin_src emacs-lisp
;; Install org-gtd
(use-package org-gtd
  :ensure t
  :after org
  :init
  ;; Configure org-mode TODO keywords
  (setq org-todo-keywords
        '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
  ;; Map GTD semantic states
  (setq org-gtd-keyword-mapping
        '((todo . "TODO")
          (next . "NEXT")
          (wait . "WAIT")
          (done . "DONE")
          (canceled . "CNCL")))
  ;; Optional: Set GTD directory
  (setq org-gtd-directory "~/gtd/")
  ;; Add to agenda files
  (setq org-agenda-files (list org-gtd-directory))
  :config
  ;; REQUIRED: Enable org-edna for project dependencies
  (org-edna-mode 1)
  ;; Spacemacs leader key bindings
  (spacemacs/set-leader-keys
    "od c" 'org-gtd-capture
    "od e" 'org-gtd-engage
    "od p" 'org-gtd-process-inbox
    "od n" 'org-gtd-show-all-next
    "od s" 'org-gtd-review-stuck-projects)
  ;; Clarify map binding
  (with-eval-after-load 'org-gtd
    (define-key org-gtd-clarify-map (kbd "C-c c") 'org-gtd-organize)))
#+end_src

**** What These Configurations Do

All three examples configure the same essential pieces:

1. *~org-todo-keywords~* - Defines the workflow states (TODO → NEXT → WAIT → DONE/CNCL)
   - The ~|~ separator marks done states (right side) vs active states (left side)
   - All GTD keywords must be in a single sequence

2. *~org-gtd-keyword-mapping~* - Maps GTD concepts to your keyword choices
   - ~todo~ - Tasks not yet actionable
   - ~next~ - Tasks ready to work on right now
   - ~wait~ - Tasks blocked or delegated
   - ~done~ - Tasks successfully completed
   - ~canceled~ - Tasks that won't be done

3. *~org-gtd-directory~* - Where org-gtd keeps its files (defaults to =~/gtd/=)

4. *~org-agenda-files~* - Makes org-gtd items appear in agenda views

5. *~org-edna-mode~* - REQUIRED for projects to work

6. *Keybindings* - Two types:
   - *Global bindings*: Work anywhere in Emacs (capture, engage, process, etc.)
   - *Clarify map binding*: Only works when organizing items in clarify buffers

**** Testing Your Configuration

After adding one of the configurations above and restarting Emacs, verify everything works:

*Test 1: Capture works*

#+begin_example
M-x org-gtd-capture
#+end_example

Expected: Opens a capture buffer for the inbox.

If it fails: Check that ~org-gtd-directory~ exists and you have write permissions.

*Test 2: Engage works*

#+begin_example
M-x org-gtd-engage
#+end_example

Expected: Opens an agenda view (might be empty if you haven't organized anything yet).

If it fails: Check that ~org-agenda-files~ includes your GTD directory.

*Test 3: Keywords are recognized*

1. Open any org file: ~M-x find-file ~/test.org~
2. Type: ~* Test heading~
3. Put cursor on the heading
4. Try cycling TODO states: ~C-c C-t~

Expected: Should cycle through TODO → NEXT → WAIT → DONE → CNCL.

If it fails: Check that ~org-todo-keywords~ is set correctly.

*Test 4: org-edna is enabled*

#+begin_example
M-x describe-variable RET org-edna-mode
#+end_example

Expected: Should show "t" (enabled).

If it fails: Make sure ~(org-edna-mode 1)~ is in your config and you've restarted Emacs.

**** Common Configuration Problems

Before troubleshooting, identify which configuration style you're using:
- *Vanilla Emacs*: See [[#example-1-vanilla-emacs-minimal-configuration][Example 1: Vanilla Emacs]]
- *Doom Emacs*: See [[#example-2-doom-emacs-configuration][Example 2: Doom Emacs]]
- *Spacemacs*: See [[#example-3-spacemacs-configuration][Example 3: Spacemacs]]

Each example shows the complete, correct configuration for that environment.

*Problem: "org-gtd-capture" is undefined*

*Cause*: org-gtd package isn't installed or loaded.

*Solution*:
- *Vanilla Emacs*: Install from MELPA with ~M-x package-install RET org-gtd RET~
- *Doom Emacs*: Add ~(package! org-gtd)~ to your ~packages.el~ and run ~doom sync~
- *Spacemacs*: The ~use-package~ form in the [[#example-3-spacemacs-configuration][Spacemacs example]] automatically installs it with ~:ensure t~

*Problem: Keywords don't change when I press C-c C-t*

*Cause*: ~org-todo-keywords~ not configured correctly.

*Solution*: Check your configuration has this setting:
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
#+end_src

Common mistakes:
- Keywords not in quotes: Should be ~"TODO"~ not ~TODO~
- Missing sequence wrapper: Need ~'((sequence ...))~ not just ~'("TODO" ...)~
- No done separator: Need ~|~ before ~"DONE"~ and ~"CNCL"~

See the complete configuration for your environment above.

*Problem: Projects don't advance when I mark tasks DONE*

*Cause*: org-edna isn't enabled.

*Solution*: All three configuration examples include ~(org-edna-mode 1)~. Make sure you have:
- *Vanilla/Spacemacs*: ~(org-edna-mode 1)~ in the ~:config~ section
- *Doom*: ~(org-edna-mode)~ in the ~:config~ section (Doom handles the argument)

*Problem: Can't see GTD items in agenda*

*Cause*: GTD directory not in ~org-agenda-files~.

*Solution*: All three configuration examples include this. Check you have:
#+begin_src emacs-lisp
(setq org-agenda-files (list org-gtd-directory))
#+end_src

Or if using ~use-package~ / ~use-package!~:
#+begin_src emacs-lisp
:custom
(org-agenda-files (list org-gtd-directory))
#+end_src

*Problem: Keybindings don't work*

*Cause*: Keybindings not defined, or defined incorrectly for your environment.

*Solution*:
- *Vanilla Emacs*: Use ~global-set-key~ for global commands, ~define-key org-gtd-clarify-map~ for clarify buffer commands
- *Doom Emacs*: Use ~map!~ with ~:leader~ prefix for global, ~:map org-gtd-clarify-map~ for clarify buffer
- *Spacemacs*: Use ~spacemacs/set-leader-keys~ for global, ~define-key~ for clarify buffer

The clarify binding (~C-c c~) *only works in clarify buffers* - you must run ~M-x org-gtd-process-inbox~ first.

See the complete configuration for your environment to copy the correct keybinding syntax.

*** Understanding Keybindings

org-gtd uses two types of keybindings, and understanding the difference is important:

**** Global Keybindings

These work *anywhere* in Emacs and let you access the main GTD commands:

#+begin_src emacs-lisp
;; These commands are always available:
(global-set-key (kbd "C-c d c") 'org-gtd-capture)       ; Capture to inbox
(global-set-key (kbd "C-c d e") 'org-gtd-engage)        ; Daily view
(global-set-key (kbd "C-c d p") 'org-gtd-process-inbox) ; Process inbox
(global-set-key (kbd "C-c d n") 'org-gtd-show-all-next) ; Show NEXT actions
#+end_src

You can use any key combination you prefer. The ~C-c d~ prefix is just a convention.

**** Clarify Map Keybindings

These only work when you're in a *clarify buffer* (during inbox processing). The most important one is:

#+begin_src emacs-lisp
;; This only works in clarify buffers:
(define-key org-gtd-clarify-map (kbd "C-c c") 'org-gtd-organize)
#+end_src

*When you're in a clarify buffer:*
1. You've called ~org-gtd-process-inbox~ and are looking at an item
2. You've edited the item to make it clear and actionable
3. Now you press ~C-c c~ to organize it (choose its type: project, single action, etc.)

*Why the distinction?*

The clarify map is a separate keymap because:
- It prevents conflicts with other org-mode bindings
- It only activates when you need it (during processing)
- You can bind different keys for organizing without affecting the rest of Emacs

*Common patterns:*

Most users bind:
- ~C-c d *~ for global commands (capture, engage, process)
- ~C-c c~ for organizing (only in clarify buffers)

But you can use whatever works for your workflow!

*** Required configuration of sub-packages
:PROPERTIES:
:CUSTOM_ID: configuring-sub-packages
:END:
**** Configuring org-edna
:PROPERTIES:
:CUSTOM_ID: configuring-org-edna
:END:
package: https://www.nongnu.org/org-edna-el/

This configuration is *REQUIRED* for project dependencies to work correctly. It enables org-edna to automatically update task states when you complete tasks in a project.

#+begin_src emacs-lisp
(org-edna-mode 1)
#+end_src

**** Adding org-gtd files to your agenda

To see org-gtd items in your agenda views, add the org-gtd directory to your ~org-agenda-files~:

#+begin_src emacs-lisp
;; If you only want GTD files in your agenda:
(setq org-agenda-files (list org-gtd-directory))

;; Or if you have other agenda files, add GTD to the list:
(add-to-list 'org-agenda-files org-gtd-directory)
#+end_src
*** configuration options for org-gtd
**** I don't care, just let me start using it
The most direct way to find out about the configuration options for org-gtd is to see the customize group: ~M-x customize-group RET org-gtd~. They are all optional because they all come with default values.

The only one you may want to change before starting to use Org GTD is ~org-gtd-directory~, which is the directory that Org GTD
will look to for everything it needs to do.

The configuration options will also be mentioned in the relevant subsections of [[#using-org-gtd][Using Org GTD]].
**** Tell me all the levers I can pull
:PROPERTIES:
:CUSTOM_ID: all-the-levers
:END:

Make sure you also read about sub-package configuration: [[#configuring-sub-packages][Required configuration of sub-packages]].

***** Required keyword configuration

These settings are *required* for Org GTD to work properly:

- ~org-todo-keywords~ :: (=org-mode= variable) Define your TODO keyword sequences here. All GTD keywords (TODO, NEXT, WAIT, DONE, CNCL or your custom versions) *must* be in the same sequence. Example.
  #+begin_src emacs-lisp
  (setq org-todo-keywords
        '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
  #+end_src

- ~org-gtd-keyword-mapping~ :: Map GTD semantic states to your chosen keywords. This tells Org GTD which keyword means what. The five required mappings are.
  - ~todo~ :: Tasks not ready to be acted upon
  - ~next~ :: Tasks ready to act on immediately
  - ~wait~ :: Tasks blocked or delegated to someone else
  - ~done~ :: Tasks successfully completed
  - ~canceled~ :: Tasks that won't be completed

  Example configuration (use ~setopt~ for Emacs 29+ to get automatic validation):
  #+begin_src emacs-lisp
  (setopt org-gtd-keyword-mapping
          '((todo . "TODO")
            (next . "NEXT")
            (wait . "WAIT")
            (done . "DONE")
            (canceled . "CNCL")))
  #+end_src

  Or for older Emacs versions:
  #+begin_src emacs-lisp
  (setq org-gtd-keyword-mapping
        '((todo . "TODO")
          (next . "NEXT")
          (wait . "WAIT")
          (done . "DONE")
          (canceled . "CNCL")))
  #+end_src

***** Optional configuration

- ~org-gtd-directory~ :: set this to a directory. =org-gtd= will look for all its files in this directory.
- ~org-gtd-capture-templates~ :: (!note: take care when changing this) This defines the pre-filled text that will show up when capturing an item to the inbox. The only requirements are that the template string must define an org-mode top-level heading, and that the entry point to the inbox.  That is to say, the first two characters must be a single asterisk followed by a space: ~"* "~, and the entry type must be like this: =entry  (file ,#'org-gtd-inbox-path)=. [[#adding-things-to-the-inbox][Adding things to the inbox]].
- ~org-reverse-note-order~ :: (=org-mode= variable) set this to ~t~ to add new items to the top of project tasks and to ~nil~ to add new items to the bottom of project tasks when organizing an item as such.
- ~org-gtd-organize-hooks~ :: this is a list of functions that you can use to decorate each item when you clarify it. For instance, you could add a function to set the effort, or the priority, or some category, etc. By default it has only one function, which lets you add tags, but of course you can change this entirely. [[#organizing-an-item][Organizing an item]].
- ~org-gtd-archive-location~ :: Points to a function to generate the archive file dynamically. Default value generates a file suffixed with the current year. The function has an arity of zero and generates an org-mode file+outline path. [[#cleaning-up-the-system][Cleaning up / archiving completed work]].
- ~org-gtd-refile-to-any-target~ :: when ~t~, =org-gtd= will refile to the first target it finds, and create a target if it doesn't find one. When false, it will ask for confirmation before refiling. [[#refiling-after-organizing][Refiling to the appropriate area]].
- ~org-gtd-delegate-read-func~ :: function that is used to prompt for a person a task is delegated to. Must return a string. By default this is set to ~read-string~.
- ~org-gtd-areas-of-focus~ :: list of strings representing your areas of focus (horizon 2 in GTD).
- ~org-gtd-clarify-show-horizons~ :: When clarifying, do you want the horizons buffer to be shown by default, or do you prefer it hidden?
- ~org-gtd-clarify-project-templates~ :: Alist of strings: ~project template name . project template~ where there template is a series of tasks you may want to insert automatically, if you have a generic type of project that comes up a lot.
- ~org-gtd-horizons-file~ :: Name of the file, in ~org-gtd-directory~, that will be displayed when the horizons buffer is displayed when clarifying.
- ~org-gtd-engage-prefix-width~ :: how many characters to dedicate to the prefix, on the left side of the TODO items, so the project name, if any, can show clearly.
*** Recommended key bindings
:PROPERTIES:
:CUSTOM_ID: recommended-key-bindings
:END:

There's an important keymap you'll want to make the flow of processing the inbox smoother. To limit impact on your emacs configuration, there is a specific keymap you can use. The function you'll want to bind is ~org-gtd-organize~. I suggest ~C-c c~, as in the following example.

#+begin_src elisp
(define-key org-gtd-clarify-map (kbd "C-c c") #'org-gtd-organize)
#+end_src

For other keybindings, do what you need. My bindings use ~C-c d~ as a prefix, i.e.:

- ~C-c d c~ :: ~org-gtd-capture~
- ~C-c d e~ :: ~org-gtd-engage~

etc.
*** Sample Doom Emacs Config
If you are a Doom Emacs user, then your configuration may look something like this:

#+BEGIN_SRC elisp
  (use-package! org-gtd
    :after org
    :custom
    (org-gtd-directory "~/gtd/")
    (org-todo-keywords '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
    (org-gtd-keyword-mapping '((todo . "TODO")
                               (next . "NEXT")
                               (wait . "WAIT")
                               (done . "DONE")
                               (canceled . "CNCL")))
    (org-agenda-files (list org-gtd-directory))
    :config
    (org-edna-mode)
    (map! :leader
          (:prefix ("d" . "org-gtd")
           :desc "Capture"        "c"  #'org-gtd-capture
           :desc "Engage"         "e"  #'org-gtd-engage
           :desc "Process inbox"  "p"  #'org-gtd-process-inbox
           :desc "Show all next"  "n"  #'org-gtd-show-all-next
           :desc "Stuck projects" "s"  #'org-gtd-review-stuck-projects))
    (map! :map org-gtd-clarify-map
          :desc "Organize this item" "C-c c" #'org-gtd-organize))
#+END_SRC
* Getting Started with Org GTD
:PROPERTIES:
:DESCRIPTION: Tutorials to get you productive quickly
:CUSTOM_ID: getting-started
:END:

You've configured org-gtd. Now let's see it in action with real examples that demonstrate why org-gtd is powerful.

** Quick Start Reference

If you haven't done the 5-minute Quick Start in the README yet, do that first. It walks you through:
1. Capturing a single action
2. Processing your inbox
3. Organizing the item
4. Seeing it in your engage view

That Quick Start proves the basic cycle works. Now let's see what makes org-gtd special: automatic project management and custom views.

** Tutorial: Your First Project
:PROPERTIES:
:CUSTOM_ID: tutorial-your-first-project
:END:

You've captured and organized a single action. That's great for simple tasks, but GTD's real power is managing multi-step projects. Let's create one and watch org-gtd handle the complexity automatically.

*** What You'll Learn

- How to capture and structure a project
- How org-gtd automatically manages task dependencies
- How tasks advance from TODO → NEXT when dependencies are satisfied
- How the engage view shows you what's immediately actionable

*** The Project

We'll plan a small house renovation with three sequential steps:
1. Review blueprints
2. Order windows
3. Schedule carpenter

This demonstrates sequential project execution - the default behavior where each task must complete before the next begins.

*** Step 1: Capture the Project

Press ~C-c d c~ (or ~M-x org-gtd-capture~).

Type (or paste) this structure:

#+begin_example
,* House Renovation
,** Review blueprints
,** Order windows of the right size
,** Schedule carpenter
#+end_example

*Important*: Projects in org-gtd have a specific structure:
- Top-level heading (~*~) is the project name
- Second-level headings (~**~) are the tasks

Press ~C-c C-c~ to save.

*** Step 2: Process the Inbox

Press ~C-c d p~ (or ~M-x org-gtd-process-inbox~).

You'll see your project in a clarify buffer. This is your chance to refine it:
- Add details to tasks (we already added "of the right size" to clarify what we need)
- Fix typos
- Make everything crystal clear

When you're satisfied, press ~C-c c~ to organize.

*** Step 3: Organize as a Project

The transient menu appears with organization options. Press *[p]* for "Project".

Watch what org-gtd does automatically:
1. Marks the first task ("Review blueprints") as *NEXT*
2. Marks other tasks as *TODO*
3. Sets up dependency relationships (task 1 blocks task 2, task 2 blocks task 3)
4. Refiles the entire project to your projects file

You'll see a prompt for tags (optional). Press ~RET~ to skip or add tags if you want.

The project is now in your GTD system!

*** Step 4: View in Engage

Press ~C-c d e~ (or ~M-x org-gtd-engage~).

You'll see an agenda view showing:
- *NEXT: Review blueprints* - This is immediately actionable
- The project "House Renovation" appears in the list
- Other tasks ("Order windows", "Schedule carpenter") don't show as NEXT - they're waiting for the first task

This is your daily engagement view - it shows *only* what you can act on right now, not everything in your system.

*** Step 5: Complete the First Task

In the agenda view, move your cursor to "Review blueprints".

Press *t* to cycle the TODO state.

Select *DONE*.

*Magic happens*: Watch "Order windows of the right size" automatically become NEXT!

This is org-edna in action - the automatic dependency system org-gtd uses.

*** Step 6: Refresh and See the Change

Press *g* to refresh the agenda view.

You'll now see:
- ✓ "Review blueprints" is DONE (depending on your agenda settings, it may be hidden)
- *NEXT: Order windows of the right size* - Now actionable!
- "Schedule carpenter" is still TODO - waiting for "Order windows" to complete

*** What Just Happened?

Let's understand the automatic workflow:

1. *When you organized as a project*, org-gtd:
   - Created a dependency chain: Task 1 → Task 2 → Task 3
   - Set properties (~ORG_GTD_BLOCKS~, ~ORG_GTD_DEPENDS_ON~) to track relationships
   - Marked only the first task as NEXT

2. *When you marked "Review blueprints" DONE*, org-gtd:
   - Checked which tasks were blocked by this one
   - Found "Order windows" had no remaining blockers
   - Automatically changed it from TODO to NEXT

3. *"Schedule carpenter" stays TODO* because:
   - It depends on "Order windows" completing
   - org-gtd won't mark it NEXT until its dependencies are satisfied

You didn't manually manage any of this. You just *did the work* and marked tasks complete. org-gtd handled the workflow automatically.

*** Continue the Project

Complete "Order windows" the same way:
1. Go to the engage view (~C-c d e~)
2. Find "Order windows of the right size"
3. When done, press *t* and select *DONE*
4. Watch "Schedule carpenter" automatically become NEXT

When all tasks are done, the project is complete. You can archive it with ~M-x org-gtd-archive-completed-items~ during your weekly review.

*** Key Takeaways

- *Projects are multi-step actions* with automatic dependency management
- *Sequential execution is the default* - tasks progress one after another
- *The engage view shows only actionable items* - not everything in your system
- *You focus on doing work, not managing workflows* - org-gtd handles task progression
- *Completing tasks automatically advances projects* - no manual state management needed

*** What's Next?

This was a sequential project (A → B → C). Later, you'll learn how to:
- Create *parallel tasks* (A and B can both be NEXT simultaneously)
- Set *custom dependencies* (A blocks C, B blocks C, but A and B are parallel)
- Manage *complex project structures* with the dependency graph

For now, practice with a few simple sequential projects. The pattern is always:
1. *Capture* with project structure
2. *Clarify* to make it clear
3. *Organize* as a project
4. *Engage* to see what's actionable
5. *Complete* tasks and watch progression happen automatically

** Tutorial: Creating Your First Custom View

The built-in ~org-gtd-engage~ view is powerful, but you'll want custom views for different contexts. org-gtd 4.0 has a declarative View DSL that makes this easy. Let's create a view that shows all your active projects.

*** What You'll Learn

- How the View DSL works (declarative syntax)
- How to create a simple custom view
- How to call your view and see results
- How to modify views for different needs

*** Why This View?

The engage view shows *today's actionable items* - what you should work on right now.

But sometimes you want the *big picture*:
- What projects am I working on?
- Which ones have active tasks?
- What's the status of each project?

This view answers those questions by showing all active projects at a glance.

*** Understanding the View DSL

Views in org-gtd are *declarative* - you describe *what* you want to see, not *how* to find it.

Here's the view we'll create:

#+begin_src emacs-lisp
'((name . "My Active Projects")
  (filters . ((category . projects)
              (has-active-tasks . t))))
#+end_src

Let's break this down:

- ~name~ :: What displays in the view header
- ~filters~ :: What to include.
  - ~category . projects~ :: Only show project headings (not single actions)
  - ~has-active-tasks . t~ :: Only projects with work remaining

That's it! The View DSL translates this into an org-ql query and shows results.

*** Creating the View Function

Add this to your init file (after your org-gtd configuration):

#+begin_src emacs-lisp
(with-eval-after-load 'org-gtd
  (defun my-org-gtd-active-projects ()
    "Show all active projects."
    (interactive)
    (org-gtd-view-show
     '((name . "My Active Projects")
       (filters . ((category . projects)
                   (has-active-tasks . t)))))))
#+end_src

Save your init file and reload it (~M-x eval-buffer~ or restart Emacs).

*** Using Your View

Now you can call it:

#+begin_example
M-x my-org-gtd-active-projects
#+end_example

You'll see a list of all your active projects!

*** Binding to a Key

For quick access, bind it to a key. Add this to your configuration:

#+begin_src emacs-lisp
;; If using vanilla Emacs
(global-set-key (kbd "C-c d P") 'my-org-gtd-active-projects)

;; If using Doom Emacs, add to your org-gtd config:
(map! :leader
      (:prefix "d"
       :desc "Active projects" "P" #'my-org-gtd-active-projects))

;; If using Spacemacs, add to your config:
(spacemacs/set-leader-keys "od P" 'my-org-gtd-active-projects)
#+end_src

Now press ~C-c d P~ (or your binding) to see active projects instantly!

*** What You'll See

The view shows:
- All projects that have at least one active task
- Each project's current state (what tasks are NEXT, TODO, etc.)
- Project names and context

Projects that are:
- Completely DONE - Won't appear (no active tasks)
- Canceled - Won't appear (no active tasks)
- Have only TODO/NEXT/WAIT tasks - Will appear

*** Experiment: Modify the View

Try these variations to see how the View DSL works:

*Show ALL projects (including completed):*

#+begin_src emacs-lisp
(defun my-org-gtd-all-projects ()
  "Show all projects, including completed ones."
  (interactive)
  (org-gtd-view-show
   '((name . "All Projects")
     (filters . ((category . projects))))))
     ;; Note: removed has-active-tasks filter
#+end_src

*Show stuck projects:*

#+begin_src emacs-lisp
(defun my-org-gtd-stuck-projects ()
  "Show projects that have work but no NEXT actions."
  (interactive)
  (org-gtd-view-show
   '((name . "Stuck Projects")
     (filters . ((category . projects)
                 (is-stuck . t))))))
#+end_src

*Show projects in a specific area of focus* (if you use areas):

#+begin_src emacs-lisp
(defun my-org-gtd-work-projects ()
  "Show only work projects."
  (interactive)
  (org-gtd-view-show
   '((name . "Work Projects")
     (filters . ((category . projects)
                 (has-active-tasks . t)
                 (area-of-focus . "Work"))))))
#+end_src

*** Available Filters

Here are common filters you can use in your views:

- ~category~ :: Filter by GTD category: ~projects~, ~actions~, ~calendar~, ~incubate~, ~habits~
- ~todo~ :: Filter by keyword: ~"NEXT"~, ~"TODO"~, ~"WAIT"~, ~"DONE"~, ~"CNCL"~
- ~has-active-tasks~ :: Only items with active (non-done) tasks
- ~is-stuck~ :: Projects that have tasks but no NEXT actions
- ~scheduled~ :: Items scheduled (you can specify ranges)
- ~deadline~ :: Items with deadlines
- ~area-of-focus~ :: Filter by area (if you use GTD horizons)
- ~property~ :: Filter by any org property

You can combine multiple filters - they all must match (AND logic).

*** Key Takeaways

- *Views are declarative* - you describe what you want, not how to get it
- *The View DSL is readable* - it's data, not complex code
- *Views are easy to create and modify* - just change the filter list
- *You can create unlimited views* - for different contexts and needs
- *Views leverage org-ql* - fast and powerful queries

*** What's Next?

Now that you understand views, you can create:
- *Review views* - For your weekly/monthly reviews
- *Context views* - Show work items, home items, errands, etc.
- *Time-based views* - Overdue items, upcoming deadlines, this week's schedule
- *Focus views* - Deep work items, quick wins, waiting-for items

See [[#view-dsl-reference][View DSL Filter Reference]] for the complete filter documentation with all available options and many more examples.

*** Where to Go From Here

You now know:
1. How to create and manage projects (Tutorial 1)
2. How to create custom views (Tutorial 2)

This is enough to be productive with org-gtd! The next section, "Using Org GTD", goes deep into:
- All GTD item types (calendar, delegate, incubate, etc.)
- Advanced project features (parallel tasks, custom dependencies)
- Hooks and customization
- Integration with email and other tools
- Review workflows

Read those sections as you need them. For now, *start using what you've learned*:
- Capture items as they come up
- Process your inbox regularly (daily if possible)
- Use the engage view to see what's actionable
- Create a few simple projects
- Experiment with custom views

The best way to learn GTD is to practice the workflow. org-gtd handles the complexity - you just do the work.

*Quick reference*:
- [[#using-org-gtd][Using Org GTD]] - Deep dive into daily workflow and all item types
- [[#reference][Reference]] - Complete documentation for configuration, commands, properties, views, and hooks
- [[#troubleshooting][Troubleshooting]] - Solutions to common problems

* Using Org GTD
:PROPERTIES:
:DESCRIPTION: How Org GTD maps to the GTD flow
:CUSTOM_ID: using-org-gtd
:END:

You've completed the tutorials and understand the basics. This section covers everything else you'll need as you use org-gtd day-to-day and want to explore more advanced features.

** Your Daily Workflow
:PROPERTIES:
:DESCRIPTION: The GTD cycle you'll practice every day
:END:

The GTD workflow has six steps. You'll do the first four frequently (even daily), and the last two periodically:

1. *Capture* - Get things out of your head into your inbox (~org-gtd-capture~)
2. *Process* - Look at each inbox item one at a time (~org-gtd-process-inbox~)
3. *Clarify* - Edit the item to make it clear and actionable
4. *Organize* - Categorize the item (~org-gtd-organize~)
5. *Engage* - Look at what you can do right now (~org-gtd-engage~)
6. *Review* - Periodically review your system for health

You already practiced this in the [[#getting-started][Getting Started tutorials]]. The sections below go deeper into each part.

*** Quick command reference

These are the commands you'll use most:

| Command | What it does | When to use it |
|-|-|-|
| ~org-gtd-capture~ | Add item to inbox | Anytime something comes up |
| ~org-gtd-process-inbox~ | Start processing inbox | Daily (or when inbox has items) |
| ~org-gtd-organize~ | Organize current item | During processing (in clarify buffer) |
| ~org-gtd-engage~ | See actionable items | Daily (your "work from" view) |
| ~org-gtd-show-all-next~ | See only NEXT actions | When you want to focus on actions |
| ~org-gtd-review-stuck-projects~ | Find stuck projects | Weekly review |
| ~org-gtd-projects-fix-all-todo-keywords~ | Fix task states after external edits | After mobile/web edits |
| ~org-gtd-archive-completed-items~ | Archive finished items | Weekly/monthly cleanup |

For complete command reference with detailed explanations, see [[#commands-reference][Commands Reference]].

For details on each workflow step, see the subsections below.

** The GTD Flow in Depth
:PROPERTIES:
:DESCRIPTION: Detailed explanation of each GTD step
:END:

Here are the domain elements of GTD that we handle:
*** Adding things to the inbox
:PROPERTIES:
:CUSTOM_ID: adding-things-to-the-inbox
:END:

The trip through GTD arguably begins by adding things to the inbox. The inbox is a file called ~inbox.org~ in the directory stored in the variable ~org-gtd-directory~. By default this means the file will be ~~/gtd/inbox.org~.

Org GTD provides one function to capture items: ~M-x org-gtd-capture~. In my setup I have this bound globally as such:

#+begin_src elisp
(global-set-key "C-c d c" #'org-gtd-capture)
#+end_src

This function uses the variable ~org-gtd-capture-templates~ to define org-gtd-specific capture templates. By default it comes with two templates, one to just capture a new item, and one to capture an item with a link to the file where you were when you started the capture.

You can customize these templates as you see fit. In order to maintain proper functioning of org-gtd, however, there are two constraints:

1. the first two characters of the template string must be a single asterisk followed by a space: ~"* "~
2. the entry type must be like this: =entry  (file ,#'org-gtd-inbox-path)=

*See also*: [[#config-vars-reference][Configuration Variables Reference]] for complete documentation of ~org-gtd-capture-templates~ and ~org-gtd-directory~.

*** Processing the inbox
:PROPERTIES:
:CUSTOM_ID: processing-the-inbox
:END:
Processing the inbox means taking everything in the inbox, one at a time, and refining/categorizing them so they are instantly useful when you are looking at available next / scheduled actions.

You can start processing the inbox with ~org-gtd-process-inbox~. This starts a looping behavior of clarifying each item in the inbox.

*** Clarifying each item
:PROPERTIES:
:CUSTOM_ID: clarification
:END:
Clarifying an item means editing and adding the information that will be most valuable to you to the item. Note that task-specific information, such as appointment date, or name of person to whom it is delegated, or even area of focus, will be added during the Organize step, so don't worry about these yet.
**** How to start clarifying
Besides ending up in here automatically while processing the inbox, there's two more ways to enter the clarifying flow:

- ~org-gtd-clarify-item~ :: call this from any org-mode heading to do a one-off clarification.
- ~org-gtd-clarify-agenda-item~ :: call this from the agenda view, if you have anything you want to re-clarify, or possibly clarify for the first time, from somewhere outside the inbox.

**** data shape requirements
:PROPERTIES:
:CUSTOM_ID: data-shape-requirement-while-clarifying
:END:
There's two general shapes you'll be looking for.
Almost everything will look like a simple org-mode heading.
For instance, ~* Task desc~.


The only exception will be a project, that will look like a top-level heading for the project description with, underneath, a series of second-level headings representing each task to be executed sequentially before the project is complete.

#+begin_example
,* Project heading
,** First task
,** Second task
,** Third task
#+end_example

**** Options and commands related to clarification
:PROPERTIES:
:CUSTOM_ID: options-and-behaviors-related-to-clarification-step
:END:
The clarify buffers are ~org-mode~ buffers that use the minor mode ~org-gtd-clarify-mode~. There is a keymap, ~org-gtd-clarify-map~, that you can use to bind useful

While clarifying, you may find it useful to see your GTD horizons. You can use:
- ~org-gtd-clarify-toggle-horizons-window~ :: a function that toggles the display of the horizons buffer
- ~org-gtd-clarify-show-horizons~ :: a boolean variable defining whether the horizons window should be shown (t) or hidden (nil) by default when clarifying an item. See  [[#working-with-horizons][Working with the GTD Horizons]] for more details.

If you are clarifying a project, you may be interested in project templates:
- ~org-gtd-clarify-project-insert-template~ :: a function that will ask you to choose a template to insert.
- ~org-gtd-clarify-project-templates~ :: an alist of the form =(name . template)= where both name and template are strings. =name= will be used in the interactive menu, and =template= will be inserted in the buffer.

*See also*: [[#config-vars-reference][Configuration Variables Reference]] for complete documentation of clarification options, and [[#commands-reference][Commands Reference]] for all clarification commands.

*** Organizing an item into the system
:PROPERTIES:
:CUSTOM_ID: organizing-an-item
:END:
When you are done clarifying, call ~M-x org-gtd-organize~ (or hit your keybinding for it, see [[#recommended-key-bindings][Recommended key bindings]]). This will open a transient menu to let you choose how Org GTD should categorize this item.

Organizing is broken up into three steps:
- Choosing a task type (see [[#understanding-gtd-item-types][Understanding GTD Item Types]])
- Applying hooks to add additional relevant information (see [[#hooks-reference][Hooks Framework Reference]])
- Refiling to the appropriate area (see [[#refiling-after-organizing][Refiling]] below)

*See also*: [[#commands-reference][Commands Reference]] for the ~org-gtd-organize~ command and all organization-related commands.

**** Refiling to the appropriate area
:PROPERTIES:
:CUSTOM_ID: refiling-after-organizing
:END:

***** Understanding Refiling in V4

In org-gtd v4, refiling is *optional organizational preference*, not a structural requirement. Items can exist anywhere in your ~org-agenda-files~.

By default, org-gtd uses ~ORG_GTD_REFILE~ properties to mark refile target headings. These can be at *any level* in *any file* in ~org-agenda-files~.

***** Default Refile System

When ~org-gtd-use-refile-system~ is t (default), org-gtd finds refile targets by searching for ~ORG_GTD_REFILE~ property:

#+begin_example
,* Projects         <-- Can be anywhere, any level
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:

,** Work/
,*** Development Projects   <-- Also a valid refile target!
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:
#+end_example

When you organize an item as a Project, org-gtd finds *all* headings with ~ORG_GTD_REFILE: Projects~ and lets you choose where to refile.

***** Creating New Refile Targets

To create a new refile target, add ~ORG_GTD_REFILE~ property to any heading:

For Projects:
#+begin_src org-mode
,* My Projects
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:
#+end_src

For other types, use the appropriate template constant value:
- Projects: ~ORG_GTD_REFILE: Projects~
- Actions: ~ORG_GTD_REFILE: Actions~
- Calendar: ~ORG_GTD_REFILE: Calendar~
- Incubated: ~ORG_GTD_REFILE: Incubated~
- Habits: ~ORG_GTD_REFILE: Habits~

If no refile target exists when organizing, org-gtd automatically creates one in your default GTD file.

***** Using Your Own Refile Configuration

If you prefer your own refile organization:

#+begin_src elisp
(setq org-gtd-use-refile-system nil)
#+end_src

Now org-gtd respects your ~org-refile-targets~ configuration. You can refile anywhere you've configured.

***** Migration from V3

V3 required this structure:
#+begin_example
,* Projects      <-- MUST be level 1
:PROPERTIES:
:ORG_GTD: Projects    <-- Dual-purpose property
:END:
#+end_example

V4 is flexible:
#+begin_example
,* Projects      <-- Can be anywhere, any level
:PROPERTIES:
:ORG_GTD_REFILE: Projects    <-- Marks refile target
:END:
#+end_example

The upgrade script (~org-gtd-upgrade-v3-to-v4~) automatically renames ~ORG_GTD~ → ~ORG_GTD_REFILE~ on your old category headings.

*** Engaging with your GTD items

You can see a list of all NEXT actions, and scheduled actions, with ~M-x org-gtd-engage~ .

You can call ~org-gtd-show-all-next~ to only see NEXT actions, nothing scheduled.

You can use ~M-x org-gtd-review-missed-engagements~ to find appointments you missed, delegated items needing check-ins, and late projects. This is your safety net for catching things that slipped through the cracks.

The weekly review is not yet implemented.

** Understanding GTD Item Types
:PROPERTIES:
:DESCRIPTION: When to use each type in the organize menu
:CUSTOM_ID: understanding-gtd-item-types
:END:

When you organize an item (~org-gtd-organize~), a transient menu appears with different item types. This section explains what each type means and when to use it.

You already saw *Projects* and *Single actions* in the tutorials. Here's the complete reference for all item types:

*** Single Action [S]

*What it is*: A one-off task to do when you have time and energy.

*When to use it*: For standalone tasks that aren't time-sensitive, don't depend on anyone else, and can be done whenever you're ready.

*Examples*:
- Buy birthday gift for Alex
- Read article about GTD methodology
- Update profile photo
- Clean garage

*What org-gtd does*:
- Marks it as NEXT (immediately actionable)
- Refiles to your actions file
- Shows in ~org-gtd-engage~ view

*** Project [P]

*What it is*: A multi-step action requiring more than one task to complete.

*When to use it*: When accomplishing your goal requires multiple sequential (or parallel) steps.

*Examples*:
- House renovation (review blueprints → order materials → schedule work)
- Launch product (design → build → test → deploy → announce)
- Plan vacation (research destinations → book flights → arrange accommodation)

*What org-gtd does*:
- Creates dependency relationships between tasks
- Marks first task(s) as NEXT, others as TODO
- Automatically advances tasks as you complete them
- Refiles entire project to your projects file

See [[#working-with-projects-advanced][Working with Projects]] for advanced features (parallel tasks, custom dependencies).

*** Add to existing project [A]

*What it is*: Add the current task to a project that already exists.

*When to use it*: When you realize a project needs an additional task, or you're breaking down a project task into sub-tasks.

*Examples*:
- Adding "Get permits" to your house renovation project
- Adding "Write announcement email" to your product launch project

*What org-gtd does*:
- Prompts you to choose which project
- Inserts task into project (position depends on ~org-reverse-note-order~)
- Task keywords may need adjustment - use ~org-gtd-projects-fix-todo-keywords-for-project-at-point~ on the project heading if needed

*** Calendar [C]

*What it is*: An action that must be done at a specific date or time.

*When to use it*: For appointments, events, or time-sensitive tasks.

*Examples*:
- Doctor appointment on Tuesday at 2pm
- Team meeting every Monday at 9am
- Submit report by Friday 5pm (deadline)
- Call contractor on Thursday

*What org-gtd does*:
- Prompts for date/time
- Adds timestamp to ~ORG_GTD_TIMESTAMP~ property
- Marks as NEXT
- Shows in agenda views at the appropriate time

*Note*: This is for calendar items, not scheduled work blocks. In GTD, scheduling means "do this at this time," not "start working on this someday."

*** Delegate [D]

*What it is*: A task someone else will do, but you need to follow up on.

*When to use it*: When you're waiting for someone else to complete something and you need to check back.

*Examples*:
- Waiting for designer to finish mockups
- Asked colleague to review document
- IT to fix laptop issue
- Contractor to provide estimate

*What org-gtd does*:
- Prompts for: person name, follow-up date
- Sets ~DELEGATED_TO~ property
- Marks as WAIT
- Shows in waiting-for views
- Appears in agenda on follow-up date

*Customization*: Set ~org-gtd-delegate-read-func~ to use completion for names.

*** Quick Action [Q]

*What it is*: Tasks that take less than 2 minutes.

*When to use it*: For trivial tasks you can do immediately.

*Examples*:
- Reply to quick email
- File a document
- Add item to shopping list
- Send calendar invite

*What org-gtd does*:
- Marks as DONE
- Archives immediately
- Assumes you just did it

*GTD principle*: If it takes less than 2 minutes, do it now. Don't organize it - just do it and mark it done.

*** Incubate [I]

*What it is*: Ideas or potential actions you're not ready to commit to yet (someday/maybe).

*When to use it*: For things you want to think about later but don't want to act on now.

*Examples*:
- Learn Spanish (someday)
- Write a book (maybe)
- Remodel kitchen (not yet)
- Take photography class (when I have time)

*What org-gtd does*:
- Prompts for review date
- Refiles to incubate file
- Will remind you on that date to reconsider

*GTD principle*: Keep these out of your active system. Review periodically (weekly/monthly) to decide if they're ready to become real projects or actions.

*** Habit [H]

*What it is*: Recurring tasks you want to track consistently (org-mode habits).

*When to use it*: For building routines and tracking streaks.

*Examples*:
- Exercise daily
- Write in journal
- Review finances weekly
- Call parents monthly

*What org-gtd does*:
- Prompts for: repeat pattern (e.g., "daily", "+1w"), start date
- Creates org-mode habit with consistency tracking
- Shows habit graph in agenda views

*Note*: See org-mode documentation for habit repeat patterns and tracking.

*** Knowledge [K]

*What it is*: Reference information to store for later.

*When to use it*: When the item is information to keep, not an action to take.

*Examples*:
- Recipe you want to remember
- Quote from article
- Meeting notes for reference
- Product specifications

*Important*: Choose this AFTER you've properly stored the information somewhere (your notes system, wiki, etc.). This just marks the inbox item as "filed" and archives it.

*GTD principle*: Separate "stuff to do" from "stuff to know." Knowledge goes in your reference system, not your action lists.

*** Trash [T]

*What it is*: Not actionable, not worth keeping.

*When to use it*: When you captured something that turns out to be irrelevant, already done, or not worth pursuing.

*Examples*:
- Event that already passed
- Duplicate of another item
- Idea that's no longer relevant
- Spam/noise

*What org-gtd does*:
- Deletes the item
- Doesn't archive, just removes it

*GTD principle*: Be ruthless. If it's not actionable and not valuable information, delete it. Clutter in your system creates noise.

*See also*: For technical details on how each item type is stored, see [[#properties-reference][Properties Reference]].

*** Working with the GTD Horizons
:PROPERTIES:
:CUSTOM_ID: working-with-horizons
:END:
In GTD, the horizons are defined as such:

- Ground :: the day-to-day
- Horizon 1 :: projects
- Horizon 2 :: areas of focus
- Horizon 3 :: 1-2 year goals
- Horizon 4 :: 3-5 year vision
- Horizon 5 :: purpose and principles

Obviously, Ground and Horizons 1 are handled by the "capture/clarify/organize/engage" flow we've already seen.

GTD recommends that you do not start using the horizons above Horizon 1 until you have both Ground and Horizon 1 under control. So, when you are ready...

**** Areas of focus
Horizon 2 is now handled by a variable and a hook you can add to ~org-gtd-organize-hooks~:
- ~org-gtd-areas-of-focus~ is a list of strings, each representing one of your areas of focus.
- ~org-gtd-set-area-of-focus~ is the hook you would add, e.g. ~(setq org-gtd-organize-hooks '(org-gtd-set-area-of-focus))~, it ensures each item you clarify will need to be part of a horizon.

You can then use the function ~org-gtd-review-area-of-focus~ to generate an agenda view to review a specific area of focus.

In order to add areas of focus to pre-existing items in your system, without going through the clarifying flow, we provide two functions:
- ~org-gtd-area-of-focus-set-on-item-at-point~, when you are on a org heading
- ~org-gtd-area-of-focus-set-on-agenda-item~, when you are on an agenda item

Do note that calling the function on item at point will trust you blindly to do the right thing, whereas setting the area of focus through the agenda will attempt to recognize if you are on a project task and thus set the category on the project itself instead of the task.

**** Longer-term horizons
The longer-term horizons can be stored in a file in the ~org-gtd-directory~. A variable governs the name of the file, ~org-gtd-horizons-file~, by default =horizons.org=.

At the moment it does not seem particularly useful to add any automation around these, since they will change so infrequently.

They are, however, useful to display.

A variable, ~org-gtd-clarify-show-horizons~, determines whether/where to display the side buffer while clarifying.

Regardless of the value of this variable, you can use the function ~org-gtd-clarify-toggle-horizons-window~ to display or hide the side window. If the above variable is nil, then the horizons window will be toggled on the right side of the screen.

*See also*:
- [[#config-vars-reference][Configuration Variables Reference]] for ~org-gtd-areas-of-focus~, ~org-gtd-horizons-file~, and ~org-gtd-clarify-show-horizons~
- [[#commands-reference][Commands Reference]] for all horizon-related commands
- [[#hooks-reference][Hooks Framework Reference]] for ~org-gtd-set-area-of-focus~ hook

** Working with Projects (Advanced)
:PROPERTIES:
:CUSTOM_ID: working-with-projects-advanced
:END:

You learned sequential projects in [[#tutorial-your-first-project][Tutorial: Your First Project]]. This section teaches you how to handle complex projects with parallel work streams, custom dependencies, and sophisticated project structures—all using visual project management.

*** Quick Navigation

This section covers:

- [[#graph-first-contact][Why Visual Project Management?]] - Understanding the motivation
- [[#graph-black-triangle][Your First Project Graph View]] - Get started in 30 seconds
- [[#graph-understanding-dependencies][Understanding Project Dependencies]] - Learn the DAG model
- [[#graph-tutorial-parallel][Tutorial: Parallel Tasks]] - Build your first complex project
- [[#graph-dependency-patterns][Common Dependency Patterns]] - Visual reference for typical structures
- [[#graph-view-command-reference][Graph View Command Reference]] - Complete command listing
- [[#graph-rendering-modes][Rendering Modes]] - SVG vs ASCII
- [[#graph-keyboard-reference][Complete Keyboard Reference]] - Quick reference card
- [[#graph-technical-details][Technical Details]] - Implementation and properties
- [[#graph-practical-tips][Practical Tips]] - When and how to use graph view
- [[#graph-troubleshooting][Troubleshooting]] - Common problems and solutions

*** First Contact: Why Visual Project Management?
:PROPERTIES:
:CUSTOM_ID: graph-first-contact
:END:

Real projects are rarely simple sequences. You might have:
- Tasks that can start simultaneously (parallel research streams)
- Multiple tasks that must all finish before the next step (convergence points)
- Independent work paths that later merge (diamond patterns)

Managing these mentally or through text properties is error-prone. You forget dependencies, create accidental bottlenecks, or miss opportunities for parallelization.

*Visual project management solves this.* You SEE your project as a dependency graph—boxes for tasks, arrows for dependencies, colors for states. Adding tasks, creating dependencies, and understanding project structure becomes intuitive and immediate.

*** Black Triangle: Your First Project Graph View
:PROPERTIES:
:CUSTOM_ID: graph-black-triangle
:END:

Let's see this in action right now.

**** Step 1: Find a project

Open your engage view: ~C-c d e~

Find any project task in your agenda (or create a quick test project if you don't have one).

**** Step 2: Open the graph view

Press ~RET~ on the project task to jump to the project heading.

Run: ~M-x org-gtd-show-project-graph~

**** Step 3: Explore

You're now looking at your project as a visual graph:
- The project heading is at the top
- Tasks are arranged in layers below
- Arrows show which tasks block other tasks
- Green boxes are NEXT (ready to work on)
- Gray boxes are TODO (waiting for dependencies)

Press ~?~ to see all available commands.

*Success!* You've visualized your first project. Everything from here builds on this.

*** Understanding Project Dependencies
:PROPERTIES:
:CUSTOM_ID: graph-understanding-dependencies
:END:

Before we build complex projects, let's understand how dependencies work visually.

**** The Dependency Graph (DAG)

Projects in org-gtd are *Directed Acyclic Graphs* (DAGs):

- *Directed* :: Dependencies have direction. If Task A blocks Task B, the arrow points from A → B. B can't start until A finishes.

- *Acyclic* :: No circular dependencies. A → B → C → A would create a deadlock. Org-gtd prevents these automatically.

- *Graph* :: Tasks can have multiple dependencies. Task C might need both A AND B to finish before it can start.

**** What You See in Graph View

The graph view arranges tasks in *layers*:

- *Layer 0*: Root tasks (no dependencies, can start immediately)
- *Layer 1*: Tasks blocked by layer 0
- *Layer 2*: Tasks blocked by layer 1
- And so on...

*Green boxes* (NEXT state) mean "ready to work on right now."
*Gray boxes* (TODO state) mean "blocked by dependencies."

When you complete a NEXT task, org-gtd automatically updates the graph:
- Completed task disappears (or grays out if you keep DONE tasks visible)
- Tasks that were waiting for it may turn green

**** Sequential vs Parallel vs Mixed

*Sequential* (default for new projects):
- Tasks execute one after another: A → B → C
- Only one task is NEXT at a time
- Simple, linear workflow

In graph view, sequential projects look like a vertical chain of boxes with arrows flowing downward.

*Parallel*:
- Multiple tasks can be NEXT simultaneously
- Multiple tasks at layer 0 (all root tasks)
- Faster project completion when tasks are independent

In graph view, parallel projects have multiple green boxes at the same layer.

*Mixed* (most real projects):
- Some tasks parallel, others sequential
- Example: Research and Planning happen together, but both must finish before Building starts

In graph view, mixed projects show parallel branches that converge at join points.

*** Tutorial: Parallel Tasks with Graph View
:PROPERTIES:
:CUSTOM_ID: graph-tutorial-parallel
:END:

Let's build a project where some tasks happen simultaneously.

**** The Scenario

You need to "Fix Shoulder Pain":
1. Find MRI facility (research task)
2. Make MRI appointment (depends on finding facility)
3. Make orthopedist appointment (independent research - parallel with 1 & 2)
4. Get diagnosis (depends on both appointments completing)

Tasks 1 and 3 can happen in parallel—they're independent research tasks.

**** Step 1: Capture and Organize

Capture the project: ~C-c d c~

#+begin_example
,* Fix Shoulder Pain
,** Find place to get MRI
,** Make MRI appointment
,** Make orthopedist appointment
,** Get diagnosis from orthopedist
#+end_example

Process the inbox: ~C-c d p~

Organize as a project: ~C-c c~ → ~[P]~

**** Step 2: Open Graph View

From the engage view (~C-c d e~), press ~RET~ on any task to jump to the project.

Run: ~M-x org-gtd-show-project-graph~

You'll see a sequential graph (the default):
#+begin_example
[Fix Shoulder Pain]
        ↓
[NEXT: Find place to get MRI]
        ↓
[TODO: Make MRI appointment]
        ↓
[TODO: Make orthopedist appointment]
        ↓
[TODO: Get diagnosis from orthopedist]
#+end_example

We need to make tasks 1 and 3 parallel.

**** Step 3: Add Orthopedist Appointment as Root Task

Click on (or navigate to) the "Find place to get MRI" task.

Press ~a r~ (add root task)

At the prompt, type: ~Make orthopedist appointment~

*Wait!* We already have that task. So instead, we'll restructure.

Actually, let's do this differently. We need to:
1. Make "Make orthopedist appointment" a root task (no dependencies)
2. Remove it from the sequential chain

*CURRENT LIMITATION*: The graph view can ADD tasks but can't MODIFY existing dependencies. So we'll build this from scratch using graph view commands.

**** Step 3 (Revised): Build with Graph View Commands

Let me show you the INTENDED workflow (this reveals what features are still needed):

1. Delete "Make orthopedist appointment" from the middle of the chain
2. Add it as a new root task
3. Make "Get diagnosis" depend on BOTH appointments

But our graph view doesn't have delete/modify yet. Let's note this and continue with what we CAN do.

**** What Graph View CAN Do Right Now

From the project heading in graph view:

- ~a c~ :: Add a child task (creates: selected task → new task)
- ~a r~ :: Add a root task (no dependencies, starts immediately)
- ~a b~ :: Add a blocker task (creates: new task → selected task)

Example: Building a parallel structure from scratch:

1. Start with project heading selected
2. ~a r~ → "Find place to get MRI"
3. ~a r~ → "Make orthopedist appointment" (now TWO root tasks!)
4. Select "Find place to get MRI"
5. ~a c~ → "Make MRI appointment"
6. Select "Make MRI appointment", ~a c~ → "Get diagnosis (MRI side)"
7. Select "Make orthopedist appointment", ~a c~ → "Get diagnosis (ortho side)"

But wait—we can't make ONE task depend on TWO tasks with current commands.

*THIS REVEALS A MISSING FEATURE.*

**** The Dependency Pattern (Diamond)

The pattern we want is called a "diamond":

#+begin_example
    Find MRI ─────┐
                  ├──→ Get Diagnosis
Make Ortho Appt ──┘
#+end_example

Two parallel paths converge at a single task.

**** Current Workaround

For now, to create complex convergence patterns, you would:
1. Use graph view to build the basic structure
2. Press ~r~ to refresh and verify
3. For convergence points (multiple tasks blocking one task), you need to either:
   - Structure the project differently
   - Wait for "modify dependency" commands to be implemented

*** Tutorial: Complex Dependencies with Graph View

**** The Scenario

"Release Next Version of Software":

1. List features (starting task)
2. Implement features (depends on list)
3. Write documentation (can start after list, parallel with implement)
4. Get beta tester feedback (depends on both implement AND documentation)
5. Update code based on feedback (depends on beta feedback)
6. Update documentation based on feedback (depends on beta feedback, parallel with code updates)
7. Release (depends on both updates completing)

**** The Dependency Graph

#+begin_example
List Features
    ├──→ Implement Features ───┐
    └──→ Write Documentation ───┼──→ Get Beta Feedback
                                │         ├──→ Update Code ─────┐
                                │         └──→ Update Docs ──────┼──→ Release
                                └───────────────────────────────┘
#+end_example

**** Building with Graph View

Starting from the project heading:

1. ~a r~ → "List features" (root task)
2. Select "List features"
3. ~a c~ → "Implement features" (depends on list)
4. Go back to "List features"
5. ~a c~ → "Write documentation" (also depends on list - now parallel!)

Now you have two parallel branches. Both are green (NEXT) because they only depend on the root task.

For the convergence at "Get Beta Feedback":
- Select "Implement features"
- ~a c~ → "Get Beta Feedback (from implement)"

*But we can't make it ALSO depend on "Write documentation" yet.*

*THIS REVEALS THE SAME MISSING FEATURE.*

**** Key Patterns This Example Shows

1. *Parallel branches* after List Features (we CAN do this with ~a c~ from same parent)
2. *Converging paths* at Get Beta Feedback (we CANNOT do this yet—needs "add as blocker to existing task")
3. *Parallel updates* after feedback (we CAN do this)
4. *Final convergence* at Release (we CANNOT do this yet)

*** Common Dependency Patterns (Visual Reference)
:PROPERTIES:
:CUSTOM_ID: graph-dependency-patterns
:END:

Here's what different patterns look like in graph view:

**** Sequential Chain (A → B → C)

#+begin_example
[A - NEXT]
    ↓
[B - TODO]
    ↓
[C - TODO]
#+end_example

*When to use*: Order matters, each task depends on the previous.

*How to build*: Start at project, ~a r~ for first task, then ~a c~ repeatedly.

*Example*: Review blueprints → Order windows → Schedule carpenter

**** Parallel Independent (A, B, C all start together)

#+begin_example
[A - NEXT]  [B - NEXT]  [C - NEXT]
#+end_example

*When to use*: Tasks are completely independent, all can start immediately.

*How to build*: From project heading, ~a r~ for each task.

*Example*: Research destinations, Check budget, Ask for time off (vacation planning)

**** Fan-out (A → B, A → C, A → D)

#+begin_example
        [A - NEXT]
       /    |    \
      ↓     ↓     ↓
  [B-TODO][C-TODO][D-TODO]
#+end_example

*When to use*: Initial work enables multiple independent paths.

*How to build*: ~a r~ for A, select A, then ~a c~ for B, C, D.

*Example*: Get project approval → (Design UI, Write backend API, Setup infrastructure)

**** Fan-in / Convergence (A → C, B → C)

#+begin_example
[A - NEXT]  [B - NEXT]
      \        /
       ↓      ↓
      [C - TODO]
#+end_example

*When to use*: Final task needs all previous work completed.

*How to build*: CANNOT BUILD YET—needs "multiple blockers" feature.

*Workaround*: Make A → C → ... and B → something-else for now.

*Example*: (Write code, Write tests) → Merge to main

**** Diamond (A → B → D, A → C → D)

#+begin_example
      [A - NEXT]
       /      \
      ↓        ↓
  [B-TODO] [C-TODO]
      \      /
       ↓    ↓
     [D-TODO]
#+end_example

*When to use*: Work splits, proceeds in parallel, then combines.

*How to build*: CANNOT BUILD YET—convergence at D needs multiple blockers.

*Example*: Research → (Write content, Design graphics) → Publish article

*** Graph View Command Reference
:PROPERTIES:
:CUSTOM_ID: graph-view-command-reference
:END:

This is the complete command reference for expert users.

*Most operations require the transient menu:* Press ~?~ to access all commands.

**** Opening Graph View

~M-x org-gtd-show-project-graph~

*Requires*: Point must be on a project heading (not a task), or will prompt for project selection

*Creates*: Interactive SVG buffer named ~*Org GTD Graph: <project-name>*~

**** Direct Keybindings (Always Available)

*Navigation:*

| Key     | Command                    | Description                                           |
|---------+----------------------------+-------------------------------------------------------|
| n / j   | Down dependency            | Move to a task this one blocks                        |
| p / k   | Up dependency              | Move to a task that blocks this one                   |
| TAB     | Next sibling               | Next task in same layer (same dependency depth)       |
| g       | Goto node                  | Jump to task by name (with completion)                |
| [       | Back                       | Navigate to previous node in history                  |
| ]       | Forward                    | Navigate to next node in history                      |
| RET     | Jump to task in org file   | Opens the org file at the task's location             |

*View:*

| Key   | Command          | Description                                                  |
|-------+------------------+--------------------------------------------------------------|
| ?     | Show menu        | Display transient menu with all commands                     |
| r     | Refresh          | Rebuild graph (use after external changes)                   |
| q     | Quit             | Close graph view, keep buffer                                |

**** Transient Menu Commands (Press ~?~ first)

*Add Operations (~a~ prefix):*

| Key   | Command          | Description                                                  |
|-------+------------------+--------------------------------------------------------------|
| a c   | Add child        | Create task that depends on selected task                    |
| a r   | Add root         | Create task with no dependencies (starts immediately)        |
| a b   | Add blocker      | Create task that blocks the selected task                    |
| a d   | Add dependency   | Add dependency between two tasks (supports convergence)      |

*After adding*: Graph automatically refreshes to show new task.

*Modify Operations:*

| Key   | Command                    | Description                                              |
|-------+----------------------------+----------------------------------------------------------|
| d     | Remove dependency          | Remove a dependency between two tasks                    |
| x     | Clear all relationships    | Clear all relationships from selected task               |

*Inspect:*

| Key   | Command                    | Description                                              |
|-------+----------------------------+----------------------------------------------------------|
| i     | Show relationships         | Display all relationships for selected task              |

*Other:*

| Key   | Command          | Description                                                  |
|-------+------------------+--------------------------------------------------------------|
| Q     | Quit and kill    | Close graph view and kill buffer                             |
| z     | Zoom             | Zoom/filter submenu (not yet implemented)                    |

**** Visual Indicators

- *Green boxes*: NEXT tasks (ready to work on)
- *Gray boxes*: TODO tasks (blocked by dependencies)
- *Arrows*: Dependencies (from blocker → blocked task)
- *Layers*: Vertical positioning shows dependency depth

**** Operations Not Available in Graph View

Some operations are standard org-mode functionality and must be done in the org file:

*Changing task properties*:
- TODO state: ~C-c C-t~ in org file
- Deadlines/schedules: ~C-c C-d~, ~C-c C-s~ in org file
- Task title/description: edit in org file
- Tags/properties: edit in org file

*Deleting tasks*: Mark task DONE or CNCL in the org file. Completed tasks still show in graph view (green boxes) to maintain project history.

*Access org file*: Press ~RET~ on any task in graph view to jump to it in the org file.

**** Text-Based Alternatives

Most users will find the graph view intuitive for dependency management. However, text-based task management commands are available:

- ~org-gtd-task-add-blockers~ - Add blockers via text interface
- ~org-gtd-task-remove-blockers~ - Remove blockers via text interface
- ~org-gtd-task-show-relationships~ - Display relationships in minibuffer
- ~org-gtd-validate-project-dependencies~ - Validate project structure

See [[#task-dependency-commands][Task Dependency Commands]] for details.

*** Graph Rendering Modes
:PROPERTIES:
:CUSTOM_ID: graph-rendering-modes
:END:

The graph view supports two rendering modes that you can toggle between at any time.

**** SVG Mode (Default)

High-quality graphical rendering with:
- Smooth curves for dependency arrows
- Anti-aliased text
- Visual polish
- Larger display area
- Better for GUI Emacs

Set as default with:
#+begin_src emacs-lisp
(setq org-gtd-graph-render-mode 'svg)
#+end_src

**** ASCII Mode

Text-based rendering using box-drawing characters:
- Works in terminal Emacs
- Accessible for screen readers
- Compact display
- No external dependencies
- Uses Unicode box-drawing glyphs

Set as default with:
#+begin_src emacs-lisp
(setq org-gtd-graph-render-mode 'ascii)
#+end_src

**** Toggling Modes

Press ~v~ while in graph view to toggle between SVG and ASCII rendering.

**** Troubleshooting ASCII Rendering

If ASCII rendering looks broken:
- Ensure your terminal supports UTF-8 box-drawing characters
- Try SVG mode (~v~ to toggle)
- Check that your font supports box-drawing glyphs
- Verify ~(char-displayable-p ?│)~ returns ~t~

*** Complete Keyboard Reference
:PROPERTIES:
:CUSTOM_ID: graph-keyboard-reference
:END:

This is a comprehensive quick reference for all graph view keybindings.

**** Navigation

| Key         | Action                                    |
|-------------+-------------------------------------------|
| ~?~         | Show command menu (transient)             |
| ~n~ / ~j~   | Down dependency (to task this blocks)     |
| ~p~ / ~k~   | Up dependency (to task that blocks this)  |
| ~TAB~       | Next sibling (same layer)                 |
| ~<backtab>~ | Previous sibling                          |
| ~<~         | First task in layer                       |
| ~>~         | Last task in layer                        |
| ~g~         | Go to task by name                        |
| ~[~         | Navigate back in history                  |
| ~]~         | Navigate forward in history               |

**** Modification (via transient menu ~?~)

| Key   | Action                              |
|-------+-------------------------------------|
| ~a a~ | Insert task AFTER selected (child)  |
| ~a b~ | Insert task BEFORE selected         |
| ~a r~ | Add root task (no dependencies)     |
| ~m b~ | Modify what blocks this task        |
| ~m a~ | Modify what this task blocks        |
| ~r~   | Remove task from project            |
| ~t~   | Change TODO state                   |

**** Information

| Key | Action                           |
|-----+----------------------------------|
| ~i~ | Show relationships for task      |
| ~e~ | Edit task in org file (jump to)  |
| ~RET~ | Jump to task in org file       |

**** View Control

| Key | Action                                |
|-----+---------------------------------------|
| ~v~ | Toggle ASCII/SVG rendering            |
| ~z~ | Zoom menu (filter/focus)              |
| ~R~ | Refresh graph (rebuild from org file) |
| ~q~ | Quit graph view                       |
| ~Q~ | Quit and kill buffer                  |

*** Auto-Refresh on File Changes

Graph view automatically watches the org file and refreshes when changes are detected (with 300ms debounce). This means:

- Changes in the org file appear in graph view automatically
- No need to manually refresh after external edits
- Multiple graph views of the same project stay in sync
- File watching is buffer-local and cleaned up on quit

You can still manually refresh with ~R~ if needed.

*** Technical Details
:PROPERTIES:
:CUSTOM_ID: graph-technical-details
:END:

**** Graph Data Structure

Projects are represented as *Directed Acyclic Graphs* (DAGs):

- *Directed*: Dependencies have direction (A blocks B, not vice versa)
- *Acyclic*: No circular dependencies (org-gtd prevents these)
- *Graph*: Tasks can have multiple blockers and multiple dependents

**** Layout Algorithm

The Sugiyama layout algorithm:
1. Assigns tasks to layers based on dependency depth
2. Minimizes edge crossings between layers
3. Centers nodes horizontally for visual balance
4. Calculates smooth curved arrows (SVG) or line-drawing characters (ASCII)

**** Properties Used

Graph view reads and writes these org properties:

- ~ORG_GTD_FIRST_TASKS~ (on project heading): Space-separated list of task IDs with no dependencies
- ~ORG_GTD_DEPENDS_ON~ (on tasks): Space-separated list of task IDs this task depends on
- ~ORG_GTD_BLOCKS~ (on tasks): Space-separated list of task IDs this task blocks
- ~ORG_GTD_PROJECT_IDS~ (on tasks): Space-separated list of project IDs this task belongs to

These properties maintain bidirectional consistency. When you add dependency A→B:
- A's ~ORG_GTD_BLOCKS~ includes B's ID
- B's ~ORG_GTD_DEPENDS_ON~ includes A's ID

You typically don't edit these properties directly—use graph view commands or the text-based alternatives.

**** Undo/Redo Support

Currently, undo/redo is not implemented in graph view. Graph modifications are immediately saved to the org file.

To undo changes:
- Switch to the org file buffer
- Use ~C-x u~ (undo) as normal
- The graph view will auto-refresh to show the reverted state

*** Practical Tips for Project Management
:PROPERTIES:
:CUSTOM_ID: graph-practical-tips
:END:

**** When to Use Graph View

- *Planning complex projects*: Visualize before committing to structure
- *Understanding stuck projects*: See why tasks are blocked
- *Weekly review*: Quick visual health check of all projects
- *Adding tasks mid-project*: Add with correct dependencies immediately

**** When to Use Sequential (Default)

- Order truly matters (can't install before purchasing)
- You're unsure what the next task will be until you complete current one
- The project is simple (3-4 tasks)
- You don't want to think about dependencies

*Just organize as project* (~C-c c~ → ~[P]~) and you're done.

**** When to Create Parallel Structures

- You have multiple people working on the project
- Tasks are independent and could be done in any order
- You want to optimize for speed
- You know all tasks upfront

*Use ~a r~ multiple times* from graph view to create parallel roots.

**** Managing Complexity

- *Start sequential, add parallel only when needed*: Don't over-engineer.
- *Use graph view to understand before modifying*: Visualize first.
- *Keep task names clear and specific*: "Research venues" not "Research"
- *Review stuck projects weekly*: ~M-x org-gtd-review-stuck-projects~

**** Growing Projects Over Time

As projects evolve, you need to add tasks:

- *New independent work stream*: ~a r~ (add root task)
- *Next step in sequence*: Select current task, ~a c~ (add child)
- *Prerequisite for existing task*: Select existing task, ~a b~ (add blocker)

After adding, press ~r~ to refresh the view.

*** Exporting Project Graphs
:PROPERTIES:
:CUSTOM_ID: graph-exporting
:END:

**** First Contact: What is Graph Export?

Graph export saves your project visualization as a file. Share project plans with teammates who don't use Emacs. Include project graphs in presentations or documentation. Process graphs with external tools like Graphviz.

Three export formats:
- *SVG*: High-quality graphics for documents and presentations
- *DOT*: Graphviz source for custom styling and layouts
- *ASCII*: Text-based diagrams for terminals and plain-text documentation

Who needs this? Anyone collaborating outside Emacs, creating documentation, or using graph analysis tools.

**** Tutorial: Export Your First Graph

Let's export a project graph in under 30 seconds:

1. Open any project in graph view: ~M-x org-gtd-show-project-graph~
2. Press ~?~ to open the command menu
3. Press ~E s~ to export as SVG
4. Choose a filename (e.g., ~project-plan.svg~)
5. Done! Open the file in any image viewer or web browser

The exported graph preserves your current view, including which task is selected (highlighted).

**** Progressive Learning: Choosing Export Formats

**Start with SVG** when you first need to export. It works everywhere—documents, presentations, web pages, email attachments. Your colleague can open it in any browser.

**Use DOT when you need control**. The DOT format is Graphviz's source language. Export to DOT when you want to:
- Change colors, fonts, or layout algorithms
- Combine multiple project graphs
- Generate different output formats (PNG, PDF, PostScript)
- Integrate with automated build systems

Process a DOT file with Graphviz:
#+begin_src bash
dot -Tpng project.dot -o project.png      # Convert to PNG
dot -Tpdf project.dot -o project.pdf      # Convert to PDF
neato -Tsvg project.dot -o custom.svg     # Different layout algorithm
#+end_src

**Use ASCII for text contexts**. ASCII export creates terminal-friendly diagrams. Use when:
- Writing plain-text documentation (README files)
- Sharing in chat or email where images don't work
- Reviewing projects over SSH without graphics
- Creating quick diagrams for code comments

Example ASCII output:
#+begin_example
Conference Planning
├─ Research venues
├─ Create budget
│  └─ Get quotes
└─ Book venue
#+end_example

**Handling large projects**: All formats work with complex graphs, but consider:
- SVG scales perfectly (zoom without quality loss)
- DOT can be processed with different layout algorithms for readability
- ASCII may become unwieldy with 20+ tasks (switch to SVG)

**** When Exports Differ from Display

The export reflects your current graph state. If you've selected a task (navigated with ~j~/~k~ or clicked), that task appears highlighted in the export.

To export without highlighting:
1. Press ~ESC~ to deselect the current task
2. Export with ~E s~, ~E d~, or ~E a~
3. The export shows all tasks unhighlighted

Changes you make in graph view are immediately saved to the org file, so exports always reflect the actual project structure.

**** Reference: Export Commands

From graph view (~M-x org-gtd-show-project-graph~), press ~?~ to open the menu, then:

| Key   | Command                       | Format | Best For                           |
|-------+-------------------------------+--------+------------------------------------|
| ~E s~ | ~org-gtd-graph-export-svg~    | SVG    | Documents, presentations, sharing  |
| ~E d~ | ~org-gtd-graph-export-dot~    | DOT    | Graphviz processing, customization |
| ~E a~ | ~org-gtd-graph-export-ascii~  | ASCII  | Terminals, plain-text docs         |

All commands prompt for a filename. The file is created immediately.

**** Troubleshooting Exports

**"No graph to export" error**: You must be in a graph view buffer. Open a project graph first with ~M-x org-gtd-show-project-graph~.

**Empty or corrupted file**:
- Verify the graph displays correctly before exporting
- Press ~R~ to refresh the graph view
- Try exporting to a different location with write permissions

**SVG won't open in browser**: Ensure the filename ends in ~.svg~. Most programs detect format by file extension.

**DOT processing fails**: Install Graphviz (~dot~ command) on your system. The DOT file is plain text—open it in any editor to verify its contents.

*** Troubleshooting Projects with Graph View
:PROPERTIES:
:CUSTOM_ID: graph-troubleshooting
:END:

**** Project is Stuck (has TODO tasks but no NEXT)

Run ~M-x org-gtd-review-stuck-projects~ to find stuck projects.

Open the stuck project in graph view: ~M-x org-gtd-show-project-graph~

*What to look for*:
- *No green boxes?* All tasks might be waiting for dependencies that are DONE. Press ~r~ to refresh.
- *Gray boxes at layer 0?* These should be green (root tasks are never blocked). Something's wrong with the dependency structure.
- *Circular dependency?* Org-gtd prevents these, but if you see arrows forming a loop, you've found a bug.

*How to fix*:
- Use graph view to understand the structure
- Add a new root task (~a r~) if nothing can start
- Refresh (~r~) after any changes

**** Task Should Be NEXT But Shows as TODO

In graph view, look at the task:
- Is it gray (TODO)?
- Trace arrows pointing TO it—these are its blockers
- Are all those blockers green? Then something's wrong.
- Are some blockers gray? Then the task is correctly blocked.

If blockers are actually DONE but still showing as green, press ~r~ to refresh.

*How to fix*: Use ~d~ to remove incorrect dependencies, or ~x~ to clear all relationships for a task and rebuild.

**** Too Many Tasks Are NEXT

In graph view:
- Count green boxes
- If you have 10+ green tasks, you probably have dependency problems
- Some tasks should depend on others but don't

*How to fix*:
- Select a task that should be blocked
- Press ~a b~ to add a blocker task
- Or restructure: tasks later in the workflow should be children (~a c~) of earlier tasks

**** Graph Won't Open

If ~M-x org-gtd-show-project-graph~ doesn't work:

- Verify you're on a project heading (not a task heading)
- Check that the heading has ~ORG_GTD~ property set to "Projects"
- Try explicitly: ~M-x org-gtd-show-project-graph~
- Check for errors in ~*Messages*~ buffer

**** Graph Shows No Tasks

If the graph opens but shows no tasks:

- Check if the project has subtasks (tasks should be subheadings under the project)
- Verify tasks have ~ORG_GTD_PROJECT_IDS~ property containing the project ID
- Press ~R~ to force a complete refresh
- Check ~*Messages*~ buffer for parsing errors

**** Task Shows Wrong State (NEXT vs TODO)

If a task's color doesn't match its expected state:

- Press ~R~ to refresh (state might be stale from external edits)
- Check the task's actual TODO state in the org file (press ~e~ to jump there)
- Verify dependencies are correct (press ~i~ to inspect relationships)
- Look for completed tasks that haven't been refreshed

**** Can't Modify Dependencies

If modification commands don't work:

- Ensure a task is selected (should see highlighted box)
- Press ~?~ to verify commands are available in the transient menu
- Check that you're in the graph view buffer, not the org file buffer
- Try ~R~ to refresh if the graph is in an inconsistent state

*** See Also

- [[#tutorial-your-first-project][Tutorial: Your First Project]] for sequential project basics
- [[#properties-reference][Properties Reference]] for ~ORG_GTD_FIRST_TASKS~, ~ORG_GTD_DEPENDS_ON~, and ~ORG_GTD_BLOCKS~ (internal implementation)
- [[#commands-reference][Commands Reference]] for all project management commands
- [[#view-dsl-reference][View DSL Filter Reference]] for creating custom project views
*** Incubating Projects: Pausing Work You're Not Ready For
:PROPERTIES:
:CUSTOM_ID: incubating-projects
:END:

**** First Contact: Why Incubate Projects?

You're managing 15 active projects. Some are ready to work on NOW. Others are good ideas, but wrong timing—maybe you're waiting for budget approval, or team availability, or just aren't ready to commit yet.

Keeping them all visible in your engage view creates noise. You scan past 10 "someday" projects to find the 5 you can actually work on today. That's cognitive load you don't need.

*Incubating projects solves this.* Pause a project with a review date. It disappears from your engage view, your NEXT lists, everywhere—but preserves the complete project structure (all tasks, dependencies, planning work). When the review date arrives or you're ready, reactivate it with one command. The project springs back to life exactly as you left it.

For GTD users managing multiple projects where some need to be dormant temporarily.

**** Black Triangle: Incubate Your First Project in 30 Seconds

Let's incubate a project right now.

*Step 1: Find a project you're not ready for*

Open graph view for any project: ~M-x org-gtd-show-project-graph~

Or navigate to any project heading in your GTD file.

*Step 2: Incubate it*

Press ~I~ in graph view, or run ~M-x org-gtd-incubate~

Enter a review date when prompted: ~2025-06-01~

*Step 3: Verify it's gone*

Open your engage view: ~C-c d e~

The project's tasks are GONE from your NEXT list. No clutter.

*Step 4: Check your review date*

The incubated project will appear in your agenda on 2025-06-01 as a reminder to reconsider it.

*Success!* You've paused a project without losing any of your planning work.

**** Understanding Incubation: What Actually Happens

When you incubate a project, org-gtd performs several operations to make it completely invisible while preserving state:

*State Preservation*

For the project heading and every task:
- Current ~ORG_GTD~ property → saved to ~PREVIOUS_ORG_GTD~ (e.g., "Projects" → "Projects")
- Current TODO keyword → saved to ~PREVIOUS_TODO~ property (e.g., "NEXT" → "NEXT")
- ~ORG_GTD~ property → set to "Incubated"
- TODO keyword → cleared completely (becomes nil)

**Why clear keywords?** This makes incubated tasks invisible to all views naturally. Your engage view shows ~(todo . "NEXT")~—tasks with no keywords don't match, so they disappear automatically.

*Review Date Storage*

The review date is stored in the project heading's ~ORG_GTD_TIMESTAMP~ property as ~<2025-06-01>~. This makes the project appear in your org-agenda on that date, just like delegated items or calendar events.

*Dependency Preservation*

ALL dependency relationships (~ORG_GTD_DEPENDS_ON~, ~ORG_GTD_BLOCKS~) remain intact. They're dormant—they don't affect anything while incubated—but they're there. When you reactivate, dependencies work exactly as before.

*Multi-Project Tasks*

If a task belongs to MULTIPLE projects (has multiple IDs in ~ORG_GTD_PROJECT_IDS~), it is NOT incubated. Why? Because it's still needed by other active projects.

You'll see: "Skipping multi-project task: Task Name"

The task remains active with its TODO keyword intact.

**** Tutorial: Managing Seasonal Projects

Let's walk through a realistic scenario: you have annual projects that you only work on during specific seasons.

*The Problem*

You're tracking these projects:
- "Annual Review Process" (only relevant December-January)
- "Summer Conference Planning" (only relevant May-August)
- "Q4 Budget Proposals" (only relevant September-November)

It's March. None of these are relevant, but they clutter your project list and NEXT tasks keep appearing in your engage view.

*The Solution: Incubate Until Needed*

In March, incubate all three:

1. Navigate to "Summer Conference Planning"
2. ~M-x org-gtd-incubate~
3. Review date: ~2025-05-01~
4. Repeat for other seasonal projects with appropriate dates

Your engage view is now clean—only projects you can work on THIS MONTH.

*When Review Dates Arrive*

On May 1st, "Summer Conference Planning" appears in your agenda:

#+begin_example
Tuesday 1 May 2025
  Summer Conference Planning (review incubated project)
#+end_example

Options:
- *Ready to activate?* Press ~RET~ to jump to it, then ~M-x org-gtd-reactivate~
- *Still not ready?* Leave it incubated, or re-incubate with a later date

*Reactivation Details*

When you run ~org-gtd-reactivate~:

1. State restoration happens automatically:
   - ~PREVIOUS_ORG_GTD~ → ~ORG_GTD~ (Incubated → Projects)
   - ~PREVIOUS_TODO~ → TODO keywords restored
   - ~ORG_GTD_TIMESTAMP~ removed (no longer in agenda)

2. Dependency recalculation runs:
   - ~org-gtd-projects-fix-todo-keywords~ examines all dependencies
   - Tasks with satisfied dependencies → marked NEXT
   - Tasks still blocked → remain TODO

3. Project graph opens automatically:
   - Review the project structure
   - Verify NEXT/TODO states make sense
   - Make any needed adjustments (~a~, ~d~, ~r~ keys)

**** Common Patterns and Scenarios

*Pattern: "Not Now, But Someday"*

Project ideas that might happen eventually:

#+begin_example
"Rewrite legacy authentication system"
"Migrate to new CRM platform"
"Redesign company website"
#+end_example

*Strategy:*
- Incubate with a FAR future date (2026-01-01)
- Or use quarterly review dates (2025-07-01, 2025-10-01, etc.)
- When review arrives, ask: "Is this the right time?" If no, re-incubate for next quarter

*Pattern: "Waiting for External Factor"*

Projects blocked by external dependencies:

#+begin_example
"Launch new product" (waiting for legal approval)
"Office redesign" (waiting for budget committee meeting on May 15th)
"Implement new API" (waiting for vendor release)
#+end_example

*Strategy:*
- Incubate with review date = when you expect the blocker to clear
- Add note in project heading: "Incubated because: waiting for budget approval"
- When reactivated, first task might be "Check if budget was approved"

*Pattern: "Quarterly Batch Projects"*

Projects you tackle in batches:

#+begin_example
"Review expenses" (quarterly)
"Update documentation" (quarterly)
"Audit security" (quarterly)
#+end_example

*Strategy:*
- After completing Q1 batch, incubate with Q2 start date
- Review dates: 2025-04-01, 2025-07-01, 2025-10-01, 2026-01-01
- Consistent rhythm without manual tracking

*Pattern: "Collaborative Project, Waiting for Team"*

Project requires specific people who aren't available:

#+begin_example
"Marketing campaign redesign" (designer on vacation until June)
"Code refactoring sprint" (waiting for team to finish current release)
#+end_example

*Strategy:*
- Incubate with return/availability date
- In project heading, note: "Incubated: waiting for Sarah (back June 10th)"
- Reactivate when team is available, project structure intact

**** Advanced: External Dependencies and Warnings

*What Are External Dependencies?*

Imagine:
- Project A has "Task A1: Research vendor options"
- Project B (separate project) has "Task B1: Evaluate vendors" that depends on Task A1 completing

Task B1 has an *external dependency*—it depends on a task from a different project.

*What Happens When Incubating*

If you incubate Project A, org-gtd warns you:

#+begin_example
External tasks depend on this project:
  - Task B1: Evaluate vendors (in Project B)

Continue incubating? (y/n)
#+end_example

**Why warn?** Incubating Project A clears Task A1's TODO keyword. Task B1 is still expecting Task A1 to be NEXT or TODO. This creates a "dangling reference"—B1 is blocked by a task that doesn't exist in active work anymore.

**Your options:**

1. *Cancel incubation* (~n~): Don't incubate Project A yet. Maybe restructure dependencies first.

2. *Continue anyway* (~y~): Accept that Task B1 will stay TODO/blocked until you reactivate Project A. Make a note in Project B about this.

3. *Remove the dependency*: Before incubating, use graph view to remove the B1 → A1 dependency link. Decide if B1 should proceed independently.

*Real-World Example*

You're planning a conference (Project Conference) with these tasks:
- Book venue
- Invite speakers
- Set up registration

A separate project (Project Marketing) has:
- "Design conference branding" → depends on "Book venue" (need venue details for design)

If you incubate Project Conference (venue not booked yet, conference might not happen), the warning shows you that Marketing's branding task will be stuck.

*Decision:* You might realize the branding task should just wait in Project Marketing with a note "start when conference is confirmed", rather than having a hard dependency. Remove the link before incubating.

**** Technical Details: How Incubation Works Under the Hood

*Property-Based State Management*

Incubation uses properties, not file movement. The project and its tasks stay in the same file, same location. Only properties change:

Before incubation (Task 1 of a project):
#+begin_example
*** NEXT Task 1: Research options
:PROPERTIES:
:ID: task-1-id
:ORG_GTD: Actions
:ORG_GTD_PROJECT_IDS: project-id
:ORG_GTD_DEPENDS_ON:
:ORG_GTD_BLOCKS: task-2-id
:END:
#+end_example

After incubation:
#+begin_example
*** Task 1: Research options
:PROPERTIES:
:ID: task-1-id
:ORG_GTD: Incubated
:PREVIOUS_ORG_GTD: Actions
:PREVIOUS_TODO: NEXT
:ORG_GTD_PROJECT_IDS: project-id
:ORG_GTD_DEPENDS_ON:
:ORG_GTD_BLOCKS: task-2-id
:END:
#+end_example

Note:
- TODO keyword cleared (was NEXT, now nothing)
- ~ORG_GTD~ changed to "Incubated"
- Original values saved in ~PREVIOUS_*~ properties
- Dependencies (~ORG_GTD_BLOCKS~) preserved unchanged

*View Filtering Mechanism*

Why don't incubated tasks appear in views?

Most views filter by TODO keywords: ~(todo . "NEXT")~, ~(todo . "TODO|NEXT|WAIT")~, etc.

Since incubated tasks have NO TODO keyword (cleared to nil), they don't match these filters. Natural exclusion.

For area-of-focus reviews that show projects, we filter: ~(and (property "ORG_GTD" "Projects") (property "CATEGORY" "Work"))~

Incubated projects have ~(property "ORG_GTD" "Incubated")~ instead of "Projects", so they appear in a separate "Incubated projects" section.

*Reactivation Dependency Recalculation*

When you reactivate, here's the exact sequence:

1. *Restore properties* (for project heading + all tasks):
   - ~PREVIOUS_ORG_GTD~ → ~ORG_GTD~
   - ~PREVIOUS_TODO~ → TODO keyword
   - Delete ~PREVIOUS_*~ properties
   - Delete ~ORG_GTD_TIMESTAMP~

2. *Recalculate NEXT/TODO states*:
   - Call ~org-gtd-projects-fix-todo-keywords~
   - This traverses the dependency graph breadth-first
   - For each task: if ALL dependencies are DONE/CNCL → mark NEXT
   - Otherwise → mark TODO

3. *Open graph view* (if interactive):
   - Shows the reactivated project visually
   - User can verify states, adjust dependencies
   - Immediate feedback on project structure

**Why recalculate?** You might have manually edited the project while incubated—added tasks, changed dependencies, marked some DONE. Recalculation ensures consistent state.

*Multi-Project Task Detection*

The check:
#+begin_src elisp
(let ((project-ids (org-entry-get-multivalued-property
                     (point) "ORG_GTD_PROJECT_IDS")))
  (if (> (length project-ids) 1)
      ;; Skip this task - belongs to multiple projects
      (message "Skipping multi-project task: %s" (org-get-heading))
    ;; Normal incubation
    ...))
#+end_src

If ~ORG_GTD_PROJECT_IDS~ contains ~"project-a project-b"~ (two IDs), the task belongs to both projects. Incubating one project shouldn't hide the task—it's still needed by the other project.

**** Troubleshooting Incubation

*Tasks Still Showing After Incubating Project*

*Symptom:* You incubated a project, but some of its tasks still appear in your engage view.

*Diagnosis:* Check if those tasks belong to multiple projects:
1. Navigate to the task
2. ~C-c C-x p~ (show properties)
3. Look at ~ORG_GTD_PROJECT_IDS~ value
4. If it has multiple IDs (space-separated), the task is shared

*Solution:* This is expected behavior. Multi-project tasks remain active because other projects need them. Options:
- Incubate ALL projects the task belongs to (task will then be incubated)
- Remove the task from one of the projects first
- Accept that the task stays visible (it's genuinely active in another project)

*Incubated Project Doesn't Appear on Review Date*

*Symptom:* Review date arrived (e.g., June 1st), but the project doesn't show in your agenda.

*Diagnosis:*
1. Navigate to the project heading
2. Check for ~ORG_GTD_TIMESTAMP~ property
3. Verify format is ~<2025-06-01>~ (angle brackets, YYYY-MM-DD)
4. Check your org-agenda-files includes the GTD file

*Solution:*
- If property is missing: re-incubate with a date
- If format is wrong: manually fix to ~<YYYY-MM-DD>~
- If file not in agenda: ~M-x org-agenda-file-to-front~ while in the GTD file

*Reactivated Project Has Wrong NEXT/TODO States*

*Symptom:* After reactivating, tasks that should be NEXT are showing as TODO, or vice versa.

*Diagnosis:* Open graph view (~M-x org-gtd-show-project-graph~):
- Trace arrows (dependencies)
- Check if dependencies are actually DONE
- Look for tasks with cleared keywords that should have keywords

*Solution:*
- Press ~r~ to refresh and recalculate states
- If recalculation doesn't fix it: dependencies might be incorrect
- Use ~d~ to modify dependencies, then ~r~ to recalculate

*Can't Reactivate: "Not Incubated" Error*

*Symptom:* Running ~org-gtd-reactivate~ gives error: "Item at point is not incubated"

*Diagnosis:* Check the ~ORG_GTD~ property:
1. ~C-c C-x p~ to show properties
2. Look for ~ORG_GTD~ value
3. Should be "Incubated"

*Solution:*
- If ~ORG_GTD~ is something else (e.g., "Projects"): it's not incubated, nothing to reactivate
- If manually edited: set ~ORG_GTD~ back to "Incubated" or just manually restore the state
- If ~PREVIOUS_*~ properties are missing: you'll need to manually set states

**** See Also

- [[#commands-reference][Commands Reference]] for ~org-gtd-incubate~ and ~org-gtd-reactivate~ full command details
- [[#tutorial-your-first-project][Tutorial: Your First Project]] for project basics before incubating
- [[#graph-first-contact][Why Visual Project Management?]] for understanding project structure
- [[#properties-reference][Properties Reference]] for ~PREVIOUS_ORG_GTD~, ~PREVIOUS_TODO~, ~ORG_GTD_TIMESTAMP~ details

*** Project Progress Cookies: See Your Progress at a Glance
:PROPERTIES:
:CUSTOM_ID: project-progress-cookies
:END:

**** First Contact: What Are Progress Cookies?

Progress cookies show how far along your project is: ~[3/7][42%]~ means 3 of 7 tasks done.

They appear directly on project headings, so you can scan your project list and instantly know which projects are nearly complete, which are just starting, and which might need attention.

*Who needs this?* Anyone managing multiple projects who wants quick visual feedback without opening each project to count tasks.

**** Black Triangle: See Progress in 30 Seconds

Your projects already have progress cookies—they're enabled by default.

1. Open your engage view: ~C-c d e~
2. Find any project task
3. Press ~RET~ to jump to the project heading

You'll see something like:

#+begin_example
,* PROJ Buy a house [0/5][0%]                      :home:
#+end_example

That's it. The ~[0/5][0%]~ shows 0 of 5 tasks completed.

**** Tutorial: Watch Cookies Update Automatically

Let's see progress cookies in action:

1. *Find a project with tasks:*
   - Open engage view: ~C-c d e~
   - Navigate to a project task, press ~RET~ to go to the project heading
   - Note the current cookie: ~[0/3][0%]~ (or similar)

2. *Complete a task:*
   - Find a NEXT task in that project
   - Mark it done: ~C-c C-t DONE~ (or cycle to DONE)

3. *Check the project heading:*
   - Scroll up to the project heading
   - The cookie updated: ~[1/3][33%]~

No manual refresh needed. Complete tasks, cookies update automatically.

**** Understanding How Cookies Work

**What gets counted?**

Progress cookies count all tasks linked to the project via ~ORG_GTD_PROJECT_IDS~. This is different from org-mode's built-in ~[/]~ cookies which only count direct children.

Why does this matter? In org-gtd v4, projects are DAGs (directed acyclic graphs)—tasks can live anywhere in your GTD files and link to projects by ID. The cookie counts ALL linked tasks, regardless of where they're located in your files.

**When do cookies update?**

- *Task state changes:* Complete a task → cookie updates immediately
- *Project creation:* New projects get cookies automatically
- *Manual refresh:* ~M-x org-gtd-project-update-all-cookies~ refreshes everything
- *Fix TODO keywords:* ~M-x org-gtd-projects-fix-all-todo-keywords~ also refreshes cookies

**** Configuring Cookie Position

Control where cookies appear with ~org-gtd-project-progress-cookie-position~:

#+begin_src emacs-lisp
;; At end of heading, before tags (default)
(setq org-gtd-project-progress-cookie-position 'end)

;; After TODO keyword, before title
(setq org-gtd-project-progress-cookie-position 'start)

;; Disable cookies entirely
(setq org-gtd-project-progress-cookie-position nil)
#+end_src

Visual comparison:

#+begin_example
;; 'end (default):
,* PROJ Buy a house [3/7][42%]                    :home:

;; 'start:
,* PROJ [3/7][42%] Buy a house                    :home:

;; nil:
,* PROJ Buy a house                               :home:
#+end_example

**** Common Scenarios

**Cookies look wrong after external edits**

You edited tasks outside org-gtd (mobile app, manual edit) and cookies don't match reality.

*Fix:* ~M-x org-gtd-project-update-all-cookies~

This scans all projects and recalculates from scratch.

**Want to disable cookies for performance**

If you have hundreds of projects and notice slowness:

#+begin_src emacs-lisp
(setq org-gtd-project-progress-cookie-position nil)
#+end_src

Cookies won't update or display.

**Cookies showing 0/0**

This means no tasks are linked to the project. Either:
- The project has no tasks yet (add some)
- Tasks don't have ~ORG_GTD_PROJECT_IDS~ pointing to this project (check properties)

**** Technical Reference

**Format:** ~[completed/total][percent%]~

**Calculation:** Scans all headings with ~ORG_GTD_PROJECT_IDS~ matching the project's ID. Counts tasks with TODO keyword in ~org-done-keywords~ as completed.

**Storage:** Actual text on the heading (not computed at display time). This means cookies persist and are visible even in non-Emacs editors.

**Hook:** ~org-after-todo-state-change-hook~ triggers recalculation when task states change.

**Related commands:**
- ~org-gtd-project-update-all-cookies~ :: Refresh all project cookies
- ~org-gtd-projects-fix-all-todo-keywords~ :: Fixes keywords AND refreshes cookies

*See also:* [[#org-gtd-project-progress-cookie-position][~org-gtd-project-progress-cookie-position~]] in Configuration Variables Reference.

*** Cleaning up / archiving completed work
:PROPERTIES:
:CUSTOM_ID: cleaning-up-the-system
:END:
Doing this without user intervention is tricky, as it makes undoing actions more complicated. As such, Org GTD provides a function that will go through the ~org-gtd-directory~ files, find the headings that belong to Org GTD (see [[#refiling-after-organizing][Refiling to the appropriate area]]), and archive the finished items.

The variable ~org-gtd-archive-location~ points to a *function* that returns a string matching the ~org-archive-location~ definition. It is a function in order to allow the filename to be dynamic.

The function to archive everything is ~M-x org-gtd-archive-completed-items~.
*** Commands you can call on org-agenda
Since Org provides the agenda, it is a convenient base of operations for interacting with things that come up through ~org-gtd-engage~.

Here are the actions available to you:

- ~M-x org-gtd-delegate-agenda-item~ :: When the point is on an action, this will properly delegate the action to someone else.
- ~M-x org-gtd-project-cancel-from-agenda~ :: When the point is on a project action, this command will cancel the remaining actions in the project.
- ~M-x org-gtd-clarify-agenda-item~ :: If you would like to clarify and organize an item through the agenda view, for whatever reason, this is your entry point.

*** Defining your own agenda views
You can define your own agenda views by defining functions with custom agenda commands. As long as you have ~org-gtd-directory~ in your ~org-agenda-files~ (required for org-gtd to work), your views will include GTD items automatically.

#+begin_src elisp
  (defun my-agenda ()
    (let ((org-agenda-custom-commands '(your-definition-here)))
      (org-agenda nil "x")))
#+end_src

Where =x= is whatever your defined key is.

*See also*: For a much easier way to create custom views, see [[#view-dsl-reference][View DSL Filter Reference]], which provides a declarative language for defining views without writing skip functions.
*** Adding your own hooks when organizing
:PROPERTIES:
:CUSTOM_ID: hooks-framework
:END:
Adding useful metadata to the tasks allows you to enhance the agenda view to make it more useful to you, whether it be effort, tags, priority, or any other amount of information you might like.

This being said, different types of tasks or items are not even created equal. For instance, there may be metadata you want to add to a project heading but not its tasks, or to a calendar item and not to a trash item.

Org GTD therefore provides a helper function, ~org-gtd-organize-type-member-p~, which you can use when creating your own hooks. The function takes one argument, a list of types (provided in the function's documentation).
When called as part of a hook, this function will check a buffer-local variable called ~org-gtd--organize-type~, managed by Org GTD, to determine truthiness.

For an example, see the source code for ~org-gtd-areas-of-focus--set~, which will not run if the task being organized is a project task, trash, knowledge, or a quick action.

*See also*: For complete documentation on the hooks framework, including many examples and best practices, see [[#hooks-reference][Hooks Framework Reference]].
** Automating through emacs
There's now a few functions you can use when you are doing work within emacs and would like GTD to track something for you as a result:
- ~org-gtd-habit-create~
- ~org-gtd-calendar-create~
- ~org-gtd-delegate-create~
- ~org-gtd-incubate-create~
- ~org-gtd-single-action-create~

See the documentation for each, but suffice it to say they all take, at the very least, a string that will be used as the text part of the org heading that gets stored in org-gtd.

For instance, one way this could work:

#+begin_src emacs-lisp
  (defun org-gtd-email-reminder ()
    (let ((topic (message-fetch-field "subject"))
          (delegated-to (message-fetch-field "to"))
          (reminder-date (org-read-date nil nil "+3d")))
      (org-gtd-delegate-create (format "Reminder: %s" topic)
                               delegated-to
                               reminder-date)))

  (add-hook 'message-send-hook 'org-gtd-email-reminder)
#+end_src

*See also*: [[#commands-reference][Commands Reference]] for complete documentation of all programmatic creation commands.

* Reference
:PROPERTIES:
:DESCRIPTION: Complete reference for all org-gtd features
:CUSTOM_ID: reference
:END:

This section provides complete reference documentation for all org-gtd configuration variables, commands, properties, and advanced features. Use this section when you need to look up specific details about a configuration option, command, or property.

*Quick navigation*:
- [[#config-vars-reference][Configuration Variables Reference]] - All customization options
- [[#commands-reference][Commands Reference]] - All interactive commands organized by workflow step
- [[#properties-reference][Properties Reference]] - All org properties used by org-gtd
- [[#view-dsl-reference][View DSL Filter Reference]] - Complete guide to creating custom views
- [[#hooks-reference][Hooks Framework Reference]] - Complete guide to customization hooks

For learning how to use org-gtd, start with [[#getting-started][Getting Started with Org GTD]] and [[#using-org-gtd][Using Org GTD]].

** Configuration Variables Reference
:PROPERTIES:
:DESCRIPTION: All customization variables explained
:CUSTOM_ID: config-vars-reference
:END:

These variables control how org-gtd behaves. All can be customized via ~M-x customize-group RET org-gtd~.

*** Required Configuration

**** ~org-todo-keywords~ (org-mode variable)

*Type*: List of keyword sequences

*Default*: Varies by org-mode installation

*Description*: Defines TODO keyword sequences for org-mode. All GTD keywords must be in the *same sequence*.

*Required format*:
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
#+end_src

The ~|~ separator marks done states (right side) from active states (left side).

**** ~org-gtd-keyword-mapping~

*Type*: Alist mapping GTD states to keyword strings

*Default*:
#+begin_src emacs-lisp
'((todo . "TODO")
  (next . "NEXT")
  (wait . "WAIT")
  (canceled . "CNCL"))
#+end_src

*Description*: Maps GTD semantic states to your chosen TODO keywords.

*Required keys*:
- ~todo~ :: Tasks not ready to be acted upon
- ~next~ :: Tasks ready to act on immediately
- ~wait~ :: Tasks blocked or delegated to someone else
- ~done~ :: Tasks successfully completed
- ~canceled~ :: Tasks that won't be completed

*Example*: Using custom keywords:
#+begin_src emacs-lisp
(setq org-todo-keywords
      '((sequence "TASK" "DOING" "BLOCKED" "|" "COMPLETE" "CANCELLED")))

(setq org-gtd-keyword-mapping
      '((todo . "TASK")
        (next . "DOING")
        (wait . "BLOCKED")
        (done . "COMPLETE")
        (canceled . "CANCELLED")))
#+end_src

*** Directory and File Configuration

**** ~org-gtd-directory~

*Type*: String (directory path)

*Default*: ~"~/gtd/"~

*Description*: Directory where org-gtd keeps all its files.

org-gtd will look for all its files in this directory:
- ~inbox.org~ - Capture target
- ~org-gtd-tasks.org~ - Main GTD file
- ~org-gtd-incubate.org~ - Someday/maybe items
- ~org-gtd-calendar.org~ - Calendar items

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-directory "~/my-gtd/")
#+end_src

*Note*: Make sure to add this directory to ~org-agenda-files~:
#+begin_src emacs-lisp
(setq org-agenda-files (list org-gtd-directory))
#+end_src

**** ~org-gtd-horizons-file~

*Type*: String (filename)

*Default*: ~"horizons.org"~

*Description*: Name of file (in ~org-gtd-directory~) containing your GTD horizons (long-term goals, areas of focus, purpose).

This file can be displayed during clarification for context.

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-horizons-file "my-horizons.org")
#+end_src

*** Capture Configuration

**** ~org-gtd-capture-templates~

*Type*: List of org-capture template specifications

*Default*:
#+begin_src emacs-lisp
'(("i" "Inbox"
   entry  (file ,#'org-gtd-inbox-path)
   "* %?\n%U\n\n  %i"
   :kill-buffer t)
  ("l" "Inbox with link"
   entry  (file ,#'org-gtd-inbox-path)
   "* %?\n%U\n\n  %i\n  %a"
   :kill-buffer t))
#+end_src

*Description*: Capture templates specific to org-gtd inbox.

*Constraints* (must be satisfied for org-gtd to work correctly):
1. Template string must start with ~"* "~ (asterisk + space for org heading)
2. Entry type must be: ~entry (file ,#'org-gtd-inbox-path)~

*Example*: Adding a custom template:
#+begin_src emacs-lisp
(setq org-gtd-capture-templates
      '(("i" "Inbox"
         entry (file ,#'org-gtd-inbox-path)
         "* %?\n%U\n\n  %i"
         :kill-buffer t)
        ("m" "Meeting note"
         entry (file ,#'org-gtd-inbox-path)
         "* Meeting: %?\n%U\n\nAttendees:\n\nNotes:\n"
         :kill-buffer t)))
#+end_src

*** Organize and Process Configuration

**** ~org-gtd-organize-hooks~

*Type*: List of functions

*Default*: ~'(org-set-tags-command)~

*Description*: Functions run when organizing each item. Each function can add metadata (tags, properties, etc.) to the item being organized.

The default value prompts for tags. Built-in options:
- ~org-set-tags-command~ :: Prompt for tags (default)
- ~org-gtd-set-area-of-focus~ :: Prompt for area of focus
- Custom functions :: Functions you write yourself

*Example*: Add effort estimation and area of focus:
#+begin_src emacs-lisp
(defun my-add-effort ()
  "Prompt for effort when organizing."
  (when (org-gtd-organize-type-member-p '(action project))
    (org-set-effort)))

(setq org-gtd-organize-hooks
      '(org-set-tags-command
        org-gtd-set-area-of-focus
        my-add-effort))
#+end_src

*Helper function*: ~org-gtd-organize-type-member-p~
- Takes a list of item types to check against
- Returns t if current item matches one of the types
- Available types: ~action~, ~project~, ~project-task~, ~calendar~, ~delegate~, ~incubate~, ~habit~, ~knowledge~, ~quick~, ~trash~

**** ~org-gtd-save-after-organize~

*Type*: Boolean

*Default*: ~nil~

*Description*: If non-nil, save all modified buffers after each organize step.

Useful if you want automatic saves during inbox processing.

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-save-after-organize t)
#+end_src

**** ~org-gtd-refile-to-any-target~

*Type*: Boolean

*Default*: ~t~

*Description*: Control refile behavior when organizing items.

- When ~t~: org-gtd will refile to the first target it finds, or create a target if necessary, without confirmation
- When ~nil~: org-gtd will ask for confirmation regardless of number of options

*Example*: Require manual refile target selection:
#+begin_src emacs-lisp
(setq org-gtd-refile-to-any-target nil)
#+end_src

**** ~org-gtd-use-refile-system~

*Type*: Boolean

*Default*: ~t~

*Description*: Whether to use org-gtd's refile system or standard org-refile.

- When ~t~ (default): org-gtd uses ~ORG_GTD_REFILE~ properties to find refile targets. This provides GTD-specific organization with flexible target placement.
- When ~nil~: org-gtd respects your existing ~org-refile-targets~ configuration. Items can be refiled anywhere you've configured org-mode refile targets.

*Important*: In V4, items can exist anywhere in ~org-agenda-files~ regardless of refile organization. This setting only affects the refile operation after clarifying items during inbox processing.

*Example*: Use your own refile configuration:
#+begin_src emacs-lisp
;; Disable org-gtd's refile system
(setq org-gtd-use-refile-system nil)

;; Configure standard org-refile targets
(setq org-refile-targets '((org-agenda-files :maxlevel . 3)))
#+end_src

*See also*: [[#refiling-after-organizing][Refiling section]] for complete documentation on creating refile targets and understanding the refile system.

*** Clarification Configuration

**** ~org-gtd-clarify-show-horizons~

*Type*: Symbol or nil

*Default*: ~nil~

*Description*: Whether to show horizons file during clarification.

Values:
- ~nil~ :: Don't show horizons by default
- ~'top~ :: Show horizons window at top
- ~'bottom~ :: Show horizons window at bottom
- ~'left~ :: Show horizons window on left
- ~'right~ :: Show horizons window on right

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-clarify-show-horizons 'right)
#+end_src

*Related command*: ~org-gtd-clarify-toggle-horizons-window~ to toggle visibility during clarification.

**** ~org-gtd-clarify-display-helper-buffer~

*Type*: Boolean

*Default*: ~nil~

*Description*: If non-nil, display project dependencies helper window when clarifying projects.

When enabled, shows a live view of task relationships in a side window when there are multiple tasks in the WIP buffer.

Useful for:
- Understanding complex dependency graphs
- Spotting cycles before they cause problems
- Planning parallel execution paths

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-clarify-display-helper-buffer t)
#+end_src

**** ~org-gtd-clarify-project-templates~

*Type*: Alist of (name . template) strings

*Default*: ~nil~

*Description*: Pre-defined project templates for common project types.

Each entry is a pair of (template-name . template-tasks) where template-tasks is a string of org headings to insert.

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-clarify-project-templates
      '(("Blog Post" . "** Research topic\n** Write draft\n** Edit\n** Add images\n** Publish")
        ("Code Feature" . "** Design API\n** Write tests\n** Implement feature\n** Code review\n** Merge")))
#+end_src

*Entering newlines in templates*: When setting this variable in your configuration file, use ~\n~ for newlines as shown above. If entering template strings interactively (e.g., via ~M-x customize-variable~ or in the minibuffer), use ~C-q C-j~ to insert a literal newline character. This works on all platforms including Windows.

Use ~org-gtd-clarify-project-insert-template~ during clarification to insert a template.

*** Areas of Focus Configuration

**** ~org-gtd-areas-of-focus~

*Type*: List of strings

*Default*: ~'("Home" "Health" "Family" "Career")~

*Description*: Your areas of focus (GTD Horizon 2) - the major areas in your life where you don't want to drop balls.

Used when:
- Adding area of focus to items (via ~org-gtd-set-area-of-focus~ hook)
- Reviewing specific areas with ~org-gtd-review-area-of-focus~

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-areas-of-focus
      '("Work" "Home" "Health" "Learning" "Relationships" "Finance"))
#+end_src

*** Engage View Configuration

**** ~org-gtd-engage-prefix-width~

*Type*: Integer

*Default*: ~12~

*Description*: How many characters to dedicate to the prefix in the engage agenda view.

The prefix shows the project name on the left side of each task.

*Example*: Increase space for longer project names:
#+begin_src emacs-lisp
(setq org-gtd-engage-prefix-width 20)
#+end_src

*** Archive Configuration

**** ~org-gtd-archive-location~

*Type*: Function (zero arguments, returns string)

*Default*: ~#'org-gtd-archive-location-func~

*Description*: Function that generates the archive location string for completed items.

The returned string must match ~org-archive-location~ format.

Default function generates: =archive-YYYY.org::datetree/= (year-based archive files).

*Example*: Archive to a single file:
#+begin_src emacs-lisp
(defun my-archive-location ()
  "Archive to a single file."
  "archive.org::")

(setq org-gtd-archive-location #'my-archive-location)
#+end_src

*Example*: Archive to month-based files:
#+begin_src emacs-lisp
(defun my-monthly-archive ()
  "Archive to month-based files."
  (format "archive-%s.org::datetree/"
          (format-time-string "%Y-%m")))

(setq org-gtd-archive-location #'my-monthly-archive)
#+end_src

*** Missed Engagements Review Configuration

**** ~org-gtd-review-missed-custom-views~

*Type*: List of GTD view specifications

*Default*: ~nil~

*Purpose*: Create custom views to find specific types of missed engagements (e.g., only work-related items, only specific areas of focus).

Think of this like creating saved searches. Instead of seeing ALL missed items, you can create views that show only the ones relevant to a specific context.

*When to use*: If you have multiple areas of focus (Work, Home, Hobbies) and want to review each separately.

*Example - Area-Specific Reviews*:
#+begin_src emacs-lisp
(setq org-gtd-review-missed-custom-views
      '(((name . "Overdue Work Items")
         (filters . ((area-of-focus . "Work")
                     (deadline . past))))
        ((name . "Missed Home Appointments")
         (filters . ((area-of-focus . "Home")
                     (category . calendar)
                     (timestamp . past))))))
#+end_src

After configuring, run ~M-x org-gtd-review-missed-with-custom~ to see all standard views plus your custom ones.

*Backward compatibility*: The old variable name ~org-gtd-oops-custom-views~ still works but will be removed in a future version.

*** ID Overlay Configuration

**** ~org-gtd-id-overlay-truncate-length~

*Type*: Integer

*Default*: ~20~

*Description*: Maximum length for displayed heading text in ID overlays.

When ~org-gtd-id-overlay-mode~ is enabled, task IDs are replaced with truncated heading text for readability.

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-id-overlay-truncate-length 30)
#+end_src

**** ~org-gtd-id-overlay-ellipsis~

*Type*: String

*Default*: ~"..."~

*Description*: String to append to truncated heading text in ID overlays.

*Example*:
#+begin_src emacs-lisp
(setq org-gtd-id-overlay-ellipsis "…")
#+end_src

*** Advanced Item Configuration

**** ~org-gtd-user-item-config~

*Type*: Alist

*Default*: ~'()~

*Description*: Override default behavior for GTD item types.

This is an advanced feature for customizing how org-gtd handles different item types. If org-gtd finds an item type in this alist, it uses your configuration instead of the built-in one.

*Example: Integrating Contact Managers with Delegation*

BBDB (Insidious Big Brother Database) and its modern successor EBDB are Emacs contact management packages that store information about people (names, emails, addresses, phone numbers, etc.). They integrate with mail clients and other Emacs packages. If you use BBDB or EBDB to manage your contacts, you can configure org-gtd to use completion from your contacts database when delegating tasks.

For EBDB integration:
#+begin_src emacs-lisp
;; Define function to fetch EBDB contacts
(defun my/ebdb-contacts ()
  "Return alist of (name . uuid) from EBDB contacts."
  (mapcar (lambda (rec)
            (let* ((name (ebdb-record-name-string rec))
                   (uuid (ebdb-record-uuid rec)))
              (cons name uuid)))
          (ebdb-records)))

;; Create custom input type for delegation that uses EBDB
(setq org-gtd-default-input-config
      (append org-gtd-default-input-config
              '(('delegate-person . (lambda (prompt)
                                     (completing-read (format "%s: " prompt)
                                                     (mapcar 'car (my/ebdb-contacts))
                                                     nil t))))))

;; Configure delegation to use the custom input type
(setq org-gtd-user-item-config
      '((:delegated
         . ((DELEGATED_TO . ((type . 'delegate-person)
                             (prompt . "Delegate to")))))))
#+end_src

For BBDB integration, adapt the function to use ~bbdb-records~ and ~bbdb-record-name~ instead:
#+begin_src emacs-lisp
(defun my/bbdb-contacts ()
  "Return alist of (name . uuid) from BBDB contacts."
  (mapcar (lambda (rec)
            (cons (bbdb-record-name rec)
                  (bbdb-record-uuid rec)))
          (bbdb-records)))
#+end_src

This same pattern can be used to integrate other completion sources (org-contacts, your own custom databases, etc.) with any org-gtd input prompt that uses the ~'text~ type.

*** Projects Configuration

**** ~org-gtd-project-progress-cookie-position~
:PROPERTIES:
:CUSTOM_ID: org-gtd-project-progress-cookie-position
:END:

*Type*: Symbol or nil

*Default*: ~'end~

*Description*: Controls where progress cookies are displayed on project headings.

Values:
- ~nil~ :: Disabled (no cookies shown)
- ~'start~ :: After TODO keyword, before title
- ~'end~ :: After heading text, before tags (default)

Progress cookies show project completion as ~[completed/total][percent%]~ format, for example ~[3/7][42%]~.

Unlike org-mode's built-in statistics cookies (~[/]~ or ~[%]~) which count direct children, org-gtd's progress cookies correctly count all tasks linked to the project via ~ORG_GTD_PROJECT_IDS~, making them accurate for the DAG-based project structure.

*Example*:
#+begin_src emacs-lisp
;; Show cookies at end of heading (default)
(setq org-gtd-project-progress-cookie-position 'end)

;; Show cookies at start of heading
(setq org-gtd-project-progress-cookie-position 'start)

;; Disable progress cookies
(setq org-gtd-project-progress-cookie-position nil)
#+end_src

*What it looks like*:
#+begin_example
;; With 'end (default):
,* PROJ Buy a house [3/7][42%]                    :home:

;; With 'start:
,* PROJ [3/7][42%] Buy a house                    :home:

;; With nil:
,* PROJ Buy a house                               :home:
#+end_example

*Automatic updates*: Cookies are automatically recalculated when:
- Task TODO states change (via hook)
- Project is created
- ~org-gtd-projects-fix-all-todo-keywords~ is run
- ~org-gtd-project-update-all-cookies~ is called manually

*See also*: [[#project-progress-cookies][Project Progress Cookies]] for detailed usage, [[#org-gtd-project-update-all-cookies][~org-gtd-project-update-all-cookies~]] for manual refresh.

*** Obsolete Variables (Do Not Use)

These variables are obsolete as of version 4.0. They are listed here for reference only.

**** ~org-gtd-todo-keyword~ (obsolete)
*Use instead*: ~org-gtd-keyword-mapping~ with key ~'todo~

**** ~org-gtd-next-keyword~ (obsolete)
*Use instead*: ~org-gtd-keyword-mapping~ with key ~'next~

**** ~org-gtd-wait-keyword~ (obsolete)
*Use instead*: ~org-gtd-keyword-mapping~ with key ~'wait~

**** ~org-gtd-canceled-keyword~ (obsolete)
*Use instead*: ~org-gtd-keyword-mapping~ with key ~'canceled~

** Commands Reference
:PROPERTIES:
:DESCRIPTION: All interactive commands explained
:CUSTOM_ID: commands-reference
:END:

This section lists all interactive commands available in org-gtd, organized by workflow step.

*** Core GTD Workflow Commands

**** ~org-gtd-capture~

*Binding*: Typically ~C-c d c~ (user-configurable)

*When to use*: Anytime something comes up that you need to capture

*What it does*:
- Opens org-capture for the inbox
- Uses templates from ~org-gtd-capture-templates~
- Stores item in inbox.org for later processing

*Arguments*: Optional ~goto~ and ~keys~ (same as ~org-capture~)

*Example usage*:
#+begin_example
M-x org-gtd-capture
Type: "Call dentist to schedule checkup"
C-c C-c to save
#+end_example

**** ~org-gtd-process-inbox~

*Binding*: Typically ~C-c d p~

*When to use*: When your inbox has items (daily or multiple times daily)

*What it does*:
- Starts processing loop through inbox items
- Opens each item in a clarify buffer (WIP mode)
- Continues until inbox is empty or you quit

*How to use*:
1. Run command
2. Edit each item to clarify it
3. Press your organize binding (~C-c c~) to organize it
4. Repeat for next item

*Related*: ~org-gtd-clarify-item~ to clarify a single item without processing whole inbox

**** ~org-gtd-organize~

*Binding*: Typically ~C-c c~ (only works in clarify buffers)

*When to use*: After clarifying an item, to categorize it

*What it does*:
- Opens transient menu with organization options
- Prompts for item-specific information (dates, names, etc.)
- Runs organize hooks
- Refiles item to appropriate location

*Important*: This only works in clarify buffers (org-gtd-wip-mode). It won't work in regular org files.

*Item types available*:
- [P] Project
- [A] Add to existing project
- [C] Calendar
- [D] Delegate
- [S] Single action
- [H] Habit
- [I] Incubate
- [K] Knowledge
- [Q] Quick action
- [T] Trash

**** ~org-gtd-engage~

*Binding*: Typically ~C-c d e~

*When to use*: Daily (or multiple times daily) to see what you can work on right now

*What it does*:
- Shows org-agenda view customized for GTD
- Displays the following.
  - Agenda for today (appointments, deadlines, scheduled items)
  - All NEXT actions (grouped by project)
- Uses prefix width from ~org-gtd-engage-prefix-width~

*Agenda commands available in this view*:
- ~t~ :: Change TODO state
- ~RET~ :: Visit item
- ~r~ :: Refile
- All other org-agenda commands :: Available as normal

**** ~org-gtd-show-all-next~

*Binding*: Typically ~C-c d n~

*When to use*: When you want to focus only on NEXT actions, without calendar/scheduled items

*What it does*:
- Shows all items with NEXT keyword
- Simpler than engage view (no agenda section)
- Useful for "get things done" focus mode

*** Review Commands

**** ~org-gtd-review-stuck-projects~

*Binding*: Typically ~C-c d s~

*When to use*: Weekly review, or when projects seem stalled

*What it does*:
- Finds projects that have active tasks but no NEXT actions
- Indicates dependency problems or missing FIRST_TASKS

*How to fix stuck projects*:
1. Navigate to project heading
2. Run ~org-gtd-projects-fix-todo-keywords-for-project-at-point~
3. If still stuck, check dependencies

**** ~org-gtd-review-area-of-focus~

*Arguments*: Optional AREA and START-DATE

*When to use*: During weekly/monthly reviews to focus on specific life area

*What it does*:
- Generates agenda view for items tagged with a specific area of focus
- Prompts for area if not provided
- Shows all items (projects, actions, calendar) for that area

*Example*:
#+begin_example
M-x org-gtd-review-area-of-focus
Area: Work
Shows: All Work-related items
#+end_example

**** ~org-gtd-review-completed-items~

*Arguments*: Optional DAYS-BACK (default 7)

*When to use*: Weekly review to see what you accomplished

*What it does*:
- Shows items completed in the last N days
- Good for weekly review reflection

*Example*:
#+begin_example
M-x org-gtd-review-completed-items
Shows: Items completed in last 7 days

C-u 30 M-x org-gtd-review-completed-items
Shows: Items completed in last 30 days
#+end_example

**** ~org-gtd-review-completed-projects~

*When to use*: Weekly/monthly review to see finished projects

*What it does*:
- Shows all projects where all tasks are DONE
- Ready to archive

**** ~org-gtd-review-missed-items~

*When to use*: When you suspect items have fallen through the cracks

*What it does*:
- Finds items that should have been processed but weren't
- Looks for various data inconsistencies

*** Stuck Item Review Commands

Each of these commands finds items with problems in a specific category:

**** ~org-gtd-review-stuck-calendar-items~

Finds calendar items with invalid or missing timestamps.

**** ~org-gtd-review-stuck-incubated-items~

Finds incubated items with invalid or missing review dates.

**** ~org-gtd-review-stuck-habit-items~

Finds habit items with incorrect configuration.

**** ~org-gtd-review-stuck-delegated-items~

Finds delegated items with missing delegate or date information.

**** ~org-gtd-review-stuck-single-action-items~

Finds single actions that aren't marked as NEXT.

*** Review Commands (Missed Engagements)

**** What Are Missed Engagements?

Life doesn't go as planned. You miss appointments, delegated items slip through cracks, projects run late. These aren't failures—they're normal. What matters is catching them and deciding what to do next.

The missed engagements review helps you find three types of items that need attention:
- *Appointments you missed*: Calendar items with dates in the past
- *Check-ins you forgot*: Delegated items where follow-up dates passed
- *Projects running late*: Projects with overdue deadlines or start dates

This is your safety net. Run it daily or weekly to ensure nothing falls through the cracks.

**** Your First Review in 30 Seconds

Try this right now:

1. Run ~M-x org-gtd-review-missed-engagements~
2. Look at what appears in the agenda view
3. Press ~TAB~ on any item to see its details

That's it. You're now reviewing missed engagements.

If you see items, ask yourself: "What should I do about this now?" Then organize accordingly (reschedule, cancel, or act).

**** Understanding the Review Workflow

Think of GTD like a promise system. When you:
- Schedule an appointment → you promise to be there at that time
- Delegate a task → you promise to check in on the date you set
- Set a project deadline → you promise to complete by that date

When dates pass without action, you've broken a promise (to yourself or others).

The review workflow helps you:
1. *Find* broken promises (missed engagements)
2. *Decide* what to do about them
3. *Act* on your decision

This isn't about guilt—it's about staying in control.

**** Tutorial: Daily Review Workflow

Here's how to use this in your daily routine:

*Morning Review* (2 minutes):
#+begin_example
M-x org-gtd-review-missed-engagements

Look at each item:
- Missed appointment? Reschedule or apologize
- Forgot to check in on delegation? Do it now
- Project running late? Decide: extend deadline or cancel
#+end_example

*Focusing on One Type*:

If you just want to see missed appointments:
#+begin_example
M-x org-gtd-review-missed-calendar
#+end_example

Or just delegated items needing check-ins:
#+begin_example
M-x org-gtd-review-missed-delegated
#+end_example

Or just late projects:
#+begin_example
M-x org-gtd-review-missed-projects
#+end_example

Each command shows only that type, making it easier to focus.

**** Common Patterns

*Pattern 1: Morning Triage*
Start each day by reviewing missed engagements. Handle or reschedule everything before starting new work.

*Pattern 2: Weekly Cleanup*
During weekly review, run the full missed engagements view. This catches anything that slipped through daily reviews.

*Pattern 3: Context-Specific Review*
Use custom views to see missed items by area of focus (see configuration below).

**** Command Reference

| Command | Shows | Use When |
|---------|-------|----------|
| ~org-gtd-review-missed-engagements~ | All missed items | Daily/weekly review |
| ~org-gtd-review-missed-calendar~ | Missed appointments only | Checking calendar |
| ~org-gtd-review-missed-delegated~ | Delegations needing check-in | Following up on delegated work |
| ~org-gtd-review-missed-projects~ | Late projects only | Project review |
| ~org-gtd-review-missed-with-custom~ | All missed + custom views | Using custom filters |

**** Backward Compatibility Note

The old command names still work:
- ~org-gtd-oops~ → ~org-gtd-review-missed-engagements~
- ~org-gtd-oops-calendar~ → ~org-gtd-review-missed-calendar~
- ~org-gtd-oops-delegated~ → ~org-gtd-review-missed-delegated~
- ~org-gtd-oops-projects~ → ~org-gtd-review-missed-projects~
- ~org-gtd-oops-with-custom~ → ~org-gtd-review-missed-with-custom~

Update to the new names when convenient. The old names will be removed in a future version.

*** Review Commands (Upcoming Delegated)

**** What Are Upcoming Delegated Check-ins?

You delegate work and set check-in dates. Some people finish early. Others appreciate regular check-ins. Waiting until check-in dates pass means lost opportunities.

The upcoming delegated review shows all active delegated items with future check-in dates. This helps you:
- *Catch early completions*: Someone finished early, you can adjust the plan now
- *Plan your follow-ups*: See what check-ins are coming this week or month
- *Proactive management*: Reach out before problems develop

This is your planning tool. Use it weekly to prepare your delegation check-ins, or ad-hoc when people report early progress.

**** Your First Review in 30 Seconds

Try this right now:

1. Run ~M-x org-gtd-review-upcoming-delegated~
2. Look at the delegated items with future check-in dates
3. Press ~TAB~ on any item to see when the check-in is scheduled

That's it. You're now seeing upcoming delegation check-ins.

If someone tells you they finished early, you'll find that item here and can update your plans accordingly.

**** Understanding Proactive Delegation Management

Think about delegation timing:

*Reactive management* (missed engagements):
- Check-in date passes → you remember to follow up
- Problem discovered after it's late
- Always catching up

*Proactive management* (upcoming review):
- See check-ins coming this week → prepare questions
- Someone finishes early → immediately unblock dependent work
- Stay ahead of problems

The upcoming delegated review shifts you from reactive to proactive.

**** Tutorial: Weekly Planning Workflow

Here's how to use this in your weekly planning:

*Sunday Planning* (5 minutes):
#+begin_example
M-x org-gtd-review-upcoming-delegated

For each item:
- Check-in this week? Prepare questions or schedule call
- Might finish early? Be ready to adjust plans
- Blocked on something? Follow up proactively
#+end_example

*When Someone Reports Early Completion*:
#+begin_example
M-x org-gtd-review-upcoming-delegated

Find their item in the list
Press TAB to jump to the item
Mark it DONE (it disappears from the upcoming view)
Check if this unblocks other work in the project
#+end_example

*Combined with Missed Review*:
#+begin_example
# Morning routine
M-x org-gtd-review-missed-delegated    # Catch up on late check-ins
M-x org-gtd-review-upcoming-delegated  # Plan upcoming check-ins
#+end_example

The first shows what you missed. The second shows what's coming. Together they give complete delegation visibility.

**** Common Patterns

*Pattern 1: Weekly Planning*
Every Sunday or Monday, review upcoming delegated items for the week. Know what check-ins are coming so you're prepared.

*Pattern 2: Early Completion Response*
When someone says "I finished that task you gave me," pull up this view to find it quickly and update your plans.

*Pattern 3: Project Acceleration*
Review a specific project's delegated items. If anyone finished early, immediately reassign work to take advantage of the extra time.

*Pattern 4: Delegation Optimization*
Notice patterns: Who consistently finishes early? Give them more work. Who's always late? More frequent check-ins.

**** Understanding What You See

The view shows all active (not done) delegated items with future check-in dates:
- Items with TODO, NEXT, or WAIT states
- Items with check-ins far in the future (months away)
- Items from all areas of focus

Once you mark an item DONE or CNCL, it disappears from this view automatically—you've already processed it and taken action.

If you see too many items and want to filter:
- Focus on one project at a time (use project-specific review)
- Look at specific timeframes (future enhancement—not yet implemented)
- Use custom views with area-of-focus filters

**** Comparison: Missed vs Upcoming

| Review Type | Shows | Mindset | Use When |
|-------------|-------|---------|----------|
| Missed Delegated | Past check-ins | Reactive - catching up | Daily triage |
| Upcoming Delegated | Future check-ins | Proactive - planning | Weekly planning |

Both are valuable. Missed helps you catch problems. Upcoming helps you prevent them.

**** Command Reference

| Command | Shows | Use When |
|---------|-------|----------|
| ~org-gtd-review-upcoming-delegated~ | All delegated items with future check-in dates | Weekly planning, early completion responses |

*** Custom View Commands

**** ~org-gtd-view-show~

**What it is:** Create custom GTD agenda views using a declarative language instead of learning org-ql or org-agenda internals.

**Why you'd use it:** The built-in views (engage, review-stuck-projects, etc.) cover common needs, but you have unique workflows. Maybe you only want to see work-related NEXT actions, or projects in a specific area, or items tagged "urgent". This lets you create exactly the view you need.

**Who needs it:** Users who want views tailored to their specific workflow beyond the built-in commands.

**Your first custom view (5 minutes):**

Let's create a view showing only your NEXT actions (no calendar, no agenda).

1. Add this to your config file:
   #+begin_src emacs-lisp
   (defun my-next-actions ()
     "Show all NEXT actions in a simple list."
     (interactive)
     (org-gtd-view-show
      '((name . "All NEXT Actions")
        (filters . ((todo . ("NEXT")))))))
   #+end_src

2. Save and reload your config (~M-x eval-buffer~ or restart Emacs)

3. Run it:
   #+begin_example
   M-x my-next-actions
   #+end_example

You'll see all your NEXT actions in one list. That's it—you've created a custom view!

**Understanding how views work:**

Think of views like filtered searches. You tell org-gtd what to show using ~filters~, and it finds matching items.

The built-in ~org-gtd-engage~ command? It uses ~org-gtd-view-show~ internally. ~org-gtd-review-stuck-projects~? Same thing. You're now using the same tool the package uses to create its own views.

Each view has two parts:
- ~name~ :: What to call the view (shows in agenda header)
- ~filters~ :: What to show (category, TODO state, tags, dates, etc.)

Filters are pairs like ~(filter-type . value)~. Multiple filters combine with AND logic—all must match.

**Tutorial: Common custom views**

*Show only work-related NEXT actions:*

#+begin_src emacs-lisp
(defun my-work-next-actions ()
  "Show NEXT actions for work projects only."
  (interactive)
  (org-gtd-view-show
   '((name . "Work NEXT Actions")
     (filters . ((todo . ("NEXT"))
                 (area-of-focus . "Work"))))))
#+end_src

Two filters: must be NEXT AND must be in Work area.

*Show projects that are stuck:*

#+begin_src emacs-lisp
(defun my-stuck-projects ()
  "Show projects with no NEXT actions."
  (interactive)
  (org-gtd-view-show
   '((name . "Stuck Projects")
     (filters . ((category . stuck-projects))))))
#+end_src

One filter: category must be stuck-projects (built-in category that checks for stuck state).

*Show items with past deadlines:*

#+begin_src emacs-lisp
(defun my-overdue-items ()
  "Show all items with deadlines in the past."
  (interactive)
  (org-gtd-view-show
   '((name . "Overdue Items")
     (filters . ((deadline . past))))))
#+end_src

One filter: deadline must be in the past. (Automatically excludes DONE items.)

*Show multiple related views together:*

#+begin_src emacs-lisp
(defun my-morning-review ()
  "Show morning planning views: NEXT actions and calendar."
  (interactive)
  (org-gtd-view-show
   '(((name . "Today's NEXT Actions")
      (filters . ((todo . ("NEXT")))))
     ((name . "Upcoming Calendar Items")
      (filters . ((category . calendar)
                  (timestamp . future)))))))
#+end_src

This shows TWO views in one agenda: NEXT actions first, then upcoming calendar items.

**Common patterns:**

*Filter by area of focus:*
#+begin_src emacs-lisp
(filters . ((area-of-focus . "Work")))
#+end_src

*Filter by category (item type):*
#+begin_src emacs-lisp
(filters . ((category . projects)))      ; All projects
(filters . ((category . actions)))       ; Single actions
(filters . ((category . delegated)))     ; Delegated items
(filters . ((category . calendar)))      ; Calendar items
(filters . ((category . stuck-projects))) ; Stuck projects only
#+end_src

*Filter by TODO state:*
#+begin_src emacs-lisp
(filters . ((todo . ("NEXT"))))          ; Just NEXT
(filters . ((todo . ("TODO" "NEXT"))))   ; TODO or NEXT
#+end_src

*Filter by time:*
#+begin_src emacs-lisp
(filters . ((deadline . past)))          ; Overdue deadlines
(filters . ((timestamp . past)))         ; Past timestamps
(filters . ((timestamp . future)))       ; Future timestamps
(filters . ((scheduled . today)))        ; Scheduled for today
#+end_src

*Combine multiple filters (AND logic):*
#+begin_src emacs-lisp
(filters . ((category . projects)
            (area-of-focus . "Work")
            (deadline . past)))
; Shows: Projects AND Work area AND overdue
#+end_src

**When to create custom views:**

Create a custom view when you find yourself:
- Repeatedly filtering the engage view manually
- Wanting to see specific combinations org-gtd doesn't provide
- Needing views for specific contexts (home office, traveling, morning routine)
- Organizing weekly reviews around specific categories

Don't create views for one-time queries—just use the built-in views and navigate. Create views for repeated patterns in your workflow.

**Binding to keys:**

Once you've created a view you use often, bind it to a key:

#+begin_src emacs-lisp
;; Vanilla Emacs
(global-set-key (kbd "C-c d w") 'my-work-next-actions)

;; Doom Emacs (in config.el)
(map! :leader
      (:prefix "d"
       :desc "Work NEXT actions" "w" #'my-work-next-actions))

;; Spacemacs (in user-config)
(spacemacs/set-leader-keys "od w" 'my-work-next-actions)
#+end_src

**Complete filter reference:**

For the full list of available filters and their syntax, see [[#view-dsl-reference][View DSL Reference]].

Common filters include:
- ~category~ :: projects, actions, delegated, calendar, stuck-projects, etc.
- ~todo~ :: List of TODO keywords to match
- ~area-of-focus~ :: Specific area/category
- ~deadline~, ~scheduled~, ~timestamp~ :: Time-based filters (past, future, today)
- ~tags~ :: Match specific tags
- ~level~ :: Heading level (2 for projects, 3+ for tasks)

**Command reference:**

*Function signature:*
#+begin_src emacs-lisp
(org-gtd-view-show VIEW-SPEC-OR-SPECS)
#+end_src

*Arguments:*
- ~VIEW-SPEC-OR-SPECS~ :: Either a single view specification (alist) or list of view specifications

*View specification structure:*
#+begin_src emacs-lisp
'((name . "View Name")
  (filters . ((filter-type . value)
              (filter-type . value)
              ...)))
#+end_src

*Multiple views:*
#+begin_src emacs-lisp
'(((name . "View 1")
   (filters . (...)))
  ((name . "View 2")
   (filters . (...))))
#+end_src

*Returns:* Opens org-agenda buffer with the specified view

*Example:*
#+begin_src emacs-lisp
;; Single view
(org-gtd-view-show
 '((name . "Active Projects")
   (filters . ((category . projects)))))

;; Multiple views
(org-gtd-view-show
 '(((name . "NEXT Actions")
    (filters . ((todo . ("NEXT")))))
   ((name . "Stuck Projects")
    (filters . ((category . stuck-projects))))))
#+end_src

*** Clarification Commands

**** ~org-gtd-clarify-item~

*Arguments*: Optional MARKER and WINDOW-CONFIG

*When to use*: To clarify a single org heading without processing the entire inbox

*What it does*:
- Opens item in clarify buffer (WIP mode)
- You can edit and organize it
- Returns to previous location when done

*Example*: Clarifying an item in your tasks file that needs re-organization.

**** ~org-gtd-clarify-agenda-item~

*When to use*: When viewing agenda and want to re-clarify an item

*What it does*:
- Opens agenda item in clarify buffer
- Same as ~org-gtd-clarify-item~ but works from agenda view

**** ~org-gtd-clarify-toggle-horizons-window~

*When to use*: During clarification, to show/hide your horizons file

*What it does*:
- Toggles display of horizons file in side window
- Position determined by ~org-gtd-clarify-show-horizons~ (or right side if variable is nil)

**** ~org-gtd-clarify-project-insert-template~

*When to use*: During project clarification, to insert a predefined template

*What it does*:
- Prompts for template from ~org-gtd-clarify-project-templates~
- Inserts template tasks into current project

*** Archive Commands

**** ~org-gtd-archive-completed-items~

*When to use*: Weekly or monthly cleanup

*What it does*:
- Finds all DONE/CNCL items in GTD files
- Archives them to location specified by ~org-gtd-archive-location~
- Keeps your active files clean

*Example*:
#+begin_example
M-x org-gtd-archive-completed-items
Archives: All completed items
Result: Clean active files, archived items in archive file(s)
#+end_example

*** Agenda-Specific Commands

These commands only work when point is on an agenda item:

**** ~org-gtd-delegate-agenda-item~

*When to use*: In agenda view, to delegate an existing action to someone else

*What it does*:
- Prompts for person to delegate to
- Prompts for follow-up date
- Updates item properties
- Refiles to delegated items location

**** ~org-gtd-project-cancel-from-agenda~

*When to use*: In agenda view, when you want to cancel an entire project

*What it does*:
- Finds the project containing the agenda item
- Marks all remaining tasks as CNCL
- Updates project status

*** Project Management Commands

**** ~org-gtd-projects-fix-todo-keywords-for-project-at-point~

*When to use*: When project TODO states seem incorrect after dependency changes

*What it does*:
- Recalculates which tasks should be NEXT based on dependency graph
- Updates all task keywords in the project
- Fixes stuck projects

*Required*: Point must be on project heading

*Note*: This is automatically called after graph UI operations and text-based task management commands. You typically only need this for troubleshooting edge cases.

**** ~org-gtd-projects-fix-all-todo-keywords~

**What it is:** Recalculates and fixes TODO/NEXT states for ALL projects in your GTD system at once.

**Why you'd use it:** After making changes in external tools (mobile apps, web interfaces, other editors) that don't know about org-gtd's dependency logic, your task states might be inconsistent. This command makes everything sane again.

**Who needs it:** Anyone who edits their GTD files outside of org-gtd (mobile apps, sync conflicts, manual edits).

**Your first use (30 seconds):**

1. Edit tasks on your phone/tablet/other tool
2. Sync back to Emacs
3. Run: ~M-x org-gtd-projects-fix-all-todo-keywords~
4. Done - all task states are now correct

That's it. No need to manually check each project.

**Common scenarios:**

- Completed tasks on mobile → states might be wrong → run this
- Changed task descriptions/notes externally → run this to be safe
- Sync conflict resolution → run this after fixing conflicts
- Bulk manual edits outside org-gtd → run this
- After migration or data import → run this

**When to use this vs the single-project version:**

Use ~org-gtd-projects-fix-all-todo-keywords~ when:
- You've worked in external tools (mobile, web, other editors)
- You've edited multiple projects
- You don't know which projects are affected
- You want to fix everything at once (safest option)

Use ~org-gtd-projects-fix-todo-keywords-for-project-at-point~ when:
- You know which specific project has issues
- You've just edited one project in Emacs
- You want to fix just one project quickly

**What it does (technical):**

1. Scans all projects in agenda files
2. Resets active task states (TODO/NEXT → TODO)
3. Calculates which tasks are ready based on dependencies
4. Marks ready tasks as NEXT
5. Preserves user-set states (WAIT, DONE, CNCL)
6. Handles multi-project tasks correctly (AND semantics)

**Multi-project tasks:**

Some tasks can belong to multiple projects. This command handles them safely:
- Shared task becomes NEXT only if ready in ALL its projects
- If ready in just some projects, stays TODO
- WAIT states are never auto-changed

**When NOT to use:**

- If you only work in Emacs with org-gtd commands (automatic state management works)
- If your projects look correct already
- Before making external changes (use after, not before)

**** ~org-gtd-project-update-all-cookies~
:PROPERTIES:
:CUSTOM_ID: org-gtd-project-update-all-cookies
:END:

**What it is:** Refreshes progress cookies on ALL project headings at once.

**Why you'd use it:** Progress cookies show ~[3/7][42%]~ on project headings. While these update automatically when you change task states, sometimes you want to refresh everything—for example, after bulk changes or data migration.

**Your first use (30 seconds):**

1. Run: ~M-x org-gtd-project-update-all-cookies~
2. Done - all project headings now show accurate progress

**What it does:**

- Scans all projects in agenda files
- Counts completed vs total tasks for each project
- Updates the ~[completed/total][percent%]~ display on each project heading

**When to use:**

- After bulk task changes outside of org-gtd
- After data migration or import
- During weekly review for visual refresh
- If progress cookies look outdated

**Configuration:**

Progress cookies are controlled by ~org-gtd-project-progress-cookie-position~:
- ~'end~ (default) - cookies appear at end of heading before tags
- ~'start~ - cookies appear after TODO keyword
- ~nil~ - cookies disabled entirely

*See also*: [[#project-progress-cookies][Project Progress Cookies]] for detailed usage guide.

**** ~org-gtd-incubate~

**What it is:** Smart command to pause items you're not ready to work on yet.

**Why you'd use it:** You have a project or action that's a good idea, but not right now. You want to set it aside with a reminder to review it later, without losing your planning work.

**Who needs it:** Anyone managing "someday/maybe" items or projects they want to defer.

**Your first use (30 seconds):**

1. Navigate to a project or action
2. Run: ~M-x org-gtd-incubate~
3. Enter review date: ~2025-12-01~
4. Done - it disappears from your engage view until that date

**What it does:**

Detects what you're on:
- Project heading → incubates entire project with all tasks
- Project task → incubates the project it belongs to
- Single action → incubates just that action

For projects:
- Preserves all task states and dependencies
- Hides everything from engage/NEXT views
- Adds review date to your agenda
- Skips multi-project tasks (tasks shared between projects)

**When to use:**

- Projects you want to pursue "someday" but not now
- Ideas that need to marinate before you're ready
- Seasonal projects (start each year)
- Projects blocked by external factors beyond your control

**** ~org-gtd-reactivate~

**What it is:** Bring back incubated projects and actions.

**Why you'd use it:** The review date arrived, you're ready to work on it again.

**Your first use (30 seconds):**

1. When you see an incubated item in agenda (on its review date)
2. Run: ~M-x org-gtd-reactivate~
3. Graph view opens - review the project structure
4. Adjust if needed and close

**What it does:**

- Restores original item states (project → Projects, actions → Actions, etc.)
- Restores task TODO keywords
- Recalculates NEXT tasks based on current dependencies
- Opens project graph view (for projects) so you can review and adjust
- Removes the review date

**When to use:**

- When an incubated item appears in your agenda on its review date
- When you're ready to reactivate something earlier than scheduled
- During weekly review when scanning incubated items

*** Task Dependency Commands
:PROPERTIES:
:CUSTOM_ID: task-dependency-commands
:END:

These text-based commands manage task relationships without using the graph view. Most users will find the graph view more intuitive (press ~M-x org-gtd-show-project-graph~), but these commands are useful for:

- Working in the org file directly
- Scripting/automation
- Preference for text-based workflows

*Graph UI equivalents*:
- Adding dependencies: ~a~ (add dependency), ~a b~ (add blocker), ~a c~ (add child)
- Removing dependencies: ~d~ (remove dependency), ~x~ (clear all)
- Viewing relationships: ~i~ (show relationships)

See [[#graph-view-command-reference][Graph View Command Reference]] for the visual approach.

**** ~org-gtd-task-add-blockers~

*When to use*: To specify that the current task depends on other task(s) completing first

*What it does*:
- Prompts to select tasks that block the current task
- Creates bidirectional relationships.
  - Adds selected task IDs to current task's ORG_GTD_DEPENDS_ON
  - Adds current task ID to selected tasks' ORG_GTD_BLOCKS
- Can select multiple blockers

*Example*:
#+begin_example
On task: "Get diagnosis"
M-x org-gtd-task-add-blockers
Select: "Make MRI appointment" and "Make orthopedist appointment"
Result: Both appointments must complete before diagnosis can start
#+end_example

**** ~org-gtd-task-remove-blockers~

*When to use*: To remove blocking relationships from current task

*What it does*:
- Shows current blockers
- Prompts to select which to remove
- Removes bidirectional relationships

**** ~org-gtd-task-add-dependent~

*When to use*: To specify that another task depends on the current task completing

*What it does*:
- Prompts to select a task that depends on current task
- Creates bidirectional relationship.
  - Adds selected task ID to current task's ORG_GTD_BLOCKS
  - Adds current task ID to selected task's ORG_GTD_DEPENDS_ON

*Example*:
#+begin_example
On task: "Get project approval"
M-x org-gtd-task-add-dependent
Select: "Start implementation"
Result: Implementation can't start until approval is done
#+end_example

**** ~org-gtd-task-add-dependents~

*When to use*: To specify multiple tasks that depend on the current task

*What it does*:
- Same as ~org-gtd-task-add-dependent~ but allows multiple selections

**** ~org-gtd-task-clear-relationships~

*When to use*: To remove ALL dependency relationships from current task

*What it does*:
- Removes all ORG_GTD_BLOCKS and ORG_GTD_DEPENDS_ON properties
- Updates related tasks to remove references to this task
- Use with caution!

**** ~org-gtd-task-show-relationships~

*When to use*: To see what tasks are related to the current task

*What it does*:
- Displays in minibuffer.
  - Tasks this task depends on (blockers)
  - Tasks that depend on this task (dependents)
- Useful for understanding dependency graph

**** ~org-gtd-validate-project-dependencies~

*When to use*: To check for dependency problems in a project

*What it does*:
- Detects broken dependency references (task IDs that don't exist)
- Finds orphaned tasks (not reachable from FIRST_TASKS)
- Identifies circular dependencies
- Provides guidance on fixes

*Required*: Point must be on project heading

**** ~org-gtd-remove-task-from-project~

*When to use*: To remove a task from a project structure

*What it does*:
- Removes the project ID from task's ORG_GTD_PROJECT_IDS property
- Doesn't delete the task, just removes project association
- Useful when reorganizing project structures

*** Area of Focus Commands

**** ~org-gtd-area-of-focus-set-on-item-at-point~

*When to use*: To add area of focus to an existing item (not during organize)

*What it does*:
- Prompts for area from ~org-gtd-areas-of-focus~
- Sets CATEGORY property
- Use this on any org heading

*Note*: Trusts you to use it correctly (no validation)

**** ~org-gtd-area-of-focus-set-on-agenda-item~

*When to use*: In agenda view, to set area of focus on an item

*What it does*:
- Same as ~org-gtd-area-of-focus-set-on-item-at-point~ but from agenda
- Smarter: detects if you're on a project task and sets area on the project instead

*** Programmatic Creation Commands

These commands create GTD items programmatically (useful for automation and Emacs Lisp code):

**** ~org-gtd-habit-create~

*Arguments*: STRING and additional parameters

*Use case*: Creating habits from Emacs Lisp

*Example*:
#+begin_src emacs-lisp
(org-gtd-habit-create "Exercise" "daily" (org-read-date nil nil "+0d"))
#+end_src

**** ~org-gtd-calendar-create~

*Arguments*: STRING and DATE-TIME

*Use case*: Creating calendar items from Emacs Lisp

*Example*:
#+begin_src emacs-lisp
(org-gtd-calendar-create "Team meeting" (org-read-date nil nil "+7d 9:00"))
#+end_src

**** ~org-gtd-delegate-create~

*Arguments*: STRING, DELEGATED-TO, and REMINDER-DATE

*Use case*: Auto-delegating from email, code review systems, etc.

*Example*:
#+begin_src emacs-lisp
(defun org-gtd-email-reminder ()
  (let ((topic (message-fetch-field "subject"))
        (delegated-to (message-fetch-field "to"))
        (reminder-date (org-read-date nil nil "+3d")))
    (org-gtd-delegate-create (format "Reminder: %s" topic)
                             delegated-to
                             reminder-date)))

(add-hook 'message-send-hook 'org-gtd-email-reminder)
#+end_src

**** ~org-gtd-incubate-create~

*Arguments*: STRING and REVIEW-DATE

*Use case*: Programmatically adding someday/maybe items

*Example*:
#+begin_src emacs-lisp
(org-gtd-incubate-create "Learn Rust" (org-read-date nil nil "+6m"))
#+end_src

**** ~org-gtd-single-action-create~

*Arguments*: STRING

*Use case*: Programmatically adding actions

*Example*:
#+begin_src emacs-lisp
(org-gtd-single-action-create "Follow up on proposal")
#+end_src

*** Utility Commands

**** ~org-gtd-setup-keywords-wizard~

*When to use*: Initial setup or when changing keyword configuration

*What it does*:
- Interactive wizard to configure GTD keyword mapping
- Guides you through setting up ~org-gtd-keyword-mapping~
- Validates configuration

**** ~org-gtd-inbox-path~

*Not interactive, but useful in Emacs Lisp*

*Returns*: Full path to inbox.org file

*Use case*: When writing custom capture templates or automation

*Example*:
#+begin_src emacs-lisp
(defun my-custom-capture ()
  (let ((inbox (org-gtd-inbox-path)))
    ;; do something with inbox file
    ))
#+end_src

*** ID Overlay Commands

**** ~org-gtd-id-overlay-mode~

*Type*: Minor mode

*When to use*: When working with project dependencies and wanting readable task references

*What it does*:
- Replaces task IDs with truncated heading text
- Makes dependency properties more readable
- Automatically enabled in WIP buffers

**** ~org-gtd-id-overlay-refresh-buffer~

*When to use*: After modifying headings, to update overlays

*What it does*:
- Refreshes all ID overlays in current buffer
- Usually automatic, but available for manual refresh

**** ~org-gtd-id-overlay-clear-buffer~

*When to use*: To remove all overlays (see raw IDs)

*What it does*:
- Removes all ID overlays from buffer
- Shows actual ID values

*** Migration and Upgrade Commands

**** ~org-gtd-upgrade-v3-to-v4~

*When to use*: REQUIRED when upgrading from version 3.x to 4.0

*What it does*:
1. Adds ORG_GTD properties to identify items
2. Converts TRIGGER-based projects to dependency-based system
3. Updates task states based on new dependency graph

*Important*:
- Make a backup first!
- Required for existing projects to work in v4
- Safe to run multiple times
- See [[#upgrading][Upgrading section]] for complete details

*** Obsolete Commands

**** ~org-gtd-mode~ (obsolete since 4.0)

*Use instead*:
#+begin_src emacs-lisp
(setq org-agenda-files (list org-gtd-directory))
(org-edna-mode 1)
#+end_src

This minor mode is no longer needed and will be removed in a future version.

** Properties Reference (Internal Implementation)
:PROPERTIES:
:DESCRIPTION: All org properties used by org-gtd
:CUSTOM_ID: properties-reference
:END:

*For most users*: You don't need to read this section! Use the graph view or text-based task management commands instead.

*This section is for*:
- Understanding org-gtd's internal data model
- Writing elisp automation/integration code
- Debugging edge cases
- Migrating data from other systems

org-gtd uses org-mode properties to track state and relationships. These properties are managed automatically by org-gtd commands - *you should not edit them manually during normal use.*

If you find yourself manually editing properties, that indicates a missing feature - please file an issue!

*** Core GTD Properties

**** ORG_GTD

*Used on*: All GTD items (projects, actions, calendar items, incubated items, etc.)

*Purpose*: Identifies the type of GTD item

*Values*:
- ~"Projects"~ :: Project heading
- ~"Actions"~ :: Project tasks and single actions
- ~"Calendar"~ :: Calendar items (appointments, deadlines)
- ~"Incubated"~ :: Someday/maybe items
- ~"Delegated"~ :: Delegated tasks (set in combination with DELEGATED_TO)

*Example*:
#+begin_example
,* My Project
:PROPERTIES:
:ORG_GTD: Projects
:END:
,** NEXT Task 1
:PROPERTIES:
:ORG_GTD: Actions
:END:
#+end_example

*Note*: This property is how org-gtd identifies items. Don't modify manually unless you understand the implications.

**** ORG_GTD_REFILE

*Used on*: Category headings that serve as refile targets

*Purpose*: Marks a heading as a refile target for org-gtd's optional refile system (see [[#refiling-after-organizing][Refiling section]])

*Values*:
- ~"Projects"~ :: Target for refiling projects
- ~"Actions"~ :: Target for refiling single actions
- ~"Calendar"~ :: Target for refiling calendar items
- ~"Incubated"~ :: Target for refiling incubated items
- ~"Habits"~ :: Target for refiling habits

*Example*:
#+begin_example
,* Projects         <-- Can be at any level in any file
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:

,* Work/Development Projects   <-- Can have multiple targets per type
:PROPERTIES:
:ORG_GTD_REFILE: Projects
:END:
#+end_example

*How it's set*:
- Automatically created by ~org-gtd-upgrade-v3-to-v4~ (renames ORG_GTD on level 1 headings)
- Manually when creating custom refile targets
- Via ~org-entry-put~ in elisp: ~(org-entry-put nil "ORG_GTD_REFILE" "Projects")~

*Important notes*:
- This property is OPTIONAL - only used if ~org-gtd-use-refile-system~ is ~t~ (default)
- Can exist at ANY level in ANY file in ~org-agenda-files~
- You can have multiple refile targets for the same category type
- Set ~org-gtd-use-refile-system~ to ~nil~ to use standard org-refile instead

*** Project Properties

**** ORG_GTD_FIRST_TASKS

*Used on*: Project headings

*Purpose*: Identifies which tasks can start immediately (have no dependencies)

*Format*: Space-separated list of task IDs

*Example*:
#+begin_example
,* Software Release
:PROPERTIES:
:ORG_GTD: Projects
:ORG_GTD_FIRST_TASKS: abc123 def456
:END:
#+end_example

This means tasks with IDs "abc123" and "def456" can both start immediately (parallel execution).

*How it's set*:
- Automatically when organizing a project
- Automatically by graph view ~a r~ (add root task) and ~a b~ (add blocker as root)
- Programmatically via ~org-entry-add-to-multivalued-property~

*For interactive use*: Use graph view commands instead of editing this property directly.

*** Task Dependency Properties

**** ORG_GTD_DEPENDS_ON

*Used on*: Project tasks

*Purpose*: Lists task IDs that must complete before this task can start

*Format*: Space-separated list of task IDs

*Example*:
#+begin_example
,** NEXT Get project approval
:PROPERTIES:
:ID: task-001
:ORG_GTD: Actions
:ORG_GTD_BLOCKS: task-002 task-003
:END:
,** TODO Design solution
:PROPERTIES:
:ID: task-002
:ORG_GTD: Actions
:ORG_GTD_DEPENDS_ON: task-001
:ORG_GTD_BLOCKS: task-004
:END:
,** TODO Setup infrastructure
:PROPERTIES:
:ID: task-003
:ORG_GTD: Actions
:ORG_GTD_DEPENDS_ON: task-001
:ORG_GTD_BLOCKS: task-004
:END:
,** TODO Implement feature
:PROPERTIES:
:ID: task-004
:ORG_GTD: Actions
:ORG_GTD_DEPENDS_ON: task-002 task-003
:END:
#+end_example

In this example:
- Task 001 (approval) starts first
- Tasks 002 (design) and 003 (infrastructure) can run in parallel after approval
- Task 004 (implement) waits for both 002 and 003 to complete

*How it's set*:
- Automatically by graph view ~a~ (add dependency), ~a c~ (add child), ~a b~ (add blocker)
- Automatically by text commands ~org-gtd-task-add-blockers~, ~org-gtd-task-add-dependent~
- Programmatically via ~org-gtd-dependencies-create~ (maintains bidirectional relationships)

*For interactive use*: Use graph view or text-based task commands instead of editing this property directly.

**** ORG_GTD_BLOCKS

*Used on*: Project tasks

*Purpose*: Lists task IDs that depend on this task completing (inverse of DEPENDS_ON)

*Format*: Space-separated list of task IDs

*Relationship*: If task A has ~ORG_GTD_BLOCKS: B C~, then:
- Task B should have ~ORG_GTD_DEPENDS_ON: A~
- Task C should have ~ORG_GTD_DEPENDS_ON: A~

*How it's set*:
- Automatically maintained when setting ORG_GTD_DEPENDS_ON (bidirectional)
- Programmatically via ~org-gtd-dependencies-create~ (handles bidirectional updates)

*For interactive use*: Use graph view or text-based task commands - they maintain the bidirectional relationship automatically.

**** ORG_GTD_PROJECT_IDS

*Used on*: Tasks

*Purpose*: Lists project IDs this task belongs to (supports multi-project tasks)

*Format*: Space-separated list of project IDs

*Note*: Currently org-gtd creates one project per task, but this property supports future multi-project features.

*** Calendar and Time Properties

**** ORG_GTD_TIMESTAMP

*Used on*: Calendar items, delegated items

*Purpose*: Stores the appointment time or follow-up date

*Format*: Org timestamp (inactive timestamp)

*Example*:
#+begin_example
,* Doctor appointment
:PROPERTIES:
:ORG_GTD: Calendar
:ORG_GTD_TIMESTAMP: [2025-10-15 Wed 14:00]
:END:
#+end_example

*Why not use SCHEDULED*: org-gtd uses a custom property to distinguish between "do this at this time" (GTD calendar items) and "start working on this sometime after this date" (org-mode scheduling).

*How it's set*:
- Automatically by ~org-gtd-organize~ when organizing items as calendar items
- Programmatically when creating calendar items

*For interactive use*: Use ~org-gtd-organize~ to change calendar items.

*** Delegation Properties

**** DELEGATED_TO

*Used on*: Delegated items

*Purpose*: Stores the name of person/team the task is delegated to

*Format*: String (person's name)

*Example*:
#+begin_example
,* Review document
:PROPERTIES:
:ORG_GTD: Delegated
:DELEGATED_TO: Alice Smith
:ORG_GTD_TIMESTAMP: [2025-10-18 Fri]
:END:
#+end_example

*How it's set*:
- Automatically by ~org-gtd-organize~ when organizing as delegated item
- Automatically by ~org-gtd-delegate-agenda-item~ from agenda
- Programmatically when creating delegated items

*For interactive use*: Use ~org-gtd-delegate-agenda-item~ or organize flow.

*Customization*: Set ~org-gtd-delegate-read-func~ to customize how names are entered (e.g., for completion).

*** Habit Properties

**** STYLE

*Used on*: Habits

*Purpose*: Identifies item as an org-mode habit

*Value*: ~"habit"~

*Example*:
#+begin_example
,* TODO Exercise
SCHEDULED: <2025-10-11 Fri .+1d>
:PROPERTIES:
:STYLE: habit
:END:
#+end_example

*Note*: This is a standard org-mode habit property. See org-mode documentation for habit repeat patterns and configuration.

*** Area of Focus Properties

**** CATEGORY

*Used on*: All items (when using areas of focus)

*Purpose*: Identifies which area of focus (GTD Horizon 2) an item belongs to

*Format*: String matching value from ~org-gtd-areas-of-focus~

*Example*:
#+begin_example
,* Finish quarterly report
:PROPERTIES:
:ORG_GTD: Actions
:CATEGORY: Work
:END:
#+end_example

*When to set*:
- During organize, if ~org-gtd-set-area-of-focus~ is in ~org-gtd-organize-hooks~
- Manually with ~org-gtd-area-of-focus-set-on-item-at-point~
- From agenda with ~org-gtd-area-of-focus-set-on-agenda-item~

*Use*: Filter views by area with ~org-gtd-review-area-of-focus~ or custom views.

*** Standard Org Properties Used by org-gtd

**** ID

*Used on*: All GTD items

*Purpose*: Unique identifier for the item (org-mode standard)

*Format*: Auto-generated UUID

*Note*: org-gtd relies heavily on IDs for task relationships. Don't delete ID properties.

**** TODO keyword

*Not a property, but a heading keyword*

*Values used by org-gtd*:
- Value from ~org-gtd-keyword-mapping~'s ~todo~ key (default "TODO")
- Value from ~org-gtd-keyword-mapping~'s ~next~ key (default "NEXT")
- Value from ~org-gtd-keyword-mapping~'s ~wait~ key (default "WAIT")
- Value from ~org-gtd-keyword-mapping~'s ~done~ key (default "DONE")
- Value from ~org-gtd-keyword-mapping~'s ~canceled~ key (default "CNCL")

**** SCHEDULED (org-mode standard)

*Used on*: Habits primarily

*Purpose*: For org-mode habits, defines repeat pattern

*Note*: org-gtd uses ORG_GTD_TIMESTAMP for calendar items instead of SCHEDULED to maintain GTD semantics.

**** DEADLINE (org-mode standard)

*Used on*: Items with hard deadlines

*Purpose*: Mark items that must be done by a specific date

*Note*: org-gtd respects org-mode deadlines in all views and oops checks.

** Troubleshooting Projects
:PROPERTIES:
:DESCRIPTION: How to fix project dependency problems
:CUSTOM_ID: troubleshooting-projects
:END:

This section covers how to fix problems with project dependencies. *You should rarely need this* - the graph view and task management commands handle dependencies correctly. If you find yourself needing these troubleshooting steps frequently, that indicates a bug - please file an issue!

*** Fixing Broken Dependencies

If you encounter dependency problems (circular dependencies, broken references, orphaned tasks):

1. *Validate project structure*:
   - Put point on project heading
   - Run ~M-x org-gtd-validate-project-dependencies~
   - This detects broken references, orphaned tasks, and circular dependencies
   - Follow the guidance provided

2. *Visual inspection with graph view*:
   - Run ~M-x org-gtd-show-project-graph~
   - Visual inspection often makes problems obvious
   - Missing arrows? Use ~a~ to add missing dependencies
   - Wrong arrows? Use ~d~ to remove incorrect dependencies
   - Task with too many relationships? Use ~i~ to inspect, ~x~ to clear all

3. *Clear and rebuild*:
   If task relationships are completely corrupted:
   - In graph view: Select the problematic task, press ~x~ to clear all relationships
   - Or in text: Put point on task, run ~M-x org-gtd-task-clear-relationships~
   - Rebuild dependencies using graph view add commands (~a~, ~a c~, ~a b~)

*** When Manual Property Editing is Needed

*You should never need to manually edit properties during normal use.*

The ONLY cases where manual property editing might be necessary:

1. *Writing elisp automation/integration code*
   - See [[#properties-reference][Properties Reference]] for property documentation
   - Use programmatic functions: ~org-gtd-dependencies-create~, ~org-entry-add-to-multivalued-property~, etc.
   - Never manipulate properties directly from interactive commands

2. *Debugging org-gtd internals*
   - If you suspect a bug in org-gtd's property management
   - Compare properties with graph view to identify discrepancies
   - File an issue with details!

3. *Migrating data from another system*
   - If importing projects from external tools
   - Batch property updates may be more efficient
   - Validate with ~org-gtd-validate-project-dependencies~ afterward

4. *Emergency recovery from data corruption*
   - Only as last resort if graph view and commands fail
   - After manual edits, run ~org-gtd-projects-fix-todo-keywords-for-project-at-point~ (one project)
   - Or run ~org-gtd-projects-fix-all-todo-keywords~ to fix all projects at once
   - Consider this a bug and file an issue

*If you find yourself manually editing properties regularly*, that indicates missing features. Please file an issue describing your workflow - we'll add the missing commands!

*** Common Problems and Solutions

**** Project Shows No NEXT Tasks (Stuck Project)

*Symptom*: Project has incomplete tasks but none are NEXT.

*Diagnosis*:
- Run ~M-x org-gtd-show-project-graph~
- Look for green boxes (NEXT tasks)
- If no green boxes, check for:
  - Circular dependencies (arrows forming a loop)
  - All tasks waiting on incomplete tasks
  - Missing ORG_GTD_FIRST_TASKS property

*Solution*:
- Fix circular dependencies: Use ~d~ to remove incorrect dependencies
- Add root tasks: Use ~a r~ or ~a b~ to create tasks that can start immediately
- Run ~org-gtd-validate-project-dependencies~ for detailed diagnosis

**** Too Many NEXT Tasks

*Symptom*: Project shows 10+ green boxes in graph view.

*Diagnosis*: Tasks that should be dependent are independent.

*Solution*:
- In graph view, identify tasks that should depend on others
- Use ~a~ to add dependencies between tasks
- Or restructure: tasks later in workflow should be children (~a c~) of earlier tasks

**** Task Won't Advance to NEXT

*Symptom*: Completed a task, but dependent task still shows TODO (gray).

*Diagnosis*:
- In graph view, select the gray task
- Press ~i~ to show relationships
- Check if all blockers are actually DONE

*Solution*:
- If blockers are DONE but showing as blocking: Press ~r~ to refresh graph
- If blocker shouldn't block this task: Use ~d~ to remove the dependency
- If multiple wrong dependencies: Use ~x~ to clear all, rebuild with ~a~

**** Task States Inconsistent After External Edits

*Symptom*: After editing on mobile app or resolving sync conflicts, task states don't match dependencies.

*Examples*:
- Tasks marked NEXT but blocked by incomplete dependencies
- Tasks stuck in TODO when they should be NEXT
- Multiple projects showing inconsistent states

*Diagnosis*:
- External tools (mobile apps, web interfaces) don't understand org-gtd dependency logic
- Manual edits or sync conflicts disrupted task states
- Affects all projects if you edited multiple files

*Solution*:
- For one project: Put point on project heading, run ~M-x org-gtd-projects-fix-todo-keywords-for-project-at-point~
- For all projects: Run ~M-x org-gtd-projects-fix-all-todo-keywords~

*Recommended workflow after mobile edits*:
1. Sync files to Emacs
2. Run ~M-x org-gtd-projects-fix-all-todo-keywords~
3. Verify with ~M-x org-gtd-engage~ - should show correct NEXT tasks

** View DSL Filter Reference
:PROPERTIES:
:DESCRIPTION: Complete reference for the View DSL
:CUSTOM_ID: view-dsl-reference
:END:

The View DSL (Domain-Specific Language) lets you create custom agenda views using simple, declarative syntax. This section documents all available filters.

*** View Structure

A GTD view is defined as an alist:

#+begin_src emacs-lisp
'((name . "View Name")
  (filters . ((filter-type . filter-value) ...)))
#+end_src

Multiple filters create AND logic (all must match).

*** Category Filters

Filter by GTD item category:

**** ~(category . delegated)~

*Matches*: Items with DELEGATED_TO property

*Use case*: See all delegated tasks

*Example*:
#+begin_src emacs-lisp
'((name . "All Delegations")
  (filters . ((category . delegated))))
#+end_src

**** ~(category . calendar)~

*Matches*: Items with ~ORG_GTD="Calendar"~

*Use case*: See all calendar items/appointments

*Example*:
#+begin_src emacs-lisp
'((name . "Calendar Items")
  (filters . ((category . calendar))))
#+end_src

**** ~(category . projects)~

*Matches*: Project headings (~ORG_GTD="Projects"~)

*Use case*: List all projects

*Example*:
#+begin_src emacs-lisp
'((name . "All Projects")
  (filters . ((category . projects))))
#+end_src

**** ~(category . active-projects)~

*Matches*: Projects with at least one active (non-done) task

*Use case*: See projects with work remaining

*Example*:
#+begin_src emacs-lisp
'((name . "Active Projects")
  (filters . ((category . active-projects))))
#+end_src

**** ~(category . completed-projects)~

*Matches*: Projects where all tasks are DONE

*Use case*: Weekly review to see completed projects ready to archive

*Example*:
#+begin_src emacs-lisp
'((name . "Completed Projects")
  (filters . ((category . completed-projects))))
#+end_src

**** ~(category . stuck-projects)~

*Matches*: Projects with active tasks but no NEXT or WAIT tasks

*Use case*: Find projects needing attention (dependency problems)

*Example*:
#+begin_src emacs-lisp
'((name . "Stuck Projects")
  (filters . ((category . stuck-projects))))
#+end_src

**** ~(category . incubate)~

*Matches*: Items with ~ORG_GTD="Incubated"~ (someday/maybe)

*Use case*: Review someday/maybe list

*Example*:
#+begin_src emacs-lisp
'((name . "Someday/Maybe")
  (filters . ((category . incubate))))
#+end_src

**** ~(category . habit)~

*Matches*: Items with ~STYLE="habit"~

*Use case*: See all habits

*Example*:
#+begin_src emacs-lisp
'((name . "All Habits")
  (filters . ((category . habit))))
#+end_src

*** Time-based Filters

Filter by timestamps, deadlines, and scheduled dates:

**** ~(timestamp . past)~

*Matches*: Items with ~ORG_GTD_TIMESTAMP~ in the past that aren't done

*Use case*: Missed appointments and follow-ups

*Example*:
#+begin_src emacs-lisp
'((name . "Missed Appointments")
  (filters . ((category . calendar)
              (timestamp . past))))
#+end_src

**** ~(timestamp . future)~

*Matches*: Items with ~ORG_GTD_TIMESTAMP~ in the future

*Use case*: Upcoming appointments

*Example*:
#+begin_src emacs-lisp
'((name . "Upcoming Appointments")
  (filters . ((category . calendar)
              (timestamp . future))))
#+end_src

**** ~(deadline . past)~

*Matches*: Items with deadline in the past that aren't done

*Use case*: Overdue items

*Example*:
#+begin_src emacs-lisp
'((name . "Overdue Items")
  (filters . ((deadline . past))))
#+end_src

**** ~(scheduled . past)~

*Matches*: Items scheduled in the past that aren't done

*Use case*: Find items that should have started

*Example*:
#+begin_src emacs-lisp
'((name . "Overdue Start Dates")
  (filters . ((scheduled . past))))
#+end_src

**** ~(scheduled . future)~

*Matches*: Items scheduled in the future

*Use case*: See what's coming up

*Example*:
#+begin_src emacs-lisp
'((name . "Future Scheduled")
  (filters . ((scheduled . future))))
#+end_src

**** ~(scheduled . today)~

*Matches*: Items scheduled for today

*Use case*: Today's habits and scheduled actions

*Example*:
#+begin_src emacs-lisp
'((name . "Today's Scheduled Items")
  (filters . ((scheduled . today))))
#+end_src

**** ~(closed . recent)~

*Matches*: Items closed in last 7 days

*Use case*: Weekly review accomplishments

*Example*:
#+begin_src emacs-lisp
'((name . "Recent Completions")
  (filters . ((closed . recent))))
#+end_src

**** ~(closed . past-day)~

*Matches*: Items closed in last day

**** ~(closed . past-week)~

*Matches*: Items closed in last week

**** ~(closed . past-month)~

*Matches*: Items closed in last month

**** ~(closed . past-year)~

*Matches*: Items closed in last year

**** ~(closed . today)~

*Matches*: Items closed today

*Use case*: End-of-day review

*Example*:
#+begin_src emacs-lisp
'((name . "Completed Today")
  (filters . ((closed . today))))
#+end_src

*** TODO Keyword Filters

Filter by TODO state:

**** ~(todo . ("KEYWORD1" "KEYWORD2"))~

*Matches*: Items with any of the specified TODO keywords

*Use case*: Show specific states

*Example*: Show only NEXT actions:
#+begin_src emacs-lisp
'((name . "NEXT Actions Only")
  (filters . ((todo . ("NEXT")))))
#+end_src

*Example*: Show NEXT and WAIT:
#+begin_src emacs-lisp
'((name . "Active and Waiting")
  (filters . ((todo . ("NEXT" "WAIT")))))
#+end_src

**** ~(done . t)~

*Matches*: Items with done TODO states (right side of ~|~ in keyword sequence)

*Use case*: Show completed items

*Example*:
#+begin_src emacs-lisp
'((name . "Completed Items")
  (filters . ((done . t))))
#+end_src

*** Area of Focus Filters

Filter by life area:

**** ~(area-of-focus . "AREA")~

*Matches*: Items with ~CATEGORY="AREA"~

*Use case*: Focus on specific life area

*Example*:
#+begin_src emacs-lisp
'((name . "Work Items")
  (filters . ((area-of-focus . "Work"))))
#+end_src

*Example*: Work projects only:
#+begin_src emacs-lisp
'((name . "Work Projects")
  (filters . ((category . active-projects)
              (area-of-focus . "Work"))))
#+end_src

*** Tag Filters

Filter by org tags:

**** ~(tags . ("TAG1" "TAG2"))~

*Matches*: Items with any of the specified tags

*Use case*: Filter by context, priority, or custom tags

*Example*:
#+begin_src emacs-lisp
'((name . "Home and Errands")
  (filters . ((todo . ("NEXT"))
              (tags . ("@home" "@errands")))))
#+end_src

**** ~(tags-match . "PATTERN")~

*Matches*: Items matching org-mode tag expression pattern

*Use case*: Complex tag queries

*Example*: All items with context tags (tags starting with @):
#+begin_src emacs-lisp
'((name . "Context-Tagged Items")
  (filters . ((tags-match . "{^@}"))))
#+end_src

*Org tag expressions*:
- ~"tag1|tag2"~ :: Has tag1 OR tag2
- ~"tag1&tag2"~ :: Has tag1 AND tag2
- ~"{^@}"~ :: Has any tag starting with @

*** Property Filters

Filter by arbitrary org properties:

**** ~(property . (("PROP" . "VALUE")))~

*Matches*: Items with specified property value

*Use case*: Filter by custom properties

*Example*:
#+begin_src emacs-lisp
'((name . "High Priority Actions")
  (filters . ((property . (("PRIORITY" . "A")))
              (todo . ("NEXT")))))
#+end_src

*Example*: Multiple property filters:
#+begin_src emacs-lisp
'((name . "Project Tasks")
  (filters . ((property . (("ORG_GTD" . "Actions"))))))
#+end_src

*** Structural Filters

Filter by org heading structure:

**** ~(level . N)~

*Matches*: Headings at level N

*Use case*: Show only top-level items

*Example*: Top-level projects only:
#+begin_src emacs-lisp
'((name . "Top-Level Projects")
  (filters . ((category . projects)
              (level . 2))))
#+end_src

*Note*: org-gtd projects are typically at level 2 in their files (under a category heading at level 1).

*** Special Filters

**** ~(not-habit . t)~

*Matches*: Items that are NOT habits

*Use case*: Exclude habits from views

*Example*:
#+begin_src emacs-lisp
'((name . "NEXT Actions (No Habits)")
  (filters . ((todo . ("NEXT"))
              (not-habit . t))))
#+end_src

**** ~(invalid-timestamp . t)~

*Matches*: Items with missing or malformed ~ORG_GTD_TIMESTAMP~ property

*Use case*: Data validation, finding broken calendar/delegate items

*Example*:
#+begin_src emacs-lisp
'((name . "Items with Invalid Timestamps")
  (filters . ((invalid-timestamp . t))))
#+end_src

*** View Configuration Options

These options control how the view is displayed:

**** ~(view-type . agenda)~

*Purpose*: Create a native org-agenda view instead of org-ql block

*Use case*: When you want a day/week agenda view

*Example*:
#+begin_src emacs-lisp
'((name . "Weekly Agenda")
  (view-type . agenda)
  (agenda-span . 7)
  (filters . ()))
#+end_src

**** ~(agenda-span . N)~

*Purpose*: Number of days to show in agenda view

*Default*: 1

*Requires*: ~(view-type . agenda)~

*Example*: Week view:
#+begin_src emacs-lisp
'((name . "Week Ahead")
  (view-type . agenda)
  (agenda-span . 7))
#+end_src

**** ~(show-habits . t)~ or ~(show-habits . nil)~

*Purpose*: Control habit visibility in agenda views

*Default*: Habits shown

*Requires*: ~(view-type . agenda)~

*Example*: Agenda without habits:
#+begin_src emacs-lisp
'((name . "Today (No Habits)")
  (view-type . agenda)
  (show-habits . nil))
#+end_src

**** ~(additional-blocks . BLOCK-SPECS)~

*Purpose*: Add additional agenda blocks to the view

*Format*: List of block specifications

*Example*: Agenda + NEXT actions:
#+begin_src emacs-lisp
'((name . "Today + Actions")
  (view-type . agenda)
  (additional-blocks . ((todo . "NEXT"))))
#+end_src

**** ~(prefix-format . FORMAT-STRING)~

*Purpose*: Custom agenda prefix format

*Use case*: Customize how items appear in agenda

*Example*:
#+begin_src emacs-lisp
'((name . "Custom Format View")
  (view-type . agenda)
  (prefix-format . "  %-12:c %?-12t% s"))
#+end_src

*** Complete View Examples

**** Weekly Review View

#+begin_src emacs-lisp
(defun my-weekly-review ()
  "Weekly review showing completed items, active projects, and stuck projects."
  (interactive)
  (org-agenda nil "w")
  (let ((org-agenda-custom-commands
         '(("w" "Weekly Review"
            ((org-ql-block '(and (property "ORG_GTD" "Projects")
                                 (project-has-active-tasks))
                           ((org-ql-block-header "Active Projects")))
             (org-ql-block '(and (property "ORG_GTD" "Projects")
                                 (project-is-stuck))
                           ((org-ql-block-header "Stuck Projects")))
             (org-ql-block '(closed :from "-7d")
                           ((org-ql-block-header "Completed This Week"))))))))
    (org-agenda nil "w")))
#+end_src

**** Context-Based View

#+begin_src emacs-lisp
(defun my-contexts-view ()
  "Show NEXT actions grouped by context."
  (interactive)
  (org-gtd-engage-grouped-by-context))
#+end_src

**** Morning Planning View

#+begin_src emacs-lisp
(defun my-morning-view ()
  "Morning planning: today's agenda, NEXT actions, and delegations to follow up."
  (interactive)
  (org-gtd-view-show
   '((name . "Morning Planning")
     (view-type . agenda)
     (agenda-span . 1)
     (additional-blocks . ((todo . "NEXT"))))))
#+end_src

*** Creating Custom Views

To create a custom view:

1. *Define the view specification*:
   #+begin_src emacs-lisp
   (defun my-custom-view ()
     "Description of what this view shows."
     (interactive)
     (org-gtd-view-show
      '((name . "View Name")
        (filters . ((filter1 . value1)
                    (filter2 . value2))))))
   #+end_src

2. *Bind to a key* (optional):
   #+begin_src emacs-lisp
   (global-set-key (kbd "C-c d v") 'my-custom-view)
   #+end_src

3. *Test and refine* - Run the view and adjust filters as needed

** Hooks Framework Reference
:PROPERTIES:
:DESCRIPTION: Complete guide to customization hooks
:CUSTOM_ID: hooks-reference
:END:

*** What Are Organize Hooks?

Hooks let you automatically capture information about tasks as you organize them—like tracking when tasks were created, auto-tagging items with "urgent" in the title, or estimating effort based on keywords.

Without hooks, you'd manually add the same metadata to every task. With hooks, you define the pattern once and org-gtd applies it automatically during organization.

For anyone who wants consistent metadata on their GTD items without repetitive manual work.

*** Your First Hook in 2 Minutes

Let's add automatic creation timestamps to all tasks except trash and quick actions.

1. Add this to your config:
   #+begin_src emacs-lisp
   (defun my-track-creation-date ()
     "Add CREATED property with current timestamp."
     (unless (org-gtd-organize-type-member-p '(trash quick))
       (org-set-property "CREATED"
                         (format-time-string "[%Y-%m-%d %a %H:%M]"))))

   (add-to-list 'org-gtd-organize-hooks 'my-track-creation-date)
   #+end_src

2. Restart Emacs (or eval the code with ~C-x C-e~)

3. Capture something: ~M-x org-gtd-capture~, type "Test task", finish capture

4. Process it: ~M-x org-gtd-process-inbox~, organize as "Single action"

5. Look at the task: you'll see a CREATED property with today's timestamp

You just automated metadata capture. Every item you organize now gets timestamped automatically.

*** The org-gtd-organize-hooks Variable

*Type*: List of functions

*When run*: During ~org-gtd-organize~, after you choose item type but before refiling

*Purpose*: Add metadata (tags, properties, etc.) to items as they're organized

*Default value*: ~'(org-set-tags-command)~

*** Built-in Hooks

**** ~org-set-tags-command~

*What it does*: Prompts for tags to add to the item

*Use when*: You want to tag items during organization (default)

*To use*:
#+begin_src emacs-lisp
(setq org-gtd-organize-hooks '(org-set-tags-command))
#+end_src

**** ~org-gtd-set-area-of-focus~

*What it does*: Prompts for area of focus (from ~org-gtd-areas-of-focus~) and sets CATEGORY property

*Use when*: You use GTD Horizon 2 (areas of focus)

*To use*:
#+begin_src emacs-lisp
(setq org-gtd-organize-hooks '(org-set-tags-command
                               org-gtd-set-area-of-focus))
#+end_src

*Behavior*: Skips prompt for:
- Project tasks (sets on project instead)
- Trash items
- Knowledge items
- Quick actions

*** Writing Custom Hooks

Custom hooks are functions that run during organization. They can:
- Add properties
- Set tags
- Modify heading text
- Prompt for information
- Skip certain item types

**** Basic Hook Structure

#+begin_src emacs-lisp
(defun my-organize-hook ()
  "Description of what this hook does."
  (interactive)  ;; hooks can be interactive or not
  ;; Your code here
  ;; Point will be on the heading being organized
  ;; Use org-mode functions to modify it
  )
#+end_src

**** Using org-gtd-organize-type-member-p

This helper function lets you run code only for specific item types.

*Function signature*:
#+begin_src emacs-lisp
(org-gtd-organize-type-member-p TYPE-LIST)
#+end_src

*Arguments*:
- ~TYPE-LIST~ :: List of item type symbols to check against

*Returns*: ~t~ if current item matches one of the types, ~nil~ otherwise

*Available types*:
- ~'action~ :: Single actions
- ~'project~ :: Project headings
- ~'project-task~ :: Tasks within projects
- ~'calendar~ :: Calendar items
- ~'delegate~ :: Delegated items
- ~'incubate~ :: Someday/maybe items
- ~'habit~ :: Habits
- ~'knowledge~ :: Reference items
- ~'quick~ :: Quick actions (<2 min)
- ~'trash~ :: Trashed items

*Example*: Only run for actions and projects:
#+begin_src emacs-lisp
(defun my-hook ()
  (when (org-gtd-organize-type-member-p '(action project))
    ;; do something
    ))
#+end_src

*** Example Custom Hooks

**** Selective Tagging with Unless

The most common pattern is "run this hook for everything EXCEPT certain types". This example prompts for tags on all items except trash and knowledge (reference):

#+begin_src emacs-lisp
(defun my-tag-tasks ()
  "Prompt for tags on all items except trash and knowledge."
  (unless (org-gtd-organize-type-member-p '(trash knowledge))
    (org-set-tags-command)))

(setq org-gtd-organize-hooks '(my-tag-tasks))
#+end_src

This replaces the default ~org-set-tags-command~ with selective tagging. The ~unless~ pattern is cleaner than listing all the types you DO want: it says "skip these few, run for everything else."

**** Add Effort Estimation

#+begin_src emacs-lisp
(defun my-add-effort ()
  "Prompt for effort estimation when organizing actions and projects."
  (when (org-gtd-organize-type-member-p '(action project))
    (call-interactively #'org-set-effort)))

(add-to-list 'org-gtd-organize-hooks 'my-add-effort)
#+end_src

**** Add Priority

#+begin_src emacs-lisp
(defun my-add-priority ()
  "Prompt for priority when organizing actions."
  (when (org-gtd-organize-type-member-p '(action))
    (call-interactively #'org-priority)))

(add-to-list 'org-gtd-organize-hooks 'my-add-priority)
#+end_src

**** Auto-Set Property Based on Keywords

#+begin_src emacs-lisp
(defun my-auto-tag-urgent ()
  "Automatically tag items with 'urgent' in their heading."
  (when (org-gtd-organize-type-member-p '(action project))
    (let ((heading (org-get-heading t t t t)))
      (when (string-match-p (regexp-quote "URGENT") heading)
        (org-set-tags ":urgent:")))))

(add-to-list 'org-gtd-organize-hooks 'my-auto-tag-urgent)
#+end_src

**** Add Custom Property

#+begin_src emacs-lisp
(defun my-add-client ()
  "Prompt for client name on work-related items."
  (when (org-gtd-organize-type-member-p '(action project))
    (when (y-or-n-p "Is this for a client? ")
      (let ((client (read-string "Client name: ")))
        (org-set-property "CLIENT" client)))))

(add-to-list 'org-gtd-organize-hooks 'my-add-client)
#+end_src

**** Integration with Org-Roam

#+begin_src emacs-lisp
(defun my-link-to-roam-project ()
  "Link GTD project to Org-Roam note."
  (when (org-gtd-organize-type-member-p '(project))
    (when (y-or-n-p "Link to Org-Roam note? ")
      (org-roam-node-insert))))

(add-to-list 'org-gtd-organize-hooks 'my-link-to-roam-project)
#+end_src

**** Set Effort from Keywords

#+begin_src emacs-lisp
(defun my-auto-set-effort ()
  "Automatically set effort based on keywords in heading."
  (when (org-gtd-organize-type-member-p '(action))
    (let ((heading (downcase (org-get-heading t t t t))))
      (cond
       ((string-match-p "quick\\|call\\|email" heading)
        (org-set-property "Effort" "0:15"))
       ((string-match-p "meeting\\|review" heading)
        (org-set-property "Effort" "1:00"))
       ((string-match-p "research\\|write\\|design" heading)
        (org-set-property "Effort" "2:00"))))))

(add-to-list 'org-gtd-organize-hooks 'my-auto-set-effort)
#+end_src

*** Hook Execution Order

Hooks run in the order they appear in ~org-gtd-organize-hooks~.

*Example*: Set area first, then tags:
#+begin_src emacs-lisp
(setq org-gtd-organize-hooks
      '(org-gtd-set-area-of-focus  ;; runs first
        org-set-tags-command))      ;; runs second
#+end_src

This order matters if one hook depends on another's results.

*** Best Practices

1. *Use type checking*: Always use ~org-gtd-organize-type-member-p~ to run hooks only for relevant item types

2. *Keep hooks focused*: Each hook should do one thing well

3. *Make hooks optional*: Use ~y-or-n-p~ for optional metadata:
   #+begin_src emacs-lisp
   (when (y-or-n-p "Add custom property? ")
     (org-set-property "PROP" value))
   #+end_src

4. *Test interactively*: Make hooks interactive for testing:
   #+begin_src emacs-lisp
   (defun my-hook ()
     (interactive)  ;; can test with M-x my-hook
     ...)
   #+end_src

5. *Handle errors gracefully*: Wrap risky code in condition-case:
   #+begin_src emacs-lisp
   (condition-case err
       (my-risky-operation)
     (error (message "Hook failed: %s" err)))
   #+end_src

6. *Document your hooks*: Add docstrings explaining what each hook does

*** Complete Example: Comprehensive Hook Setup

#+begin_src emacs-lisp
;; Custom hooks for org-gtd
(defun my-add-effort ()
  "Prompt for effort on actions and projects."
  (when (org-gtd-organize-type-member-p '(action project))
    (call-interactively #'org-set-effort)))

(defun my-add-priority ()
  "Prompt for priority on actions."
  (when (org-gtd-organize-type-member-p '(action))
    (call-interactively #'org-priority)))

(defun my-auto-tag-contexts ()
  "Automatically suggest context tags based on heading keywords."
  (when (org-gtd-organize-type-member-p '(action))
    (let* ((heading (downcase (org-get-heading t t t t)))
           (suggested-tags '()))
      (when (string-match-p "\\(phone\\|call\\)" heading)
        (push "@phone" suggested-tags))
      (when (string-match-p "\\(computer\\|code\\|write\\)" heading)
        (push "@computer" suggested-tags))
      (when (string-match-p "\\(store\\|buy\\|shop\\)" heading)
        (push "@errands" suggested-tags))
      (when suggested-tags
        (message "Suggested contexts: %s" (string-join suggested-tags ", "))))))

(defun my-track-creation-date ()
  "Add CREATED property with current timestamp."
  (unless (org-gtd-organize-type-member-p '(trash quick))
    (org-set-property "CREATED"
                      (format-time-string "[%Y-%m-%d %a %H:%M]"))))

;; Install hooks
(setq org-gtd-organize-hooks
      '(org-gtd-set-area-of-focus  ;; set area first
        org-set-tags-command        ;; then tags
        my-auto-tag-contexts        ;; suggest context tags
        my-add-effort               ;; estimate effort
        my-add-priority             ;; set priority if needed
        my-track-creation-date))    ;; track when created
#+end_src

This creates a comprehensive metadata capture workflow during organization.

* Troubleshooting
:PROPERTIES:
:CUSTOM_ID: troubleshooting
:END:

This section covers common problems and their solutions. For complete command documentation, see [[#commands-reference][Commands Reference]].

** Finding lost tasks

Sometimes items get stuck or fall through the cracks. org-gtd provides several commands to find problematic items:

- ~org-gtd-review-stuck-calendar-items~ :: Calendar items with invalid or missing timestamps
- ~org-gtd-review-stuck-incubated-items~ :: Incubated items with invalid or missing review dates
- ~org-gtd-review-stuck-habit-items~ :: Habits with incorrect configuration
- ~org-gtd-review-stuck-delegated-items~ :: Delegated items missing delegate or date information
- ~org-gtd-review-stuck-single-action-items~ :: Single actions that aren't marked as NEXT
- ~org-gtd-review-stuck-projects~ :: Projects that have tasks but no NEXT actions
- ~org-gtd-review-missed-items~ :: Items that should have been processed but weren't

See [[#commands-reference][Commands Reference]] for detailed documentation of these commands.

** Projects without a NEXT item

If a project has active tasks but none are marked NEXT, this usually indicates:
1. Missing dependency configuration (no ~ORG_GTD_FIRST_TASKS~ property)
2. org-edna is not enabled
3. Dependency properties need recalculation
4. Task states are inconsistent after external edits (mobile apps, sync conflicts)

*Solution for one project*: Put the point on the project heading and run ~M-x org-gtd-projects-fix-todo-keywords-for-project-at-point~.

*Solution for all projects*: Run ~M-x org-gtd-projects-fix-all-todo-keywords~ to fix all projects at once. This is especially useful after:
- Editing tasks on mobile apps or web interfaces
- Resolving sync conflicts
- Bulk manual edits outside org-gtd
- Migrating or importing data

*Note*: Make sure org-edna is enabled: ~(org-edna-mode 1)~ in your init file. See [[#configuring][Configuring]] for setup instructions.

See also: [[#working-with-projects-advanced][Working with Projects (Advanced)]] for complete project troubleshooting guide.

** I can't create a project when clarifying an inbox item!

When organizing an item as a project, org-gtd expects a specific structure:

#+begin_example
,* Project heading
,** First task
,** Second task
,** Third task
#+end_example

*Common issues*:
- Top-level heading must be a single asterisk ~*~
- Tasks must be second-level headings ~**~
- Must have at least one task under the project heading

See [[#data-shape-requirement-while-clarifying][data shape requirements]] for complete details.

If this doesn't solve your problem, please open an issue at https://github.com/Trevoke/org-gtd.el/issues with:
1. The exact structure of your item in the clarify buffer
2. What happens when you try to organize it
3. Any error messages

** Configuration problems

*** Keywords not working

If TODO keywords aren't changing correctly:

1. *Check ~org-todo-keywords~ includes all GTD keywords in one sequence*:
   #+begin_src emacs-lisp
   (setq org-todo-keywords
         '((sequence "TODO" "NEXT" "WAIT" "|" "DONE" "CNCL")))
   #+end_src

2. *Check ~org-gtd-keyword-mapping~ maps to those keywords*:
   #+begin_src emacs-lisp
   (setq org-gtd-keyword-mapping
         '((todo . "TODO")
           (next . "NEXT")
           (wait . "WAIT")
           (done . "DONE")
           (canceled . "CNCL")))
   #+end_src

3. *Remove any ~#+TODO:~ lines from GTD org files*

See [[#configuring][Configuring]] for complete setup instructions.

*** Items not showing in engage view

If items aren't appearing in ~org-gtd-engage~:

1. *Check org-agenda-files includes org-gtd-directory*:
   #+begin_src emacs-lisp
   (setq org-agenda-files (list org-gtd-directory))
   #+end_src

2. *Check item has correct properties*:
   - Single actions should have ~ORG_GTD: Actions~ and TODO keyword NEXT
   - Project tasks should have ~ORG_GTD: Actions~ and be part of a project

3. *Verify org-edna is enabled*:
   #+begin_src emacs-lisp
   (org-edna-mode 1)
   #+end_src

See [[#config-vars-reference][Configuration Variables Reference]] for all configuration options.

** Tasks still showing after incubating project

*Symptom*: Incubated a project but some tasks still appear in engage view.

*Diagnosis*:
- Multi-project tasks (tasks shared between projects) are not incubated
- If task belongs to Project A and Project B, and you only incubate Project A, the task stays visible

*Solution*:
- Check task's ORG_GTD_PROJECT_IDS property to see which projects it belongs to
- Either incubate all projects the task belongs to, or remove it from one project first
- During incubation, watch for "Skipping multi-project task" messages

*Recommended workflow*:
1. Before incubating: review the project for multi-project tasks
2. Decide: should this task stay active (part of other project) or be incubated too?
3. If incubating: incubate all projects it belongs to
4. If staying active: accept that it will remain visible

** Still stuck?

If you're still having problems:

1. Check [[#reference][Reference]] for complete documentation
2. Search existing issues: https://github.com/Trevoke/org-gtd.el/issues
3. Ask on Discord: https://discord.gg/2kAK6TfqJq
4. Open a new issue with:
   - Your org-gtd configuration
   - Steps to reproduce the problem
   - Expected vs actual behavior
   - Any error messages
